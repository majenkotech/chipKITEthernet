/home/matt/.uecide/compilers/pic32-gcc/bin/pic32-objdump -h -S /tmp/build-b295745c-7e70-443c-b0ab-0bc75a159f62/ChipKITTelnetServer.elf 

/tmp/build-b295745c-7e70-443c-b0ab-0bc75a159f62/ChipKITTelnetServer.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000010  9d001000  9d001000  00011000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .image_ptr_table 00000008  9d0000f8  9d0000f8  000100f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .app_excpt    00000010  9d000180  9d000180  00010180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .vector_0     00000014  9d000200  9d000200  00010200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .vector_1     00000014  9d000220  9d000220  00010220  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .vector_2     00000014  9d000240  9d000240  00010240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .vector_3     00000014  9d000260  9d000260  00010260  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .vector_4     0000001c  9d000280  9d000280  00010280  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .vector_5     00000014  9d0002a0  9d0002a0  000102a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .vector_6     00000014  9d0002c0  9d0002c0  000102c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .vector_7     00000014  9d0002e0  9d0002e0  000102e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .vector_8     00000014  9d000300  9d000300  00010300  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .vector_9     00000014  9d000320  9d000320  00010320  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .vector_10    00000014  9d000340  9d000340  00010340  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .vector_11    00000014  9d000360  9d000360  00010360  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .vector_12    00000014  9d000380  9d000380  00010380  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .vector_13    00000014  9d0003a0  9d0003a0  000103a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .vector_14    00000014  9d0003c0  9d0003c0  000103c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .vector_15    00000014  9d0003e0  9d0003e0  000103e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .vector_16    00000014  9d000400  9d000400  00010400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .vector_17    00000014  9d000420  9d000420  00010420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .vector_18    00000014  9d000440  9d000440  00010440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .vector_19    00000014  9d000460  9d000460  00010460  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .vector_20    00000014  9d000480  9d000480  00010480  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .vector_21    00000014  9d0004a0  9d0004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .vector_22    00000014  9d0004c0  9d0004c0  000104c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .vector_23    00000014  9d0004e0  9d0004e0  000104e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .vector_24    00000014  9d000500  9d000500  00010500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .vector_25    00000014  9d000520  9d000520  00010520  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .vector_26    00000014  9d000540  9d000540  00010540  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .vector_27    00000014  9d000560  9d000560  00010560  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .vector_28    00000014  9d000580  9d000580  00010580  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .vector_29    00000014  9d0005a0  9d0005a0  000105a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .vector_30    00000014  9d0005c0  9d0005c0  000105c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .vector_31    00000014  9d0005e0  9d0005e0  000105e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .vector_32    00000014  9d000600  9d000600  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .vector_33    00000014  9d000620  9d000620  00010620  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .vector_34    00000014  9d000640  9d000640  00010640  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .vector_35    00000014  9d000660  9d000660  00010660  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .vector_36    00000014  9d000680  9d000680  00010680  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .vector_37    00000014  9d0006a0  9d0006a0  000106a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .vector_38    00000014  9d0006c0  9d0006c0  000106c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .vector_39    00000014  9d0006e0  9d0006e0  000106e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .vector_40    00000014  9d000700  9d000700  00010700  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .vector_41    00000014  9d000720  9d000720  00010720  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .vector_42    00000014  9d000740  9d000740  00010740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .vector_43    00000014  9d000760  9d000760  00010760  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .vector_44    00000014  9d000780  9d000780  00010780  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .vector_45    00000014  9d0007a0  9d0007a0  000107a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .vector_46    00000014  9d0007c0  9d0007c0  000107c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .vector_47    00000014  9d0007e0  9d0007e0  000107e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .vector_48    00000014  9d000800  9d000800  00010800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .vector_49    00000014  9d000820  9d000820  00010820  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .vector_50    00000014  9d000840  9d000840  00010840  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .vector_51    00000014  9d000860  9d000860  00010860  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .vector_52    00000014  9d000880  9d000880  00010880  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .vector_53    00000014  9d0008a0  9d0008a0  000108a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .vector_54    00000014  9d0008c0  9d0008c0  000108c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .vector_55    00000014  9d0008e0  9d0008e0  000108e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .vector_56    00000014  9d000900  9d000900  00010900  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .vector_57    00000014  9d000920  9d000920  00010920  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .vector_58    00000014  9d000940  9d000940  00010940  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .vector_59    00000014  9d000960  9d000960  00010960  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .vector_60    00000014  9d000980  9d000980  00010980  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .vector_61    00000014  9d0009a0  9d0009a0  000109a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .vector_62    00000014  9d0009c0  9d0009c0  000109c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .vector_63    00000014  9d0009e0  9d0009e0  000109e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .startup      000001e0  9d001010  9d001010  00011010  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text         0000c8a0  9d0011f0  9d0011f0  000111f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .init         00000024  9d00da90  9d00da90  0001da90  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .fini         0000001c  9d00dab4  9d00dab4  0001dab4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .ctors        0000000c  9d00dad0  9d00dad0  0001dad0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 72 .dtors        0000000c  9d00dadc  9d00dadc  0001dadc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 73 .header_info  0000004c  9d00dae8  9d00dae8  0001dae8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 74 .ram_exchange_data 00000008  a0000000  a0000000  0002c800  2**0
                  CONTENTS
 75 .rodata       00000c18  9d00db34  9d00db34  0001db34  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .data         00000908  a0000008  9d00e74c  00020008  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 77 .sdata        00000030  a0000910  9d00f054  00020910  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 78 .sbss         00000138  a0000940  9d00f084  00020940  2**3
                  ALLOC
 79 .bss          000090b0  a0000a78  9d00f084  00020a78  2**2
                  ALLOC
 80 .heap         00002000  a0009b28  9d00f084  00029b28  2**0
                  ALLOC
 81 .stack        00000800  a000bb28  9d00f084  0002bb28  2**0
                  ALLOC
 82 .comment      00000095  00000000  00000000  0002c808  2**0
                  CONTENTS, READONLY
 83 .debug_aranges 00001fe0  00000000  00000000  0002c8a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 84 .debug_pubnames 00003346  00000000  00000000  0002e880  2**0
                  CONTENTS, READONLY, DEBUGGING
 85 .debug_info   0004cd23  00000000  00000000  00031bc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 86 .debug_abbrev 0000c3dc  00000000  00000000  0007e8e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 87 .debug_line   000129b0  00000000  00000000  0008acc5  2**0
                  CONTENTS, READONLY, DEBUGGING
 88 .debug_frame  00003c70  00000000  00000000  0009d678  2**2
                  CONTENTS, READONLY, DEBUGGING
 89 .debug_str    00009971  00000000  00000000  000a12e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 90 .debug_loc    00023095  00000000  00000000  000aac59  2**0
                  CONTENTS, READONLY, DEBUGGING
 91 .debug_pubtypes 00004c17  00000000  00000000  000cdcee  2**0
                  CONTENTS, READONLY, DEBUGGING
 92 .debug_ranges 00004c80  00000000  00000000  000d2908  2**3
                  CONTENTS, READONLY, DEBUGGING
 93 .gnu.attributes 00000010  00000000  00000000  000d7588  2**0
                  CONTENTS, READONLY
 94 .mdebug.abi32 00000000  a000c800  a000c800  0002c800  2**0
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .reset:

9d001000 <_reset>:
9d001000:	3c1a9d00 	lui	k0,0x9d00
9d001004:	275a1010 	addiu	k0,k0,4112
9d001008:	03400008 	jr	k0
9d00100c:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d01 	lui	k0,0x9d01
9d000184:	275ac564 	addiu	k0,k0,-15004
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_0>:
    lw       k0,4 * number (k0); \
    jr       k0; \
    .end VECTOR_SYMBOLNAME(number); \
    .size VECTOR_SYMBOLNAME(number), .-VECTOR_SYMBOLNAME(number);

 VECTOR_ENTRY(0)
9d000200:	3c1aa000 	lui	k0,0xa000
9d000204:	275a0008 	addiu	k0,k0,8
9d000208:	8f5a0000 	lw	k0,0(k0)
9d00020c:	03400008 	jr	k0
9d000210:	00000000 	nop

Disassembly of section .vector_1:

9d000220 <__vector_1>:
 VECTOR_ENTRY(1)
9d000220:	3c1aa000 	lui	k0,0xa000
9d000224:	275a0008 	addiu	k0,k0,8
9d000228:	8f5a0004 	lw	k0,4(k0)
9d00022c:	03400008 	jr	k0
9d000230:	00000000 	nop

Disassembly of section .vector_2:

9d000240 <__vector_2>:
 VECTOR_ENTRY(2)
9d000240:	3c1aa000 	lui	k0,0xa000
9d000244:	275a0008 	addiu	k0,k0,8
9d000248:	8f5a0008 	lw	k0,8(k0)
9d00024c:	03400008 	jr	k0
9d000250:	00000000 	nop

Disassembly of section .vector_3:

9d000260 <__vector_3>:
 VECTOR_ENTRY(3)
9d000260:	3c1aa000 	lui	k0,0xa000
9d000264:	275a0008 	addiu	k0,k0,8
9d000268:	8f5a000c 	lw	k0,12(k0)
9d00026c:	03400008 	jr	k0
9d000270:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <__vector_4>:
 VECTOR_ENTRY(4)
9d000280:	3c1aa000 	lui	k0,0xa000
9d000284:	275a0008 	addiu	k0,k0,8
9d000288:	8f5a0010 	lw	k0,16(k0)
9d00028c:	03400008 	jr	k0
9d000290:	00000000 	nop

9d000294 <__vector_dispatch_4>:
9d000294:	0b400b7b 	j	9d002dec <_T1Interrupt>
9d000298:	00000000 	nop

Disassembly of section .vector_5:

9d0002a0 <__vector_5>:
 VECTOR_ENTRY(5)
9d0002a0:	3c1aa000 	lui	k0,0xa000
9d0002a4:	275a0008 	addiu	k0,k0,8
9d0002a8:	8f5a0014 	lw	k0,20(k0)
9d0002ac:	03400008 	jr	k0
9d0002b0:	00000000 	nop

Disassembly of section .vector_6:

9d0002c0 <__vector_6>:
 VECTOR_ENTRY(6)
9d0002c0:	3c1aa000 	lui	k0,0xa000
9d0002c4:	275a0008 	addiu	k0,k0,8
9d0002c8:	8f5a0018 	lw	k0,24(k0)
9d0002cc:	03400008 	jr	k0
9d0002d0:	00000000 	nop

Disassembly of section .vector_7:

9d0002e0 <__vector_7>:
 VECTOR_ENTRY(7)
9d0002e0:	3c1aa000 	lui	k0,0xa000
9d0002e4:	275a0008 	addiu	k0,k0,8
9d0002e8:	8f5a001c 	lw	k0,28(k0)
9d0002ec:	03400008 	jr	k0
9d0002f0:	00000000 	nop

Disassembly of section .vector_8:

9d000300 <__vector_8>:
 VECTOR_ENTRY(8)
9d000300:	3c1aa000 	lui	k0,0xa000
9d000304:	275a0008 	addiu	k0,k0,8
9d000308:	8f5a0020 	lw	k0,32(k0)
9d00030c:	03400008 	jr	k0
9d000310:	00000000 	nop

Disassembly of section .vector_9:

9d000320 <__vector_9>:
 VECTOR_ENTRY(9)
9d000320:	3c1aa000 	lui	k0,0xa000
9d000324:	275a0008 	addiu	k0,k0,8
9d000328:	8f5a0024 	lw	k0,36(k0)
9d00032c:	03400008 	jr	k0
9d000330:	00000000 	nop

Disassembly of section .vector_10:

9d000340 <__vector_10>:
 VECTOR_ENTRY(10)
9d000340:	3c1aa000 	lui	k0,0xa000
9d000344:	275a0008 	addiu	k0,k0,8
9d000348:	8f5a0028 	lw	k0,40(k0)
9d00034c:	03400008 	jr	k0
9d000350:	00000000 	nop

Disassembly of section .vector_11:

9d000360 <__vector_11>:
 VECTOR_ENTRY(11)
9d000360:	3c1aa000 	lui	k0,0xa000
9d000364:	275a0008 	addiu	k0,k0,8
9d000368:	8f5a002c 	lw	k0,44(k0)
9d00036c:	03400008 	jr	k0
9d000370:	00000000 	nop

Disassembly of section .vector_12:

9d000380 <__vector_12>:
 VECTOR_ENTRY(12)
9d000380:	3c1aa000 	lui	k0,0xa000
9d000384:	275a0008 	addiu	k0,k0,8
9d000388:	8f5a0030 	lw	k0,48(k0)
9d00038c:	03400008 	jr	k0
9d000390:	00000000 	nop

Disassembly of section .vector_13:

9d0003a0 <__vector_13>:
 VECTOR_ENTRY(13)
9d0003a0:	3c1aa000 	lui	k0,0xa000
9d0003a4:	275a0008 	addiu	k0,k0,8
9d0003a8:	8f5a0034 	lw	k0,52(k0)
9d0003ac:	03400008 	jr	k0
9d0003b0:	00000000 	nop

Disassembly of section .vector_14:

9d0003c0 <__vector_14>:
 VECTOR_ENTRY(14)
9d0003c0:	3c1aa000 	lui	k0,0xa000
9d0003c4:	275a0008 	addiu	k0,k0,8
9d0003c8:	8f5a0038 	lw	k0,56(k0)
9d0003cc:	03400008 	jr	k0
9d0003d0:	00000000 	nop

Disassembly of section .vector_15:

9d0003e0 <__vector_15>:
 VECTOR_ENTRY(15)
9d0003e0:	3c1aa000 	lui	k0,0xa000
9d0003e4:	275a0008 	addiu	k0,k0,8
9d0003e8:	8f5a003c 	lw	k0,60(k0)
9d0003ec:	03400008 	jr	k0
9d0003f0:	00000000 	nop

Disassembly of section .vector_16:

9d000400 <__vector_16>:
 VECTOR_ENTRY(16)
9d000400:	3c1aa000 	lui	k0,0xa000
9d000404:	275a0008 	addiu	k0,k0,8
9d000408:	8f5a0040 	lw	k0,64(k0)
9d00040c:	03400008 	jr	k0
9d000410:	00000000 	nop

Disassembly of section .vector_17:

9d000420 <__vector_17>:
 VECTOR_ENTRY(17)
9d000420:	3c1aa000 	lui	k0,0xa000
9d000424:	275a0008 	addiu	k0,k0,8
9d000428:	8f5a0044 	lw	k0,68(k0)
9d00042c:	03400008 	jr	k0
9d000430:	00000000 	nop

Disassembly of section .vector_18:

9d000440 <__vector_18>:
 VECTOR_ENTRY(18)
9d000440:	3c1aa000 	lui	k0,0xa000
9d000444:	275a0008 	addiu	k0,k0,8
9d000448:	8f5a0048 	lw	k0,72(k0)
9d00044c:	03400008 	jr	k0
9d000450:	00000000 	nop

Disassembly of section .vector_19:

9d000460 <__vector_19>:
 VECTOR_ENTRY(19)
9d000460:	3c1aa000 	lui	k0,0xa000
9d000464:	275a0008 	addiu	k0,k0,8
9d000468:	8f5a004c 	lw	k0,76(k0)
9d00046c:	03400008 	jr	k0
9d000470:	00000000 	nop

Disassembly of section .vector_20:

9d000480 <__vector_20>:
 VECTOR_ENTRY(20)
9d000480:	3c1aa000 	lui	k0,0xa000
9d000484:	275a0008 	addiu	k0,k0,8
9d000488:	8f5a0050 	lw	k0,80(k0)
9d00048c:	03400008 	jr	k0
9d000490:	00000000 	nop

Disassembly of section .vector_21:

9d0004a0 <__vector_21>:
 VECTOR_ENTRY(21)
9d0004a0:	3c1aa000 	lui	k0,0xa000
9d0004a4:	275a0008 	addiu	k0,k0,8
9d0004a8:	8f5a0054 	lw	k0,84(k0)
9d0004ac:	03400008 	jr	k0
9d0004b0:	00000000 	nop

Disassembly of section .vector_22:

9d0004c0 <__vector_22>:
 VECTOR_ENTRY(22)
9d0004c0:	3c1aa000 	lui	k0,0xa000
9d0004c4:	275a0008 	addiu	k0,k0,8
9d0004c8:	8f5a0058 	lw	k0,88(k0)
9d0004cc:	03400008 	jr	k0
9d0004d0:	00000000 	nop

Disassembly of section .vector_23:

9d0004e0 <__vector_23>:
 VECTOR_ENTRY(23)
9d0004e0:	3c1aa000 	lui	k0,0xa000
9d0004e4:	275a0008 	addiu	k0,k0,8
9d0004e8:	8f5a005c 	lw	k0,92(k0)
9d0004ec:	03400008 	jr	k0
9d0004f0:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_24>:
 VECTOR_ENTRY(24)
9d000500:	3c1aa000 	lui	k0,0xa000
9d000504:	275a0008 	addiu	k0,k0,8
9d000508:	8f5a0060 	lw	k0,96(k0)
9d00050c:	03400008 	jr	k0
9d000510:	00000000 	nop

Disassembly of section .vector_25:

9d000520 <__vector_25>:
 VECTOR_ENTRY(25)
9d000520:	3c1aa000 	lui	k0,0xa000
9d000524:	275a0008 	addiu	k0,k0,8
9d000528:	8f5a0064 	lw	k0,100(k0)
9d00052c:	03400008 	jr	k0
9d000530:	00000000 	nop

Disassembly of section .vector_26:

9d000540 <__vector_26>:
 VECTOR_ENTRY(26)
9d000540:	3c1aa000 	lui	k0,0xa000
9d000544:	275a0008 	addiu	k0,k0,8
9d000548:	8f5a0068 	lw	k0,104(k0)
9d00054c:	03400008 	jr	k0
9d000550:	00000000 	nop

Disassembly of section .vector_27:

9d000560 <__vector_27>:
 VECTOR_ENTRY(27)
9d000560:	3c1aa000 	lui	k0,0xa000
9d000564:	275a0008 	addiu	k0,k0,8
9d000568:	8f5a006c 	lw	k0,108(k0)
9d00056c:	03400008 	jr	k0
9d000570:	00000000 	nop

Disassembly of section .vector_28:

9d000580 <__vector_28>:
 VECTOR_ENTRY(28)
9d000580:	3c1aa000 	lui	k0,0xa000
9d000584:	275a0008 	addiu	k0,k0,8
9d000588:	8f5a0070 	lw	k0,112(k0)
9d00058c:	03400008 	jr	k0
9d000590:	00000000 	nop

Disassembly of section .vector_29:

9d0005a0 <__vector_29>:
 VECTOR_ENTRY(29)
9d0005a0:	3c1aa000 	lui	k0,0xa000
9d0005a4:	275a0008 	addiu	k0,k0,8
9d0005a8:	8f5a0074 	lw	k0,116(k0)
9d0005ac:	03400008 	jr	k0
9d0005b0:	00000000 	nop

Disassembly of section .vector_30:

9d0005c0 <__vector_30>:
 VECTOR_ENTRY(30)
9d0005c0:	3c1aa000 	lui	k0,0xa000
9d0005c4:	275a0008 	addiu	k0,k0,8
9d0005c8:	8f5a0078 	lw	k0,120(k0)
9d0005cc:	03400008 	jr	k0
9d0005d0:	00000000 	nop

Disassembly of section .vector_31:

9d0005e0 <__vector_31>:
 VECTOR_ENTRY(31)
9d0005e0:	3c1aa000 	lui	k0,0xa000
9d0005e4:	275a0008 	addiu	k0,k0,8
9d0005e8:	8f5a007c 	lw	k0,124(k0)
9d0005ec:	03400008 	jr	k0
9d0005f0:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_32>:
 VECTOR_ENTRY(32)
9d000600:	3c1aa000 	lui	k0,0xa000
9d000604:	275a0008 	addiu	k0,k0,8
9d000608:	8f5a0080 	lw	k0,128(k0)
9d00060c:	03400008 	jr	k0
9d000610:	00000000 	nop

Disassembly of section .vector_33:

9d000620 <__vector_33>:
 VECTOR_ENTRY(33)
9d000620:	3c1aa000 	lui	k0,0xa000
9d000624:	275a0008 	addiu	k0,k0,8
9d000628:	8f5a0084 	lw	k0,132(k0)
9d00062c:	03400008 	jr	k0
9d000630:	00000000 	nop

Disassembly of section .vector_34:

9d000640 <__vector_34>:
 VECTOR_ENTRY(34)
9d000640:	3c1aa000 	lui	k0,0xa000
9d000644:	275a0008 	addiu	k0,k0,8
9d000648:	8f5a0088 	lw	k0,136(k0)
9d00064c:	03400008 	jr	k0
9d000650:	00000000 	nop

Disassembly of section .vector_35:

9d000660 <__vector_35>:
 VECTOR_ENTRY(35)
9d000660:	3c1aa000 	lui	k0,0xa000
9d000664:	275a0008 	addiu	k0,k0,8
9d000668:	8f5a008c 	lw	k0,140(k0)
9d00066c:	03400008 	jr	k0
9d000670:	00000000 	nop

Disassembly of section .vector_36:

9d000680 <__vector_36>:
 VECTOR_ENTRY(36)
9d000680:	3c1aa000 	lui	k0,0xa000
9d000684:	275a0008 	addiu	k0,k0,8
9d000688:	8f5a0090 	lw	k0,144(k0)
9d00068c:	03400008 	jr	k0
9d000690:	00000000 	nop

Disassembly of section .vector_37:

9d0006a0 <__vector_37>:
 VECTOR_ENTRY(37)
9d0006a0:	3c1aa000 	lui	k0,0xa000
9d0006a4:	275a0008 	addiu	k0,k0,8
9d0006a8:	8f5a0094 	lw	k0,148(k0)
9d0006ac:	03400008 	jr	k0
9d0006b0:	00000000 	nop

Disassembly of section .vector_38:

9d0006c0 <__vector_38>:
 VECTOR_ENTRY(38)
9d0006c0:	3c1aa000 	lui	k0,0xa000
9d0006c4:	275a0008 	addiu	k0,k0,8
9d0006c8:	8f5a0098 	lw	k0,152(k0)
9d0006cc:	03400008 	jr	k0
9d0006d0:	00000000 	nop

Disassembly of section .vector_39:

9d0006e0 <__vector_39>:
 VECTOR_ENTRY(39)
9d0006e0:	3c1aa000 	lui	k0,0xa000
9d0006e4:	275a0008 	addiu	k0,k0,8
9d0006e8:	8f5a009c 	lw	k0,156(k0)
9d0006ec:	03400008 	jr	k0
9d0006f0:	00000000 	nop

Disassembly of section .vector_40:

9d000700 <__vector_40>:
 VECTOR_ENTRY(40)
9d000700:	3c1aa000 	lui	k0,0xa000
9d000704:	275a0008 	addiu	k0,k0,8
9d000708:	8f5a00a0 	lw	k0,160(k0)
9d00070c:	03400008 	jr	k0
9d000710:	00000000 	nop

Disassembly of section .vector_41:

9d000720 <__vector_41>:
 VECTOR_ENTRY(41)
9d000720:	3c1aa000 	lui	k0,0xa000
9d000724:	275a0008 	addiu	k0,k0,8
9d000728:	8f5a00a4 	lw	k0,164(k0)
9d00072c:	03400008 	jr	k0
9d000730:	00000000 	nop

Disassembly of section .vector_42:

9d000740 <__vector_42>:
 VECTOR_ENTRY(42)
9d000740:	3c1aa000 	lui	k0,0xa000
9d000744:	275a0008 	addiu	k0,k0,8
9d000748:	8f5a00a8 	lw	k0,168(k0)
9d00074c:	03400008 	jr	k0
9d000750:	00000000 	nop

Disassembly of section .vector_43:

9d000760 <__vector_43>:
 VECTOR_ENTRY(43)
9d000760:	3c1aa000 	lui	k0,0xa000
9d000764:	275a0008 	addiu	k0,k0,8
9d000768:	8f5a00ac 	lw	k0,172(k0)
9d00076c:	03400008 	jr	k0
9d000770:	00000000 	nop

Disassembly of section .vector_44:

9d000780 <__vector_44>:
 VECTOR_ENTRY(44)
9d000780:	3c1aa000 	lui	k0,0xa000
9d000784:	275a0008 	addiu	k0,k0,8
9d000788:	8f5a00b0 	lw	k0,176(k0)
9d00078c:	03400008 	jr	k0
9d000790:	00000000 	nop

Disassembly of section .vector_45:

9d0007a0 <__vector_45>:
 VECTOR_ENTRY(45)
9d0007a0:	3c1aa000 	lui	k0,0xa000
9d0007a4:	275a0008 	addiu	k0,k0,8
9d0007a8:	8f5a00b4 	lw	k0,180(k0)
9d0007ac:	03400008 	jr	k0
9d0007b0:	00000000 	nop

Disassembly of section .vector_46:

9d0007c0 <__vector_46>:
 VECTOR_ENTRY(46)
9d0007c0:	3c1aa000 	lui	k0,0xa000
9d0007c4:	275a0008 	addiu	k0,k0,8
9d0007c8:	8f5a00b8 	lw	k0,184(k0)
9d0007cc:	03400008 	jr	k0
9d0007d0:	00000000 	nop

Disassembly of section .vector_47:

9d0007e0 <__vector_47>:
 VECTOR_ENTRY(47)
9d0007e0:	3c1aa000 	lui	k0,0xa000
9d0007e4:	275a0008 	addiu	k0,k0,8
9d0007e8:	8f5a00bc 	lw	k0,188(k0)
9d0007ec:	03400008 	jr	k0
9d0007f0:	00000000 	nop

Disassembly of section .vector_48:

9d000800 <__vector_48>:
 VECTOR_ENTRY(48)
9d000800:	3c1aa000 	lui	k0,0xa000
9d000804:	275a0008 	addiu	k0,k0,8
9d000808:	8f5a00c0 	lw	k0,192(k0)
9d00080c:	03400008 	jr	k0
9d000810:	00000000 	nop

Disassembly of section .vector_49:

9d000820 <__vector_49>:
 VECTOR_ENTRY(49)
9d000820:	3c1aa000 	lui	k0,0xa000
9d000824:	275a0008 	addiu	k0,k0,8
9d000828:	8f5a00c4 	lw	k0,196(k0)
9d00082c:	03400008 	jr	k0
9d000830:	00000000 	nop

Disassembly of section .vector_50:

9d000840 <__vector_50>:
 VECTOR_ENTRY(50)
9d000840:	3c1aa000 	lui	k0,0xa000
9d000844:	275a0008 	addiu	k0,k0,8
9d000848:	8f5a00c8 	lw	k0,200(k0)
9d00084c:	03400008 	jr	k0
9d000850:	00000000 	nop

Disassembly of section .vector_51:

9d000860 <__vector_51>:
 VECTOR_ENTRY(51)
9d000860:	3c1aa000 	lui	k0,0xa000
9d000864:	275a0008 	addiu	k0,k0,8
9d000868:	8f5a00cc 	lw	k0,204(k0)
9d00086c:	03400008 	jr	k0
9d000870:	00000000 	nop

Disassembly of section .vector_52:

9d000880 <__vector_52>:
 VECTOR_ENTRY(52)
9d000880:	3c1aa000 	lui	k0,0xa000
9d000884:	275a0008 	addiu	k0,k0,8
9d000888:	8f5a00d0 	lw	k0,208(k0)
9d00088c:	03400008 	jr	k0
9d000890:	00000000 	nop

Disassembly of section .vector_53:

9d0008a0 <__vector_53>:
 VECTOR_ENTRY(53)
9d0008a0:	3c1aa000 	lui	k0,0xa000
9d0008a4:	275a0008 	addiu	k0,k0,8
9d0008a8:	8f5a00d4 	lw	k0,212(k0)
9d0008ac:	03400008 	jr	k0
9d0008b0:	00000000 	nop

Disassembly of section .vector_54:

9d0008c0 <__vector_54>:
 VECTOR_ENTRY(54)
9d0008c0:	3c1aa000 	lui	k0,0xa000
9d0008c4:	275a0008 	addiu	k0,k0,8
9d0008c8:	8f5a00d8 	lw	k0,216(k0)
9d0008cc:	03400008 	jr	k0
9d0008d0:	00000000 	nop

Disassembly of section .vector_55:

9d0008e0 <__vector_55>:
 VECTOR_ENTRY(55)
9d0008e0:	3c1aa000 	lui	k0,0xa000
9d0008e4:	275a0008 	addiu	k0,k0,8
9d0008e8:	8f5a00dc 	lw	k0,220(k0)
9d0008ec:	03400008 	jr	k0
9d0008f0:	00000000 	nop

Disassembly of section .vector_56:

9d000900 <__vector_56>:
 VECTOR_ENTRY(56)
9d000900:	3c1aa000 	lui	k0,0xa000
9d000904:	275a0008 	addiu	k0,k0,8
9d000908:	8f5a00e0 	lw	k0,224(k0)
9d00090c:	03400008 	jr	k0
9d000910:	00000000 	nop

Disassembly of section .vector_57:

9d000920 <__vector_57>:
 VECTOR_ENTRY(57)
9d000920:	3c1aa000 	lui	k0,0xa000
9d000924:	275a0008 	addiu	k0,k0,8
9d000928:	8f5a00e4 	lw	k0,228(k0)
9d00092c:	03400008 	jr	k0
9d000930:	00000000 	nop

Disassembly of section .vector_58:

9d000940 <__vector_58>:
 VECTOR_ENTRY(58)
9d000940:	3c1aa000 	lui	k0,0xa000
9d000944:	275a0008 	addiu	k0,k0,8
9d000948:	8f5a00e8 	lw	k0,232(k0)
9d00094c:	03400008 	jr	k0
9d000950:	00000000 	nop

Disassembly of section .vector_59:

9d000960 <__vector_59>:
 VECTOR_ENTRY(59)
9d000960:	3c1aa000 	lui	k0,0xa000
9d000964:	275a0008 	addiu	k0,k0,8
9d000968:	8f5a00ec 	lw	k0,236(k0)
9d00096c:	03400008 	jr	k0
9d000970:	00000000 	nop

Disassembly of section .vector_60:

9d000980 <__vector_60>:
 VECTOR_ENTRY(60)
9d000980:	3c1aa000 	lui	k0,0xa000
9d000984:	275a0008 	addiu	k0,k0,8
9d000988:	8f5a00f0 	lw	k0,240(k0)
9d00098c:	03400008 	jr	k0
9d000990:	00000000 	nop

Disassembly of section .vector_61:

9d0009a0 <__vector_61>:
 VECTOR_ENTRY(61)
9d0009a0:	3c1aa000 	lui	k0,0xa000
9d0009a4:	275a0008 	addiu	k0,k0,8
9d0009a8:	8f5a00f4 	lw	k0,244(k0)
9d0009ac:	03400008 	jr	k0
9d0009b0:	00000000 	nop

Disassembly of section .vector_62:

9d0009c0 <__vector_62>:
 VECTOR_ENTRY(62)
9d0009c0:	3c1aa000 	lui	k0,0xa000
9d0009c4:	275a0008 	addiu	k0,k0,8
9d0009c8:	8f5a00f8 	lw	k0,248(k0)
9d0009cc:	03400008 	jr	k0
9d0009d0:	00000000 	nop

Disassembly of section .vector_63:

9d0009e0 <__vector_63>:
 VECTOR_ENTRY(63)
9d0009e0:	3c1aa000 	lui	k0,0xa000
9d0009e4:	275a0008 	addiu	k0,k0,8
9d0009e8:	8f5a00fc 	lw	k0,252(k0)
9d0009ec:	03400008 	jr	k0
9d0009f0:	00000000 	nop

Disassembly of section .startup:

9d001010 <_startup>:
9d001010:	401a6000 	mfc0	k0,c0_status
9d001014:	7f5a04c0 	ext	k0,k0,0x13,0x1
9d001018:	13400005 	beqz	k0,9d001030 <_no_nmi>
9d00101c:	00000000 	nop
9d001020:	3c1a9d01 	lui	k0,0x9d01
9d001024:	275ac644 	addiu	k0,k0,-14780
9d001028:	03400008 	jr	k0
9d00102c:	00000000 	nop

9d001030 <_no_nmi>:
9d001030:	3c1da002 	lui	sp,0xa002
9d001034:	27bd0000 	addiu	sp,sp,0
9d001038:	3c1ca001 	lui	gp,0xa001
9d00103c:	279c8900 	addiu	gp,gp,-30464
9d001040:	40096002 	mfc0	t1,c0_srsctl
9d001044:	01205820 	add	t3,t1,zero
9d001048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
9d00104c:	7d494984 	ins	t1,t2,0x6,0x4
9d001050:	40896002 	mtc0	t1,c0_srsctl
9d001054:	41dce000 	wrpgpr	gp,gp
9d001058:	408b6002 	mtc0	t3,c0_srsctl
9d00105c:	3c089d01 	lui	t0,0x9d01
9d001060:	2508c634 	addiu	t0,t0,-14796
9d001064:	0100f809 	jalr	t0
9d001068:	00000000 	nop
9d00106c:	3c08a000 	lui	t0,0xa000
9d001070:	25080940 	addiu	t0,t0,2368
9d001074:	3c09a001 	lui	t1,0xa001
9d001078:	25299b28 	addiu	t1,t1,-25816
9d00107c:	10000006 	b	9d001098 <_bss_check>
9d001080:	00000000 	nop

9d001084 <_bss_init>:
9d001084:	ad000000 	sw	zero,0(t0)
9d001088:	ad000004 	sw	zero,4(t0)
9d00108c:	ad000008 	sw	zero,8(t0)
9d001090:	ad00000c 	sw	zero,12(t0)
9d001094:	25080010 	addiu	t0,t0,16

9d001098 <_bss_check>:
9d001098:	0109082b 	sltu	at,t0,t1
9d00109c:	1420fff9 	bnez	at,9d001084 <_bss_init>
9d0010a0:	00000000 	nop
9d0010a4:	3c089d01 	lui	t0,0x9d01
9d0010a8:	2508e74c 	addiu	t0,t0,-6324
9d0010ac:	3c09a000 	lui	t1,0xa000
9d0010b0:	25290008 	addiu	t1,t1,8
9d0010b4:	3c0aa000 	lui	t2,0xa000
9d0010b8:	254a0940 	addiu	t2,t2,2368
9d0010bc:	10000005 	b	9d0010d4 <_init_check>
9d0010c0:	00000000 	nop

9d0010c4 <_init_data>:
9d0010c4:	8d0b0000 	lw	t3,0(t0)
9d0010c8:	ad2b0000 	sw	t3,0(t1)
9d0010cc:	25080004 	addiu	t0,t0,4
9d0010d0:	25290004 	addiu	t1,t1,4

9d0010d4 <_init_check>:
9d0010d4:	012a082b 	sltu	at,t1,t2
9d0010d8:	1420fffa 	bnez	at,9d0010c4 <_init_data>
9d0010dc:	00000000 	nop
9d0010e0:	3c090000 	lui	t1,0x0
9d0010e4:	25290000 	addiu	t1,t1,0
9d0010e8:	1120001d 	beqz	t1,9d001160 <_ramfunc_done>
9d0010ec:	00000000 	nop
9d0010f0:	3c089d01 	lui	t0,0x9d01
9d0010f4:	2508f084 	addiu	t0,t0,-3964
9d0010f8:	3c09a001 	lui	t1,0xa001
9d0010fc:	2529c800 	addiu	t1,t1,-14336
9d001100:	3c0aa001 	lui	t2,0xa001
9d001104:	254ac800 	addiu	t2,t2,-14336

9d001108 <_init_ramfunc>:
9d001108:	8d0b0000 	lw	t3,0(t0)
9d00110c:	ad2b0000 	sw	t3,0(t1)
9d001110:	25080004 	addiu	t0,t0,4
9d001114:	25290004 	addiu	t1,t1,4

9d001118 <_ramfunc_check>:
9d001118:	012a082b 	sltu	at,t1,t2
9d00111c:	1420fffa 	bnez	at,9d001108 <_init_ramfunc>
9d001120:	00000000 	nop
9d001124:	3c090001 	lui	t1,0x1
9d001128:	2529c800 	addiu	t1,t1,-14336
9d00112c:	3c0abf88 	lui	t2,0xbf88
9d001130:	254a2010 	addiu	t2,t2,8208
9d001134:	ad490000 	sw	t1,0(t2)
9d001138:	3c090002 	lui	t1,0x2
9d00113c:	25290000 	addiu	t1,t1,0
9d001140:	3c0abf88 	lui	t2,0xbf88
9d001144:	254a2020 	addiu	t2,t2,8224
9d001148:	ad490000 	sw	t1,0(t2)
9d00114c:	3c090002 	lui	t1,0x2
9d001150:	25290000 	addiu	t1,t1,0
9d001154:	3c0abf88 	lui	t2,0xbf88
9d001158:	254a2030 	addiu	t2,t2,8240
9d00115c:	ad490000 	sw	t1,0(t2)

9d001160 <_ramfunc_done>:
9d001160:	40804800 	mtc0	zero,c0_count
9d001164:	240affff 	li	t2,-1
9d001168:	408a5800 	mtc0	t2,c0_compare
9d00116c:	3c099d00 	lui	t1,0x9d00
9d001170:	25290000 	addiu	t1,t1,0
9d001174:	40897801 	mtc0	t1,c0_ebase
9d001178:	3c090000 	lui	t1,0x0
9d00117c:	25290001 	addiu	t1,t1,1
9d001180:	240a0000 	li	t2,0
9d001184:	7d2a4944 	ins	t2,t1,0x5,0x5
9d001188:	408a6001 	mtc0	t2,c0_intctl
9d00118c:	3c090080 	lui	t1,0x80
9d001190:	40896800 	mtc0	t1,c0_cause
9d001194:	40088000 	mfc0	t0,c0_config
9d001198:	7d090580 	ext	t1,t0,0x16,0x1
9d00119c:	00094c40 	sll	t1,t1,0x11
9d0011a0:	40086000 	mfc0	t0,c0_status
9d0011a4:	3c010058 	lui	at,0x58
9d0011a8:	01014024 	and	t0,t0,at
9d0011ac:	01284025 	or	t0,t1,t0
9d0011b0:	40886000 	mtc0	t0,c0_status
9d0011b4:	3c089d01 	lui	t0,0x9d01
9d0011b8:	2508c63c 	addiu	t0,t0,-14788
9d0011bc:	0100f809 	jalr	t0
9d0011c0:	00000000 	nop
9d0011c4:	40086000 	mfc0	t0,c0_status
9d0011c8:	3c01ffbf 	lui	at,0xffbf
9d0011cc:	3421ffff 	ori	at,at,0xffff
9d0011d0:	01014024 	and	t0,t0,at
9d0011d4:	40886000 	mtc0	t0,c0_status
9d0011d8:	30840000 	andi	a0,a0,0x0
9d0011dc:	30a50000 	andi	a1,a1,0x0
9d0011e0:	3c089d00 	lui	t0,0x9d00
9d0011e4:	250811f0 	addiu	t0,t0,4592
9d0011e8:	01000008 	jr	t0
9d0011ec:	00000000 	nop

Disassembly of section .text:

9d0011f0 <_main_entry>:
9d0011f0:	0f4036a4 	jal	9d00da90 <_text_end>
9d0011f4:	00000000 	nop
9d0011f8:	30840000 	andi	a0,a0,0x0
9d0011fc:	30a50000 	andi	a1,a1,0x0
9d001200:	0f402be4 	jal	9d00af90 <main>
9d001204:	00000000 	nop
9d001208:	1000fffd 	b	9d001200 <_main_entry+0x10>
9d00120c:	00000000 	nop

9d001210 <__do_global_dtors_aux>:
9d001210:	27bdffd8 	addiu	sp,sp,-40
9d001214:	afb2001c 	sw	s2,28(sp)
9d001218:	3c12a000 	lui	s2,0xa000
9d00121c:	92420a78 	lbu	v0,2680(s2)
9d001220:	afbf0024 	sw	ra,36(sp)
9d001224:	afb30020 	sw	s3,32(sp)
9d001228:	afb10018 	sw	s1,24(sp)
9d00122c:	14400020 	bnez	v0,9d0012b0 <__do_global_dtors_aux+0xa0>
9d001230:	afb00014 	sw	s0,20(sp)
9d001234:	3c119d01 	lui	s1,0x9d01
9d001238:	3c109d01 	lui	s0,0x9d01
9d00123c:	3c13a000 	lui	s3,0xa000
9d001240:	2631dadc 	addiu	s1,s1,-9508
9d001244:	2610dae4 	addiu	s0,s0,-9500
9d001248:	8e620a7c 	lw	v0,2684(s3)
9d00124c:	02118023 	subu	s0,s0,s1
9d001250:	00108083 	sra	s0,s0,0x2
9d001254:	2610ffff 	addiu	s0,s0,-1
9d001258:	0050182b 	sltu	v1,v0,s0
9d00125c:	5060000c 	beqzl	v1,9d001290 <__do_global_dtors_aux+0x80>
9d001260:	3c020000 	lui	v0,0x0
9d001264:	24420001 	addiu	v0,v0,1
9d001268:	00021880 	sll	v1,v0,0x2
9d00126c:	02231821 	addu	v1,s1,v1
9d001270:	8c630000 	lw	v1,0(v1)
9d001274:	0060f809 	jalr	v1
9d001278:	ae620a7c 	sw	v0,2684(s3)
9d00127c:	8e620a7c 	lw	v0,2684(s3)
9d001280:	0050182b 	sltu	v1,v0,s0
9d001284:	1460fff8 	bnez	v1,9d001268 <__do_global_dtors_aux+0x58>
9d001288:	24420001 	addiu	v0,v0,1
9d00128c:	3c020000 	lui	v0,0x0
9d001290:	24420000 	addiu	v0,v0,0
9d001294:	10400005 	beqz	v0,9d0012ac <__do_global_dtors_aux+0x9c>
9d001298:	24020001 	li	v0,1
9d00129c:	3c04a000 	lui	a0,0xa000
9d0012a0:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012a4:	24840008 	addiu	a0,a0,8
9d0012a8:	24020001 	li	v0,1
9d0012ac:	a2420a78 	sb	v0,2680(s2)
9d0012b0:	8fbf0024 	lw	ra,36(sp)
9d0012b4:	8fb30020 	lw	s3,32(sp)
9d0012b8:	8fb2001c 	lw	s2,28(sp)
9d0012bc:	8fb10018 	lw	s1,24(sp)
9d0012c0:	8fb00014 	lw	s0,20(sp)
9d0012c4:	03e00008 	jr	ra
9d0012c8:	27bd0028 	addiu	sp,sp,40

9d0012cc <frame_dummy>:
9d0012cc:	3c020000 	lui	v0,0x0
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	24420000 	addiu	v0,v0,0
9d0012d8:	10400006 	beqz	v0,9d0012f4 <frame_dummy+0x28>
9d0012dc:	afbf0014 	sw	ra,20(sp)
9d0012e0:	3c04a000 	lui	a0,0xa000
9d0012e4:	3c05a000 	lui	a1,0xa000
9d0012e8:	24840008 	addiu	a0,a0,8
9d0012ec:	0c000000 	jal	90000000 <_imageExecutionJumpToFirstInFlash+0x8e000000>
9d0012f0:	24a50a80 	addiu	a1,a1,2688
9d0012f4:	3c04a000 	lui	a0,0xa000
9d0012f8:	8c820008 	lw	v0,8(a0)
9d0012fc:	10400007 	beqz	v0,9d00131c <frame_dummy+0x50>
9d001300:	3c190000 	lui	t9,0x0
9d001304:	27390000 	addiu	t9,t9,0
9d001308:	13200004 	beqz	t9,9d00131c <frame_dummy+0x50>
9d00130c:	8fbf0014 	lw	ra,20(sp)
9d001310:	24840008 	addiu	a0,a0,8
9d001314:	03200008 	jr	t9
9d001318:	27bd0018 	addiu	sp,sp,24
9d00131c:	8fbf0014 	lw	ra,20(sp)
9d001320:	03e00008 	jr	ra
9d001324:	27bd0018 	addiu	sp,sp,24

9d001328 <_Z41__static_initialization_and_destruction_0ii.clone.0>:
9d001328:	24020001 	li	v0,1
9d00132c:	50820008 	beql	a0,v0,9d001350 <_Z41__static_initialization_and_destruction_0ii.clone.0+0x28>
9d001330:	3c04a000 	lui	a0,0xa000
9d001334:	14800004 	bnez	a0,9d001348 <_Z41__static_initialization_and_destruction_0ii.clone.0+0x20>
9d001338:	00000000 	nop
9d00133c:	3c04a000 	lui	a0,0xa000
9d001340:	0b400701 	j	9d001c04 <_ZN6ServerD1Ev>
9d001344:	24840a98 	addiu	a0,a0,2712
9d001348:	03e00008 	jr	ra
9d00134c:	00000000 	nop
9d001350:	24840a98 	addiu	a0,a0,2712
9d001354:	0b4006f6 	j	9d001bd8 <_ZN6ServerC1Et>
9d001358:	24050017 	li	a1,23

9d00135c <setup>:
9d00135c:	27bdffe0 	addiu	sp,sp,-32
9d001360:	27828018 	addiu	v0,gp,-32744
9d001364:	27858040 	addiu	a1,gp,-32704
9d001368:	27868010 	addiu	a2,gp,-32752
9d00136c:	27878014 	addiu	a3,gp,-32748
9d001370:	2784804c 	addiu	a0,gp,-32692
9d001374:	afbf001c 	sw	ra,28(sp)
9d001378:	0f4006a2 	jal	9d001a88 <_ZN20ChipKITEthernetClass5beginEPhS0_S0_S0_>
9d00137c:	afa20010 	sw	v0,16(sp)
9d001380:	3c04a000 	lui	a0,0xa000
9d001384:	0f400720 	jal	9d001c80 <_ZN6Server5beginEv>
9d001388:	24840a98 	addiu	a0,a0,2712
9d00138c:	24040039 	li	a0,57
9d001390:	0f402a7c 	jal	9d00a9f0 <pinMode>
9d001394:	24050001 	li	a1,1
9d001398:	8fbf001c 	lw	ra,28(sp)
9d00139c:	24040056 	li	a0,86
9d0013a0:	00002821 	move	a1,zero
9d0013a4:	0b402a7c 	j	9d00a9f0 <pinMode>
9d0013a8:	27bd0020 	addiu	sp,sp,32

9d0013ac <loop>:
9d0013ac:	27bdff98 	addiu	sp,sp,-104
9d0013b0:	3c05a000 	lui	a1,0xa000
9d0013b4:	27a40010 	addiu	a0,sp,16
9d0013b8:	24a50a98 	addiu	a1,a1,2712
9d0013bc:	afbf0064 	sw	ra,100(sp)
9d0013c0:	afb70060 	sw	s7,96(sp)
9d0013c4:	afb6005c 	sw	s6,92(sp)
9d0013c8:	afb50058 	sw	s5,88(sp)
9d0013cc:	afb40054 	sw	s4,84(sp)
9d0013d0:	afb30050 	sw	s3,80(sp)
9d0013d4:	afb2004c 	sw	s2,76(sp)
9d0013d8:	afb10048 	sw	s1,72(sp)
9d0013dc:	0f400776 	jal	9d001dd8 <_ZN6Server9availableEv>
9d0013e0:	afb00044 	sw	s0,68(sp)
9d0013e4:	0f400658 	jal	9d001960 <_ZN6ClientcvbEv>
9d0013e8:	27a40010 	addiu	a0,sp,16
9d0013ec:	14400064 	bnez	v0,9d001580 <loop+0x1d4>
9d0013f0:	8f908048 	lw	s0,-32696(gp)
9d0013f4:	12000033 	beqz	s0,9d0014c4 <loop+0x118>
9d0013f8:	00000000 	nop
9d0013fc:	3c119d01 	lui	s1,0x9d01
9d001400:	3c139d01 	lui	s3,0x9d01
9d001404:	3c159d01 	lui	s5,0x9d01
9d001408:	2631db50 	addiu	s1,s1,-9392
9d00140c:	2673db5c 	addiu	s3,s3,-9380
9d001410:	3c149d01 	lui	s4,0x9d01
9d001414:	26b5db74 	addiu	s5,s5,-9356
9d001418:	0b40050d 	j	9d001434 <loop+0x88>
9d00141c:	3c169d01 	lui	s6,0x9d01
9d001420:	0f400654 	jal	9d001950 <_ZN6ClientD1Ev>
9d001424:	27a40028 	addiu	a0,sp,40
9d001428:	8e10000c 	lw	s0,12(s0)
9d00142c:	12000025 	beqz	s0,9d0014c4 <loop+0x118>
9d001430:	00000000 	nop
9d001434:	92050000 	lbu	a1,0(s0)
9d001438:	0f400637 	jal	9d0018dc <_ZN6ClientC1Eh>
9d00143c:	27a40028 	addiu	a0,sp,40
9d001440:	0f400688 	jal	9d001a20 <_ZN6Client9connectedEv>
9d001444:	27a40028 	addiu	a0,sp,40
9d001448:	5040007b 	beqzl	v0,9d001638 <loop+0x28c>
9d00144c:	8f918048 	lw	s1,-32696(gp)
9d001450:	0f400616 	jal	9d001858 <_ZN6Client9availableEv>
9d001454:	27a40028 	addiu	a0,sp,40
9d001458:	1040fff1 	beqz	v0,9d001420 <loop+0x74>
9d00145c:	00000000 	nop
9d001460:	0f400614 	jal	9d001850 <_ZN6Client4readEv>
9d001464:	27a40028 	addiu	a0,sp,40
9d001468:	8e120004 	lw	s2,4(s0)
9d00146c:	0040b821 	move	s7,v0
9d001470:	0f40301c 	jal	9d00c070 <strlen>
9d001474:	02402021 	move	a0,s2
9d001478:	2403000d 	li	v1,13
9d00147c:	12e30026 	beq	s7,v1,9d001518 <loop+0x16c>
9d001480:	240300ff 	li	v1,255
9d001484:	12e3001c 	beq	s7,v1,9d0014f8 <loop+0x14c>
9d001488:	2403000a 	li	v1,10
9d00148c:	12e3ffe4 	beq	s7,v1,9d001420 <loop+0x74>
9d001490:	24030001 	li	v1,1
9d001494:	92040008 	lbu	a0,8(s0)
9d001498:	108300ae 	beq	a0,v1,9d001754 <loop+0x3a8>
9d00149c:	02429021 	addu	s2,s2,v0
9d0014a0:	a2570000 	sb	s7,0(s2)
9d0014a4:	8e030004 	lw	v1,4(s0)
9d0014a8:	27a40028 	addiu	a0,sp,40
9d0014ac:	00621021 	addu	v0,v1,v0
9d0014b0:	0f400654 	jal	9d001950 <_ZN6ClientD1Ev>
9d0014b4:	a0400001 	sb	zero,1(v0)
9d0014b8:	8e10000c 	lw	s0,12(s0)
9d0014bc:	5600ffde 	bnezl	s0,9d001438 <loop+0x8c>
9d0014c0:	92050000 	lbu	a1,0(s0)
9d0014c4:	0f400654 	jal	9d001950 <_ZN6ClientD1Ev>
9d0014c8:	27a40010 	addiu	a0,sp,16
9d0014cc:	8fbf0064 	lw	ra,100(sp)
9d0014d0:	8fb70060 	lw	s7,96(sp)
9d0014d4:	8fb6005c 	lw	s6,92(sp)
9d0014d8:	8fb50058 	lw	s5,88(sp)
9d0014dc:	8fb40054 	lw	s4,84(sp)
9d0014e0:	8fb30050 	lw	s3,80(sp)
9d0014e4:	8fb2004c 	lw	s2,76(sp)
9d0014e8:	8fb10048 	lw	s1,72(sp)
9d0014ec:	8fb00044 	lw	s0,68(sp)
9d0014f0:	03e00008 	jr	ra
9d0014f4:	27bd0068 	addiu	sp,sp,104
9d0014f8:	92040008 	lbu	a0,8(s0)
9d0014fc:	24030001 	li	v1,1
9d001500:	5083008e 	beql	a0,v1,9d00173c <loop+0x390>
9d001504:	02429021 	addu	s2,s2,v0
9d001508:	a2030008 	sb	v1,8(s0)
9d00150c:	a2000009 	sb	zero,9(s0)
9d001510:	0b400508 	j	9d001420 <loop+0x74>
9d001514:	a200000a 	sb	zero,10(s0)
9d001518:	02402021 	move	a0,s2
9d00151c:	0f402ffa 	jal	9d00bfe8 <strcmp>
9d001520:	02202821 	move	a1,s1
9d001524:	1040007d 	beqz	v0,9d00171c <loop+0x370>
9d001528:	3c02bf88 	lui	v0,0xbf88
9d00152c:	02402021 	move	a0,s2
9d001530:	0f402ffa 	jal	9d00bfe8 <strcmp>
9d001534:	02602821 	move	a1,s3
9d001538:	10400074 	beqz	v0,9d00170c <loop+0x360>
9d00153c:	24040039 	li	a0,57
9d001540:	02402021 	move	a0,s2
9d001544:	0f402ffa 	jal	9d00bfe8 <strcmp>
9d001548:	2685db68 	addiu	a1,s4,-9368
9d00154c:	1040006b 	beqz	v0,9d0016fc <loop+0x350>
9d001550:	24040039 	li	a0,57
9d001554:	02402021 	move	a0,s2
9d001558:	0f402ffa 	jal	9d00bfe8 <strcmp>
9d00155c:	02a02821 	move	a1,s5
9d001560:	10400059 	beqz	v0,9d0016c8 <loop+0x31c>
9d001564:	3c059d01 	lui	a1,0x9d01
9d001568:	27a40028 	addiu	a0,sp,40
9d00156c:	0f402b6a 	jal	9d00ada8 <_ZN5Print5printEPKc>
9d001570:	26c5db8c 	addiu	a1,s6,-9332
9d001574:	8e020004 	lw	v0,4(s0)
9d001578:	0b400508 	j	9d001420 <loop+0x74>
9d00157c:	a0400000 	sb	zero,0(v0)
9d001580:	1200000b 	beqz	s0,9d0015b0 <loop+0x204>
9d001584:	93a60014 	lbu	a2,20(sp)
9d001588:	02001021 	move	v0,s0
9d00158c:	00001821 	move	v1,zero
9d001590:	24050001 	li	a1,1
9d001594:	90440000 	lbu	a0,0(v0)
9d001598:	8c42000c 	lw	v0,12(v0)
9d00159c:	00862026 	xor	a0,a0,a2
9d0015a0:	1440fffc 	bnez	v0,9d001594 <loop+0x1e8>
9d0015a4:	00a4180a 	movz	v1,a1,a0
9d0015a8:	1460ff95 	bnez	v1,9d001400 <loop+0x54>
9d0015ac:	3c119d01 	lui	s1,0x9d01
9d0015b0:	0f402e0d 	jal	9d00b834 <malloc>
9d0015b4:	24040010 	li	a0,16
9d0015b8:	00408021 	move	s0,v0
9d0015bc:	ac40000c 	sw	zero,12(v0)
9d0015c0:	93a20014 	lbu	v0,20(sp)
9d0015c4:	24040400 	li	a0,1024
9d0015c8:	0f402e0d 	jal	9d00b834 <malloc>
9d0015cc:	a2020000 	sb	v0,0(s0)
9d0015d0:	ae020004 	sw	v0,4(s0)
9d0015d4:	240500ff 	li	a1,255
9d0015d8:	0f400629 	jal	9d0018a4 <_ZN6Client5writeEh>
9d0015dc:	27a40010 	addiu	a0,sp,16
9d0015e0:	27a40010 	addiu	a0,sp,16
9d0015e4:	0f400629 	jal	9d0018a4 <_ZN6Client5writeEh>
9d0015e8:	240500fc 	li	a1,252
9d0015ec:	27a40010 	addiu	a0,sp,16
9d0015f0:	0f400629 	jal	9d0018a4 <_ZN6Client5writeEh>
9d0015f4:	24050022 	li	a1,34
9d0015f8:	3c059d01 	lui	a1,0x9d01
9d0015fc:	27a40010 	addiu	a0,sp,16
9d001600:	0f402bd8 	jal	9d00af60 <_ZN5Print7printlnEPKc>
9d001604:	24a5db3c 	addiu	a1,a1,-9412
9d001608:	8f848048 	lw	a0,-32696(gp)
9d00160c:	02002821 	move	a1,s0
9d001610:	14800003 	bnez	a0,9d001620 <loop+0x274>
9d001614:	00801821 	move	v1,a0
9d001618:	0b4005fa 	j	9d0017e8 <loop+0x43c>
9d00161c:	af908048 	sw	s0,-32696(gp)
9d001620:	8c62000c 	lw	v0,12(v1)
9d001624:	5440fffe 	bnezl	v0,9d001620 <loop+0x274>
9d001628:	00401821 	move	v1,v0
9d00162c:	ac65000c 	sw	a1,12(v1)
9d001630:	0b4004ff 	j	9d0013fc <loop+0x50>
9d001634:	00808021 	move	s0,a0
9d001638:	52300064 	beql	s1,s0,9d0017cc <loop+0x420>
9d00163c:	8e02000c 	lw	v0,12(s0)
9d001640:	12200012 	beqz	s1,9d00168c <loop+0x2e0>
9d001644:	00000000 	nop
9d001648:	8e22000c 	lw	v0,12(s1)
9d00164c:	50500007 	beql	v0,s0,9d00166c <loop+0x2c0>
9d001650:	8e02000c 	lw	v0,12(s0)
9d001654:	1040000d 	beqz	v0,9d00168c <loop+0x2e0>
9d001658:	00408821 	move	s1,v0
9d00165c:	8e22000c 	lw	v0,12(s1)
9d001660:	1450fffc 	bne	v0,s0,9d001654 <loop+0x2a8>
9d001664:	00000000 	nop
9d001668:	8e02000c 	lw	v0,12(s0)
9d00166c:	8e040004 	lw	a0,4(s0)
9d001670:	0f402e17 	jal	9d00b85c <free>
9d001674:	ae22000c 	sw	v0,12(s1)
9d001678:	0f402e17 	jal	9d00b85c <free>
9d00167c:	02002021 	move	a0,s0
9d001680:	8e22000c 	lw	v0,12(s1)
9d001684:	1440fff5 	bnez	v0,9d00165c <loop+0x2b0>
9d001688:	00408821 	move	s1,v0
9d00168c:	0f400654 	jal	9d001950 <_ZN6ClientD1Ev>
9d001690:	27a40028 	addiu	a0,sp,40
9d001694:	0f400654 	jal	9d001950 <_ZN6ClientD1Ev>
9d001698:	27a40010 	addiu	a0,sp,16
9d00169c:	8fbf0064 	lw	ra,100(sp)
9d0016a0:	8fb70060 	lw	s7,96(sp)
9d0016a4:	8fb6005c 	lw	s6,92(sp)
9d0016a8:	8fb50058 	lw	s5,88(sp)
9d0016ac:	8fb40054 	lw	s4,84(sp)
9d0016b0:	8fb30050 	lw	s3,80(sp)
9d0016b4:	8fb2004c 	lw	s2,76(sp)
9d0016b8:	8fb10048 	lw	s1,72(sp)
9d0016bc:	8fb00044 	lw	s0,68(sp)
9d0016c0:	03e00008 	jr	ra
9d0016c4:	27bd0068 	addiu	sp,sp,104
9d0016c8:	27a40028 	addiu	a0,sp,40
9d0016cc:	0f402b6a 	jal	9d00ada8 <_ZN5Print5printEPKc>
9d0016d0:	24a5db7c 	addiu	a1,a1,-9348
9d0016d4:	0f402af7 	jal	9d00abdc <digitalRead>
9d0016d8:	24040056 	li	a0,86
9d0016dc:	14400039 	bnez	v0,9d0017c4 <loop+0x418>
9d0016e0:	3c059d01 	lui	a1,0x9d01
9d0016e4:	3c059d01 	lui	a1,0x9d01
9d0016e8:	24a5db38 	addiu	a1,a1,-9416
9d0016ec:	0f402bd8 	jal	9d00af60 <_ZN5Print7printlnEPKc>
9d0016f0:	27a40028 	addiu	a0,sp,40
9d0016f4:	0b40055b 	j	9d00156c <loop+0x1c0>
9d0016f8:	27a40028 	addiu	a0,sp,40
9d0016fc:	0f402ac4 	jal	9d00ab10 <digitalWrite>
9d001700:	00002821 	move	a1,zero
9d001704:	0b400555 	j	9d001554 <loop+0x1a8>
9d001708:	8e120004 	lw	s2,4(s0)
9d00170c:	0f402ac4 	jal	9d00ab10 <digitalWrite>
9d001710:	24050001 	li	a1,1
9d001714:	0b400550 	j	9d001540 <loop+0x194>
9d001718:	8e120004 	lw	s2,4(s0)
9d00171c:	8c4361a0 	lw	v1,24992(v0)
9d001720:	24040001 	li	a0,1
9d001724:	7c837bc4 	ins	v1,a0,0xf,0x1
9d001728:	ac4361a0 	sw	v1,24992(v0)
9d00172c:	0f402a6d 	jal	9d00a9b4 <_Z5resetv>
9d001730:	00000000 	nop
9d001734:	0b40054b 	j	9d00152c <loop+0x180>
9d001738:	8e120004 	lw	s2,4(s0)
9d00173c:	2403ffff 	li	v1,-1
9d001740:	a2430000 	sb	v1,0(s2)
9d001744:	8e030004 	lw	v1,4(s0)
9d001748:	00621021 	addu	v0,v1,v0
9d00174c:	0b400508 	j	9d001420 <loop+0x74>
9d001750:	a0400001 	sb	zero,1(v0)
9d001754:	92020009 	lbu	v0,9(s0)
9d001758:	5040ff31 	beqzl	v0,9d001420 <loop+0x74>
9d00175c:	a2170009 	sb	s7,9(s0)
9d001760:	240300fd 	li	v1,253
9d001764:	10430024 	beq	v0,v1,9d0017f8 <loop+0x44c>
9d001768:	a217000a 	sb	s7,10(s0)
9d00176c:	3c059d01 	lui	a1,0x9d01
9d001770:	24a5db90 	addiu	a1,a1,-9328
9d001774:	0f402b6a 	jal	9d00ada8 <_ZN5Print5printEPKc>
9d001778:	27a40028 	addiu	a0,sp,40
9d00177c:	92050009 	lbu	a1,9(s0)
9d001780:	2406000a 	li	a2,10
9d001784:	0f402ba3 	jal	9d00ae8c <_ZN5Print5printEhi>
9d001788:	27a40028 	addiu	a0,sp,40
9d00178c:	3c059d01 	lui	a1,0x9d01
9d001790:	27a40028 	addiu	a0,sp,40
9d001794:	0f402b6a 	jal	9d00ada8 <_ZN5Print5printEPKc>
9d001798:	24a5db88 	addiu	a1,a1,-9336
9d00179c:	9205000a 	lbu	a1,10(s0)
9d0017a0:	27a40028 	addiu	a0,sp,40
9d0017a4:	0f402ba3 	jal	9d00ae8c <_ZN5Print5printEhi>
9d0017a8:	2406000a 	li	a2,10
9d0017ac:	3c059d01 	lui	a1,0x9d01
9d0017b0:	27a40028 	addiu	a0,sp,40
9d0017b4:	0f402bd8 	jal	9d00af60 <_ZN5Print7printlnEPKc>
9d0017b8:	24a5db94 	addiu	a1,a1,-9324
9d0017bc:	0b400508 	j	9d001420 <loop+0x74>
9d0017c0:	a2000008 	sb	zero,8(s0)
9d0017c4:	0b4005bb 	j	9d0016ec <loop+0x340>
9d0017c8:	24a5db34 	addiu	a1,a1,-9420
9d0017cc:	8e040004 	lw	a0,4(s0)
9d0017d0:	0f402e17 	jal	9d00b85c <free>
9d0017d4:	af828048 	sw	v0,-32696(gp)
9d0017d8:	0f402e17 	jal	9d00b85c <free>
9d0017dc:	02002021 	move	a0,s0
9d0017e0:	0b4005a3 	j	9d00168c <loop+0x2e0>
9d0017e4:	00000000 	nop
9d0017e8:	1600ff05 	bnez	s0,9d001400 <loop+0x54>
9d0017ec:	3c119d01 	lui	s1,0x9d01
9d0017f0:	0b400531 	j	9d0014c4 <loop+0x118>
9d0017f4:	00000000 	nop
9d0017f8:	27a40028 	addiu	a0,sp,40
9d0017fc:	0f400629 	jal	9d0018a4 <_ZN6Client5writeEh>
9d001800:	240500ff 	li	a1,255
9d001804:	27a40028 	addiu	a0,sp,40
9d001808:	0f400629 	jal	9d0018a4 <_ZN6Client5writeEh>
9d00180c:	240500fc 	li	a1,252
9d001810:	9205000a 	lbu	a1,10(s0)
9d001814:	0f400629 	jal	9d0018a4 <_ZN6Client5writeEh>
9d001818:	27a40028 	addiu	a0,sp,40
9d00181c:	0b4005dc 	j	9d001770 <loop+0x3c4>
9d001820:	3c059d01 	lui	a1,0x9d01

9d001824 <_GLOBAL__I_mac>:
9d001824:	0b4004ca 	j	9d001328 <_Z41__static_initialization_and_destruction_0ii.clone.0>
9d001828:	24040001 	li	a0,1

9d00182c <_GLOBAL__D_mac>:
9d00182c:	0b4004ca 	j	9d001328 <_Z41__static_initialization_and_destruction_0ii.clone.0>
9d001830:	00002021 	move	a0,zero

9d001834 <_ZN6Client5flushEv>:
**      as the MAL's TCPDiscard() function.
**      
*/
void Client::flush() 
{
    ChipKITClientFlush(_hTCP);
9d001834:	0b400a33 	j	9d0028cc <ChipKITClientFlush>
9d001838:	90840004 	lbu	a0,4(a0)

9d00183c <_ZN6Client4peekEv>:
**      This is an undocumented but existing Arduino Ethernet method
**      
*/
int Client::peek() 
{
  return(ChipKITClientPeek(_hTCP));
9d00183c:	0b400a3a 	j	9d0028e8 <ChipKITClientPeek>
9d001840:	90840004 	lbu	a0,4(a0)

9d001844 <_ZN6Client4readEPhm>:
**      See http://arduino.cc/en/Reference/ClientRead for more info
**      
*/
int Client::read(uint8_t *buf, size_t size) 
{
  return(ChipKITClientGetBuff(_hTCP, buf, size));
9d001844:	90840004 	lbu	a0,4(a0)
9d001848:	0b400928 	j	9d0024a0 <ChipKITClientGetBuff>
9d00184c:	30c6ffff 	andi	a2,a2,0xffff

9d001850 <_ZN6Client4readEv>:
**      Same as defined by http://arduino.cc/en/Reference/ClientRead
**      
*/
int Client::read() 
{
    return(ChipKITClientGetByte(_hTCP));
9d001850:	0b400912 	j	9d002448 <ChipKITClientGetByte>
9d001854:	90840004 	lbu	a0,4(a0)

9d001858 <_ZN6Client9availableEv>:
**	Description:
**      Same as defined by http://arduino.cc/en/Reference/ClientAvailable
*/
int Client::available() 
{
    if(ChipKITValidTCPHandle(_hTCP))
9d001858:	90840004 	lbu	a0,4(a0)
9d00185c:	24820002 	addiu	v0,a0,2
9d001860:	304200ff 	andi	v0,v0,0xff
9d001864:	2c420002 	sltiu	v0,v0,2
9d001868:	14400003 	bnez	v0,9d001878 <_ZN6Client9availableEv+0x20>
9d00186c:	00000000 	nop
    {
        return(ChipKITClientAvailable(_hTCP));
9d001870:	0b400908 	j	9d002420 <ChipKITClientAvailable>
9d001874:	00000000 	nop
    }
    else
    {
        return(0);
    }
}
9d001878:	03e00008 	jr	ra
9d00187c:	00001021 	move	v0,zero

9d001880 <_ZN6Client5writeEPKhm>:
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Client::write(const uint8_t *buf, size_t size)
{
9d001880:	00801021 	move	v0,a0
    ChipKITClientPutBuff(_hTCP, buf, size, _cSecTimeout);
9d001884:	8c470014 	lw	a3,20(v0)
9d001888:	90840004 	lbu	a0,4(a0)
9d00188c:	0b4009b4 	j	9d0026d0 <ChipKITClientPutBuff>
9d001890:	30c6ffff 	andi	a2,a2,0xffff

9d001894 <_ZN6Client5writeEPKc>:
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Client::write(const char *str) 
{
9d001894:	00801021 	move	v0,a0
    ChipKITClientPutSz(_hTCP, str, _cSecTimeout);
9d001898:	8c460014 	lw	a2,20(v0)
9d00189c:	0b400967 	j	9d00259c <ChipKITClientPutSz>
9d0018a0:	90840004 	lbu	a0,4(a0)

9d0018a4 <_ZN6Client5writeEh>:
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
*/
void Client::write(uint8_t b) 
{
    ChipKITClientPutByte(_hTCP, b);
9d0018a4:	90840004 	lbu	a0,4(a0)
9d0018a8:	0b400950 	j	9d002540 <ChipKITClientPutByte>
9d0018ac:	30a500ff 	andi	a1,a1,0xff

9d0018b0 <_ZN6ClientC1Ev>:
**      None
**
**	Description:
**      
*/
Client::Client()
9d0018b0:	3c029d01 	lui	v0,0x9d01
9d0018b4:	2442dba0 	addiu	v0,v0,-9312
9d0018b8:	ac820000 	sw	v0,0(a0)
**	Description:
**      
*/
void Client::PrivateInit(void)
{
    _hTCP = INVALID_SOCKET;
9d0018bc:	2402fffe 	li	v0,-2
9d0018c0:	a0820004 	sb	v0,4(a0)
    _szURL = NULL;
    _ip = 0;
    _port = 0;
    _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;  // default value
9d0018c4:	2402001e 	li	v0,30
**      
*/
void Client::PrivateInit(void)
{
    _hTCP = INVALID_SOCKET;
    _szURL = NULL;
9d0018c8:	ac80000c 	sw	zero,12(a0)
    _ip = 0;
9d0018cc:	ac800008 	sw	zero,8(a0)
    _port = 0;
9d0018d0:	a4800010 	sh	zero,16(a0)
**      
*/
Client::Client()
{
    PrivateInit();
}
9d0018d4:	03e00008 	jr	ra
9d0018d8:	ac820014 	sw	v0,20(a0)

9d0018dc <_ZN6ClientC1Eh>:
**      hTCP    - socket to use.
**
**	Description:
**      
*/
Client::Client(TCP_SOCKET hTCP)
9d0018dc:	3c029d01 	lui	v0,0x9d01
9d0018e0:	2442dba0 	addiu	v0,v0,-9312
9d0018e4:	ac820000 	sw	v0,0(a0)
{
    _hTCP = INVALID_SOCKET;
    _szURL = NULL;
    _ip = 0;
    _port = 0;
    _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;  // default value
9d0018e8:	2402001e 	li	v0,30
**      
*/
void Client::PrivateInit(void)
{
    _hTCP = INVALID_SOCKET;
    _szURL = NULL;
9d0018ec:	ac80000c 	sw	zero,12(a0)
    _ip = 0;
9d0018f0:	ac800008 	sw	zero,8(a0)
    _port = 0;
9d0018f4:	a4800010 	sh	zero,16(a0)
    _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;  // default value
9d0018f8:	ac820014 	sw	v0,20(a0)
*/
Client::Client(TCP_SOCKET hTCP)
{
    PrivateInit();
    _hTCP = hTCP;
}
9d0018fc:	03e00008 	jr	ra
9d001900:	a0850004 	sb	a1,4(a0)

9d001904 <_ZN6Client12PrivateResetEv>:
**
**	Description:
**      
*/
void Client::PrivateReset(void)
{
9d001904:	27bdffe8 	addiu	sp,sp,-24
9d001908:	afb00010 	sw	s0,16(sp)
9d00190c:	00808021 	move	s0,a0
    if(_szURL != NULL)
9d001910:	8c84000c 	lw	a0,12(a0)
9d001914:	10800003 	beqz	a0,9d001924 <_ZN6Client12PrivateResetEv+0x20>
9d001918:	afbf0014 	sw	ra,20(sp)
    {
        free(_szURL);
9d00191c:	0f402e17 	jal	9d00b85c <free>
9d001920:	00000000 	nop
**	Description:
**      
*/
void Client::PrivateInit(void)
{
    _hTCP = INVALID_SOCKET;
9d001924:	2402fffe 	li	v0,-2
9d001928:	a2020004 	sb	v0,4(s0)
        free(_szURL);
        _szURL = NULL;
    }

    PrivateInit();
}
9d00192c:	8fbf0014 	lw	ra,20(sp)
{
    _hTCP = INVALID_SOCKET;
    _szURL = NULL;
    _ip = 0;
    _port = 0;
    _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;  // default value
9d001930:	2402001e 	li	v0,30
**      
*/
void Client::PrivateInit(void)
{
    _hTCP = INVALID_SOCKET;
    _szURL = NULL;
9d001934:	ae00000c 	sw	zero,12(s0)
    _ip = 0;
9d001938:	ae000008 	sw	zero,8(s0)
    _port = 0;
9d00193c:	a6000010 	sh	zero,16(s0)
    _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;  // default value
9d001940:	ae020014 	sw	v0,20(s0)
        free(_szURL);
        _szURL = NULL;
    }

    PrivateInit();
}
9d001944:	8fb00010 	lw	s0,16(sp)
9d001948:	03e00008 	jr	ra
9d00194c:	27bd0018 	addiu	sp,sp,24

9d001950 <_ZN6ClientD1Ev>:
/***	Client Destructor
**
**	Synopsis:   This clean up all allocated data when the Client Class is destructed
**
*/
Client::~Client()
9d001950:	3c029d01 	lui	v0,0x9d01
9d001954:	2442dba0 	addiu	v0,v0,-9312
{
    PrivateReset();
9d001958:	0b400641 	j	9d001904 <_ZN6Client12PrivateResetEv>
9d00195c:	ac820000 	sw	v0,0(a0)

9d001960 <_ZN6ClientcvbEv>:
**	Description:
**      
*/
Client::operator bool() 
{
  return(ChipKITValidTCPHandle(_hTCP));
9d001960:	90820004 	lbu	v0,4(a0)
9d001964:	24420002 	addiu	v0,v0,2
9d001968:	304200ff 	andi	v0,v0,0xff
9d00196c:	2c420002 	sltiu	v0,v0,2
}
9d001970:	03e00008 	jr	ra
9d001974:	38420001 	xori	v0,v0,0x1

9d001978 <_ZN6ClientaSERKS_>:
**
**	Description:
**      
*/
Client& Client::operator=(const Client& otherClient)
{
9d001978:	27bdffe0 	addiu	sp,sp,-32
9d00197c:	afb10018 	sw	s1,24(sp)
9d001980:	00a08821 	move	s1,a1
9d001984:	afb00014 	sw	s0,20(sp)
9d001988:	afbf001c 	sw	ra,28(sp)
    PrivateReset();
9d00198c:	0f400641 	jal	9d001904 <_ZN6Client12PrivateResetEv>
9d001990:	00808021 	move	s0,a0
     _hTCP = otherClient._hTCP;
9d001994:	92260004 	lbu	a2,4(s1)
    _ip = otherClient._ip;
9d001998:	8e250008 	lw	a1,8(s1)
    _port = otherClient._port;
9d00199c:	96230010 	lhu	v1,16(s1)
    _cSecTimeout = otherClient._cSecTimeout;
9d0019a0:	8e220014 	lw	v0,20(s1)
 
    if(otherClient._szURL != NULL)
9d0019a4:	8e24000c 	lw	a0,12(s1)
**      
*/
Client& Client::operator=(const Client& otherClient)
{
    PrivateReset();
     _hTCP = otherClient._hTCP;
9d0019a8:	a2060004 	sb	a2,4(s0)
    _ip = otherClient._ip;
9d0019ac:	ae050008 	sw	a1,8(s0)
    _port = otherClient._port;
9d0019b0:	a6030010 	sh	v1,16(s0)
    _cSecTimeout = otherClient._cSecTimeout;
 
    if(otherClient._szURL != NULL)
9d0019b4:	10800009 	beqz	a0,9d0019dc <_ZN6ClientaSERKS_+0x64>
9d0019b8:	ae020014 	sw	v0,20(s0)
    {
        _szURL = (char *) malloc(strlen(otherClient._szURL) + 1);
9d0019bc:	0f40301c 	jal	9d00c070 <strlen>
9d0019c0:	00000000 	nop
9d0019c4:	0f402e0d 	jal	9d00b834 <malloc>
9d0019c8:	24440001 	addiu	a0,v0,1
9d0019cc:	ae02000c 	sw	v0,12(s0)
        strcpy(_szURL, otherClient._szURL);
9d0019d0:	8e25000c 	lw	a1,12(s1)
9d0019d4:	0f403013 	jal	9d00c04c <strcpy>
9d0019d8:	00402021 	move	a0,v0
    }

    return(*this);
}
9d0019dc:	8fbf001c 	lw	ra,28(sp)
9d0019e0:	02001021 	move	v0,s0
9d0019e4:	8fb10018 	lw	s1,24(sp)
9d0019e8:	8fb00014 	lw	s0,20(sp)
9d0019ec:	03e00008 	jr	ra
9d0019f0:	27bd0020 	addiu	sp,sp,32

9d0019f4 <_ZN6ClientC1ERKS_>:
**	Errors:
**
**	Description:
**      
*/
Client::Client(const Client& otherClient)
9d0019f4:	3c039d01 	lui	v1,0x9d01
9d0019f8:	2463dba0 	addiu	v1,v1,-9312
9d0019fc:	ac830000 	sw	v1,0(a0)
**	Description:
**      
*/
void Client::PrivateInit(void)
{
    _hTCP = INVALID_SOCKET;
9d001a00:	2403fffe 	li	v1,-2
9d001a04:	a0830004 	sb	v1,4(a0)
    _szURL = NULL;
    _ip = 0;
    _port = 0;
    _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;  // default value
9d001a08:	2403001e 	li	v1,30
**      
*/
void Client::PrivateInit(void)
{
    _hTCP = INVALID_SOCKET;
    _szURL = NULL;
9d001a0c:	ac80000c 	sw	zero,12(a0)
    _ip = 0;
9d001a10:	ac800008 	sw	zero,8(a0)
    _port = 0;
9d001a14:	a4800010 	sh	zero,16(a0)
**      
*/
Client::Client(const Client& otherClient)
{
    PrivateInit();          // must be called as the this does not call the default constructor to init.
    *this = otherClient;    // use the assigment operator to do the copy.
9d001a18:	0b40065e 	j	9d001978 <_ZN6ClientaSERKS_>
9d001a1c:	ac830014 	sw	v1,20(a0)

9d001a20 <_ZN6Client9connectedEv>:
**	Description:
**      Same as defined by http://arduino.cc/en/Reference/ClientConnected
**      
*/
uint8_t Client::connected() 
{
9d001a20:	27bdffe8 	addiu	sp,sp,-24
9d001a24:	afbf0014 	sw	ra,20(sp)
   return(ChipKITClientConnected(_hTCP));
9d001a28:	0f400a23 	jal	9d00288c <ChipKITClientConnected>
9d001a2c:	90840004 	lbu	a0,4(a0)
}
9d001a30:	8fbf0014 	lw	ra,20(sp)
9d001a34:	304200ff 	andi	v0,v0,0xff
9d001a38:	03e00008 	jr	ra
9d001a3c:	27bd0018 	addiu	sp,sp,24

9d001a40 <_ZN20ChipKITEthernetClass5beginEPhS0_S0_S0_S0_>:
**
**	Description:
**      Refer to the Arduino documentation http://arduino.cc/en/Reference/EthernetBegin 
*/
void ChipKITEthernetClass::begin(uint8_t *mac, uint8_t *ip, uint8_t *gateway, uint8_t *subnet, uint8_t *dns1)
{
9d001a40:	27bdffd8 	addiu	sp,sp,-40
**      Refer to the Arduino documentation http://arduino.cc/en/Reference/EthernetBegin 
*/
void ChipKITEthernetClass::begin(uint8_t *mac, uint8_t *ip, uint8_t *gateway, uint8_t *subnet, uint8_t *dns1, uint8_t *dns2)
{
  
  ChipKITEthernetBegin(mac, ip, gateway, subnet, dns1, dns2);
9d001a44:	8fa2003c 	lw	v0,60(sp)
9d001a48:	00a02021 	move	a0,a1
9d001a4c:	00c02821 	move	a1,a2
9d001a50:	00e03021 	move	a2,a3
9d001a54:	8fa70038 	lw	a3,56(sp)
9d001a58:	afa20010 	sw	v0,16(sp)
9d001a5c:	27a20018 	addiu	v0,sp,24
**
**	Description:
**      Refer to the Arduino documentation http://arduino.cc/en/Reference/EthernetBegin 
*/
void ChipKITEthernetClass::begin(uint8_t *mac, uint8_t *ip, uint8_t *gateway, uint8_t *subnet, uint8_t *dns1)
{
9d001a60:	afbf0024 	sw	ra,36(sp)
    uint8_t dns[] = {0,0,0,0};      // probably already set a DNS server in dns1
9d001a64:	a3a00018 	sb	zero,24(sp)
9d001a68:	a3a00019 	sb	zero,25(sp)
9d001a6c:	a3a0001a 	sb	zero,26(sp)
9d001a70:	a3a0001b 	sb	zero,27(sp)
**      Refer to the Arduino documentation http://arduino.cc/en/Reference/EthernetBegin 
*/
void ChipKITEthernetClass::begin(uint8_t *mac, uint8_t *ip, uint8_t *gateway, uint8_t *subnet, uint8_t *dns1, uint8_t *dns2)
{
  
  ChipKITEthernetBegin(mac, ip, gateway, subnet, dns1, dns2);
9d001a74:	0f40080d 	jal	9d002034 <ChipKITEthernetBegin>
9d001a78:	afa20014 	sw	v0,20(sp)
void ChipKITEthernetClass::begin(uint8_t *mac, uint8_t *ip, uint8_t *gateway, uint8_t *subnet, uint8_t *dns1)
{
    uint8_t dns[] = {0,0,0,0};      // probably already set a DNS server in dns1

    begin(mac, ip, gateway, subnet, dns1, dns);
}
9d001a7c:	8fbf0024 	lw	ra,36(sp)
9d001a80:	03e00008 	jr	ra
9d001a84:	27bd0028 	addiu	sp,sp,40

9d001a88 <_ZN20ChipKITEthernetClass5beginEPhS0_S0_S0_>:
{
    uint8_t dns[4];

    // often a router/gateway will work as a DNS server, so if no DNS server
    // is specifed, then apply the gateway
    memcpy(dns, gateway, 4);
9d001a88:	88e30003 	lwl	v1,3(a3)
**
**	Description:
**      Refer to the Arduino documentation http://arduino.cc/en/Reference/EthernetBegin 
*/
void ChipKITEthernetClass::begin(uint8_t *mac, uint8_t *ip, uint8_t *gateway, uint8_t *subnet)
{
9d001a8c:	27bdffd8 	addiu	sp,sp,-40

    // often a router/gateway will work as a DNS server, so if no DNS server
    // is specifed, then apply the gateway
    memcpy(dns, gateway, 4);

    begin(mac, ip, gateway, subnet, dns);
9d001a90:	8fa20038 	lw	v0,56(sp)
{
    uint8_t dns[4];

    // often a router/gateway will work as a DNS server, so if no DNS server
    // is specifed, then apply the gateway
    memcpy(dns, gateway, 4);
9d001a94:	98e30000 	lwr	v1,0(a3)
**
**	Description:
**      Refer to the Arduino documentation http://arduino.cc/en/Reference/EthernetBegin 
*/
void ChipKITEthernetClass::begin(uint8_t *mac, uint8_t *ip, uint8_t *gateway, uint8_t *subnet)
{
9d001a98:	afbf0024 	sw	ra,36(sp)

    // often a router/gateway will work as a DNS server, so if no DNS server
    // is specifed, then apply the gateway
    memcpy(dns, gateway, 4);

    begin(mac, ip, gateway, subnet, dns);
9d001a9c:	afa20010 	sw	v0,16(sp)
9d001aa0:	27a20018 	addiu	v0,sp,24
9d001aa4:	afa20014 	sw	v0,20(sp)
9d001aa8:	0f400690 	jal	9d001a40 <_ZN20ChipKITEthernetClass5beginEPhS0_S0_S0_S0_>
9d001aac:	afa30018 	sw	v1,24(sp)
}
9d001ab0:	8fbf0024 	lw	ra,36(sp)
9d001ab4:	03e00008 	jr	ra
9d001ab8:	27bd0028 	addiu	sp,sp,40

9d001abc <_ZN20ChipKITEthernetClass13PeriodicTasksEv>:
**
**	Errors:
*/
void  ChipKITEthernetClass::PeriodicTasks()
{
    ChipKITPeriodicTasks();
9d001abc:	0b4007b6 	j	9d001ed8 <ChipKITPeriodicTasks>
9d001ac0:	00000000 	nop

9d001ac4 <_ZN6Server5writeEPKhm>:
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Server::write(const uint8_t *buffer, size_t size) 
{
9d001ac4:	27bdffd8 	addiu	sp,sp,-40
9d001ac8:	afb30020 	sw	s3,32(sp)
   SKL * psklNow = sklListening.psklNext;
9d001acc:	8c930010 	lw	s3,16(a0)
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Server::write(const uint8_t *buffer, size_t size) 
{
9d001ad0:	afb10018 	sw	s1,24(sp)
9d001ad4:	afb00014 	sw	s0,20(sp)
9d001ad8:	afbf0024 	sw	ra,36(sp)
9d001adc:	afb2001c 	sw	s2,28(sp)
9d001ae0:	00808021 	move	s0,a0
   SKL * psklNow = sklListening.psklNext;

    while(psklNow != NULL)
9d001ae4:	1260000a 	beqz	s3,9d001b10 <_ZN6Server5writeEPKhm+0x4c>
9d001ae8:	00a08821 	move	s1,a1
9d001aec:	30d2ffff 	andi	s2,a2,0xffff
    {
        ChipKITClientPutBuff(psklNow->hTCP, buffer, size, _cSecTimeout);
9d001af0:	92640000 	lbu	a0,0(s3)
9d001af4:	8e070014 	lw	a3,20(s0)
9d001af8:	02202821 	move	a1,s1
9d001afc:	0f4009b4 	jal	9d0026d0 <ChipKITClientPutBuff>
9d001b00:	02403021 	move	a2,s2
        psklNow = psklNow->psklNext;
9d001b04:	8e730008 	lw	s3,8(s3)
*/
void Server::write(const uint8_t *buffer, size_t size) 
{
   SKL * psklNow = sklListening.psklNext;

    while(psklNow != NULL)
9d001b08:	5660fffa 	bnezl	s3,9d001af4 <_ZN6Server5writeEPKhm+0x30>
9d001b0c:	92640000 	lbu	a0,0(s3)
    {
        ChipKITClientPutBuff(psklNow->hTCP, buffer, size, _cSecTimeout);
        psklNow = psklNow->psklNext;
    }
}
9d001b10:	8fbf0024 	lw	ra,36(sp)
9d001b14:	8fb30020 	lw	s3,32(sp)
9d001b18:	8fb2001c 	lw	s2,28(sp)
9d001b1c:	8fb10018 	lw	s1,24(sp)
9d001b20:	8fb00014 	lw	s0,20(sp)
9d001b24:	03e00008 	jr	ra
9d001b28:	27bd0028 	addiu	sp,sp,40

9d001b2c <_ZN6Server5writeEPKc>:
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Server::write(const char *str) 
{
9d001b2c:	27bdffe0 	addiu	sp,sp,-32
9d001b30:	afb20018 	sw	s2,24(sp)
   SKL * psklNow = sklListening.psklNext;
9d001b34:	8c920010 	lw	s2,16(a0)
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Server::write(const char *str) 
{
9d001b38:	afb10014 	sw	s1,20(sp)
9d001b3c:	afb00010 	sw	s0,16(sp)
9d001b40:	afbf001c 	sw	ra,28(sp)
9d001b44:	00808021 	move	s0,a0
   SKL * psklNow = sklListening.psklNext;

    while(psklNow != NULL)
9d001b48:	12400008 	beqz	s2,9d001b6c <_ZN6Server5writeEPKc+0x40>
9d001b4c:	00a08821 	move	s1,a1
    {
        ChipKITClientPutSz(psklNow->hTCP, str, _cSecTimeout);
9d001b50:	92440000 	lbu	a0,0(s2)
9d001b54:	8e060014 	lw	a2,20(s0)
9d001b58:	0f400967 	jal	9d00259c <ChipKITClientPutSz>
9d001b5c:	02202821 	move	a1,s1
        psklNow = psklNow->psklNext;
9d001b60:	8e520008 	lw	s2,8(s2)
*/
void Server::write(const char *str) 
{
   SKL * psklNow = sklListening.psklNext;

    while(psklNow != NULL)
9d001b64:	5640fffb 	bnezl	s2,9d001b54 <_ZN6Server5writeEPKc+0x28>
9d001b68:	92440000 	lbu	a0,0(s2)
    {
        ChipKITClientPutSz(psklNow->hTCP, str, _cSecTimeout);
        psklNow = psklNow->psklNext;
    }
}
9d001b6c:	8fbf001c 	lw	ra,28(sp)
9d001b70:	8fb20018 	lw	s2,24(sp)
9d001b74:	8fb10014 	lw	s1,20(sp)
9d001b78:	8fb00010 	lw	s0,16(sp)
9d001b7c:	03e00008 	jr	ra
9d001b80:	27bd0020 	addiu	sp,sp,32

9d001b84 <_ZN6Server5writeEh>:
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Server::write(uint8_t b) 
{
9d001b84:	27bdffe0 	addiu	sp,sp,-32
9d001b88:	afb10018 	sw	s1,24(sp)
   SKL * psklNow = sklListening.psklNext;
9d001b8c:	8c910010 	lw	s1,16(a0)
**      And http://arduino.cc/en/Reference/ServerPrint
**      And http://arduino.cc/en/Reference/ServerPrintln
**      
*/
void Server::write(uint8_t b) 
{
9d001b90:	afb00014 	sw	s0,20(sp)
9d001b94:	afbf001c 	sw	ra,28(sp)
   SKL * psklNow = sklListening.psklNext;

    while(psklNow != NULL)
9d001b98:	12200007 	beqz	s1,9d001bb8 <_ZN6Server5writeEh+0x34>
9d001b9c:	30b000ff 	andi	s0,a1,0xff
    {
        ChipKITClientPutByte(psklNow->hTCP, b);
9d001ba0:	92240000 	lbu	a0,0(s1)
9d001ba4:	0f400950 	jal	9d002540 <ChipKITClientPutByte>
9d001ba8:	02002821 	move	a1,s0
        psklNow = psklNow->psklNext;
9d001bac:	8e310008 	lw	s1,8(s1)
*/
void Server::write(uint8_t b) 
{
   SKL * psklNow = sklListening.psklNext;

    while(psklNow != NULL)
9d001bb0:	5620fffc 	bnezl	s1,9d001ba4 <_ZN6Server5writeEh+0x20>
9d001bb4:	92240000 	lbu	a0,0(s1)
    {
        ChipKITClientPutByte(psklNow->hTCP, b);
        psklNow = psklNow->psklNext;
    }
}
9d001bb8:	8fbf001c 	lw	ra,28(sp)
9d001bbc:	8fb10018 	lw	s1,24(sp)
9d001bc0:	8fb00014 	lw	s0,20(sp)
9d001bc4:	03e00008 	jr	ra
9d001bc8:	27bd0020 	addiu	sp,sp,32

9d001bcc <__tcf_0>:
*/
Client Server::available()
{
    // just an empty client with an invalid socket
    // static only because we want to construct it once.
    static Client ClientFail;  
9d001bcc:	3c04a000 	lui	a0,0xa000
9d001bd0:	0b400654 	j	9d001950 <_ZN6ClientD1Ev>
9d001bd4:	24840ab0 	addiu	a0,a0,2736

9d001bd8 <_ZN6ServerC1Et>:
**
**	Description:
**      Same as defined by http://arduino.cc/en/Reference/ServerConstructor
**      
*/
Server::Server(uint16_t port)
9d001bd8:	3c029d01 	lui	v0,0x9d01
9d001bdc:	2442dbc8 	addiu	v0,v0,-9272
9d001be0:	ac820000 	sw	v0,0(a0)
{
  _port = port;
  sklListening.hTCP = UNKNOWN_SOCKET;
9d001be4:	2402ffff 	li	v0,-1
9d001be8:	a0820008 	sb	v0,8(a0)
  sklListening.psklNext = NULL;
  sklListening.psklBack = NULL;
  _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;
9d001bec:	2402001e 	li	v0,30
**      Same as defined by http://arduino.cc/en/Reference/ServerConstructor
**      
*/
Server::Server(uint16_t port)
{
  _port = port;
9d001bf0:	a4850004 	sh	a1,4(a0)
  sklListening.hTCP = UNKNOWN_SOCKET;
  sklListening.psklNext = NULL;
9d001bf4:	ac800010 	sw	zero,16(a0)
  sklListening.psklBack = NULL;
9d001bf8:	ac80000c 	sw	zero,12(a0)
  _cSecTimeout = ETHERNET_DEFAULT_TIMEOUT;
}
9d001bfc:	03e00008 	jr	ra
9d001c00:	ac820014 	sw	v0,20(a0)

9d001c04 <_ZN6ServerD1Ev>:
**
**	Synopsis:   This clean up all allocated data and releases all clients
**              attached to the server.
**
*/
Server::~Server()
9d001c04:	27bdffe0 	addiu	sp,sp,-32
9d001c08:	afb10014 	sw	s1,20(sp)
{
    SKL *   psklNow = sklListening.psklNext;
9d001c0c:	8c910010 	lw	s1,16(a0)
**
**	Synopsis:   This clean up all allocated data and releases all clients
**              attached to the server.
**
*/
Server::~Server()
9d001c10:	3c029d01 	lui	v0,0x9d01
9d001c14:	2442dbc8 	addiu	v0,v0,-9272
9d001c18:	afb00010 	sw	s0,16(sp)
9d001c1c:	afbf001c 	sw	ra,28(sp)
9d001c20:	afb20018 	sw	s2,24(sp)
9d001c24:	00808021 	move	s0,a0
{
    SKL *   psklNow = sklListening.psklNext;

    while(psklNow != NULL) 
9d001c28:	16200003 	bnez	s1,9d001c38 <_ZN6ServerD1Ev+0x34>
9d001c2c:	ac820000 	sw	v0,0(a0)

        free(psklDelete);
    }

  _port = 0;
  sklListening.hTCP = UNKNOWN_SOCKET;
9d001c30:	0b400716 	j	9d001c58 <_ZN6ServerD1Ev+0x54>
9d001c34:	2402ffff 	li	v0,-1

        SKL *   psklDelete = psklNow;
        psklNow = psklNow->psklNext;

        // We have to close this so the socket goes back to the TCPIP stack.
        ChipKITClientStop(psklDelete->hTCP);
9d001c38:	92240000 	lbu	a0,0(s1)
9d001c3c:	0f400a0d 	jal	9d002834 <ChipKITClientStop>
9d001c40:	8e320008 	lw	s2,8(s1)

        free(psklDelete);
9d001c44:	0f402e17 	jal	9d00b85c <free>
9d001c48:	02202021 	move	a0,s1
*/
Server::~Server()
{
    SKL *   psklNow = sklListening.psklNext;

    while(psklNow != NULL) 
9d001c4c:	1640fffa 	bnez	s2,9d001c38 <_ZN6ServerD1Ev+0x34>
9d001c50:	02408821 	move	s1,s2

        free(psklDelete);
    }

  _port = 0;
  sklListening.hTCP = UNKNOWN_SOCKET;
9d001c54:	2402ffff 	li	v0,-1
9d001c58:	a2020008 	sb	v0,8(s0)
  sklListening.psklNext = NULL;
  sklListening.psklBack = NULL;
}
9d001c5c:	8fbf001c 	lw	ra,28(sp)
        ChipKITClientStop(psklDelete->hTCP);

        free(psklDelete);
    }

  _port = 0;
9d001c60:	a6000004 	sh	zero,4(s0)
  sklListening.hTCP = UNKNOWN_SOCKET;
  sklListening.psklNext = NULL;
9d001c64:	ae000010 	sw	zero,16(s0)
  sklListening.psklBack = NULL;
9d001c68:	ae00000c 	sw	zero,12(s0)
}
9d001c6c:	8fb20018 	lw	s2,24(sp)
9d001c70:	8fb10014 	lw	s1,20(sp)
9d001c74:	8fb00010 	lw	s0,16(sp)
9d001c78:	03e00008 	jr	ra
9d001c7c:	27bd0020 	addiu	sp,sp,32

9d001c80 <_ZN6Server5beginEv>:
**	Description:
**      Same as defined by http://arduino.cc/en/Reference/ServerBegin
**      
*/
void Server::begin()
{
9d001c80:	27bdffe8 	addiu	sp,sp,-24
9d001c84:	afb00010 	sw	s0,16(sp)
9d001c88:	afbf0014 	sw	ra,20(sp)
    // we have already begun, don't do it again
    if(ChipKITValidTCPHandle(sklListening.hTCP))
9d001c8c:	90820008 	lbu	v0,8(a0)
9d001c90:	24420002 	addiu	v0,v0,2
9d001c94:	304200ff 	andi	v0,v0,0xff
9d001c98:	2c420002 	sltiu	v0,v0,2
9d001c9c:	14400005 	bnez	v0,9d001cb4 <_ZN6Server5beginEv+0x34>
9d001ca0:	00808021 	move	s0,a0
    }

    // really too bad we can't return an error to
    // tell us if we got a socket or not.
    sklListening.hTCP = ChipKITServerListenPORT(_port);
}
9d001ca4:	8fbf0014 	lw	ra,20(sp)
9d001ca8:	8fb00010 	lw	s0,16(sp)
9d001cac:	03e00008 	jr	ra
9d001cb0:	27bd0018 	addiu	sp,sp,24
        return;
    }

    // really too bad we can't return an error to
    // tell us if we got a socket or not.
    sklListening.hTCP = ChipKITServerListenPORT(_port);
9d001cb4:	94860004 	lhu	a2,4(a0)
9d001cb8:	00002821 	move	a1,zero
9d001cbc:	00002021 	move	a0,zero
9d001cc0:	0f4008c8 	jal	9d002320 <ChipKITClientConnect>
9d001cc4:	24070001 	li	a3,1
9d001cc8:	a2020008 	sb	v0,8(s0)
}
9d001ccc:	8fbf0014 	lw	ra,20(sp)
9d001cd0:	8fb00010 	lw	s0,16(sp)
9d001cd4:	03e00008 	jr	ra
9d001cd8:	27bd0018 	addiu	sp,sp,24

9d001cdc <_ZN6Server19ServiceSocketListenEv>:
**	Description:
**      This is a server maintainace routine
**      
*/
void Server::ServiceSocketListen(void)
{
9d001cdc:	27bdffe0 	addiu	sp,sp,-32
9d001ce0:	afb00010 	sw	s0,16(sp)
9d001ce4:	00808021 	move	s0,a0
    SKL * psklNow = NULL;

    // let things run so we can pick up a listen event
    Ethernet.PeriodicTasks();
9d001ce8:	2784804c 	addiu	a0,gp,-32692
**	Description:
**      This is a server maintainace routine
**      
*/
void Server::ServiceSocketListen(void)
{
9d001cec:	afbf001c 	sw	ra,28(sp)
9d001cf0:	afb20018 	sw	s2,24(sp)
    SKL * psklNow = NULL;

    // let things run so we can pick up a listen event
    Ethernet.PeriodicTasks();
9d001cf4:	0f4006af 	jal	9d001abc <_ZN20ChipKITEthernetClass13PeriodicTasksEv>
9d001cf8:	afb10014 	sw	s1,20(sp)

    // if the handle we are listening on is valid and  connected
    // then create a Client in the list with this handle
    if(ChipKITValidTCPHandle(sklListening.hTCP) && ChipKITClientConnected(sklListening.hTCP))
9d001cfc:	92040008 	lbu	a0,8(s0)
9d001d00:	24820002 	addiu	v0,a0,2
9d001d04:	304200ff 	andi	v0,v0,0xff
9d001d08:	2c420002 	sltiu	v0,v0,2
9d001d0c:	54400006 	bnezl	v0,9d001d28 <_ZN6Server19ServiceSocketListenEv+0x4c>
9d001d10:	8e100010 	lw	s0,16(s0)
9d001d14:	0f400a23 	jal	9d00288c <ChipKITClientConnected>
9d001d18:	00000000 	nop
9d001d1c:	5440001c 	bnezl	v0,9d001d90 <_ZN6Server19ServiceSocketListenEv+0xb4>
9d001d20:	96060004 	lhu	a2,4(s0)
        }
   }

    // now go through the list and delete any sockets that are not connected.
    // remember the first Client is always a false client, so start with the first one in the list after the false one.
    psklNow = sklListening.psklNext;
9d001d24:	8e100010 	lw	s0,16(s0)
    while(psklNow != NULL)
9d001d28:	12000014 	beqz	s0,9d001d7c <_ZN6Server19ServiceSocketListenEv+0xa0>
9d001d2c:	8fbf001c 	lw	ra,28(sp)
    {
 
        // here is one that is no longer connected
        if(!ChipKITClientConnected(psklNow->hTCP))
9d001d30:	0f400a23 	jal	9d00288c <ChipKITClientConnected>
9d001d34:	92040000 	lbu	a0,0(s0)
9d001d38:	5440000e 	bnezl	v0,9d001d74 <_ZN6Server19ServiceSocketListenEv+0x98>
9d001d3c:	8e100008 	lw	s0,8(s0)
        {
            SKL * psklFree = psklNow;
            psklNow = psklNow->psklBack;
9d001d40:	8e110004 	lw	s1,4(s0)

            if(psklFree->psklNext != NULL)
9d001d44:	8e020008 	lw	v0,8(s0)
9d001d48:	10400003 	beqz	v0,9d001d58 <_ZN6Server19ServiceSocketListenEv+0x7c>
9d001d4c:	02201821 	move	v1,s1
            {
                psklFree->psklNext->psklBack = psklFree->psklBack;
9d001d50:	ac510004 	sw	s1,4(v0)
9d001d54:	8e030004 	lw	v1,4(s0)
    
            // there should always be a back pointer; if not point back to sklListening
            psklFree->psklBack->psklNext = psklFree->psklNext;

            // We have to close this so the socket goes back to the TCPIP stack.
            ChipKITClientStop(psklFree->hTCP);
9d001d58:	92040000 	lbu	a0,0(s0)
9d001d5c:	0f400a0d 	jal	9d002834 <ChipKITClientStop>
9d001d60:	ac620008 	sw	v0,8(v1)

            // get rid of this client;
            free(psklFree);
9d001d64:	0f402e17 	jal	9d00b85c <free>
9d001d68:	02002021 	move	a0,s0
 
        // here is one that is no longer connected
        if(!ChipKITClientConnected(psklNow->hTCP))
        {
            SKL * psklFree = psklNow;
            psklNow = psklNow->psklBack;
9d001d6c:	02208021 	move	s0,s1

            // get rid of this client;
            free(psklFree);
        }

        psklNow = psklNow->psklNext;
9d001d70:	8e100008 	lw	s0,8(s0)
   }

    // now go through the list and delete any sockets that are not connected.
    // remember the first Client is always a false client, so start with the first one in the list after the false one.
    psklNow = sklListening.psklNext;
    while(psklNow != NULL)
9d001d74:	1600ffee 	bnez	s0,9d001d30 <_ZN6Server19ServiceSocketListenEv+0x54>
9d001d78:	8fbf001c 	lw	ra,28(sp)
            free(psklFree);
        }

        psklNow = psklNow->psklNext;
    }
}
9d001d7c:	8fb20018 	lw	s2,24(sp)
9d001d80:	8fb10014 	lw	s1,20(sp)
9d001d84:	8fb00010 	lw	s0,16(sp)
9d001d88:	03e00008 	jr	ra
9d001d8c:	27bd0020 	addiu	sp,sp,32
    // then create a Client in the list with this handle
    if(ChipKITValidTCPHandle(sklListening.hTCP) && ChipKITClientConnected(sklListening.hTCP))
    {  
        SKL *   psklFirst = sklListening.psklNext;

        TCP_SOCKET hTCP = ChipKITServerListenPORT(_port);  // immediately start listening on another socket
9d001d90:	00002021 	move	a0,zero
9d001d94:	00002821 	move	a1,zero
9d001d98:	24070001 	li	a3,1
9d001d9c:	0f4008c8 	jal	9d002320 <ChipKITClientConnect>
9d001da0:	8e110010 	lw	s1,16(s0)
        
        // Now create and entry for the connected socket
        sklListening.psklNext = (SKL *) malloc(sizeof(SKL));
9d001da4:	2404000c 	li	a0,12
9d001da8:	0f402e0d 	jal	9d00b834 <malloc>
9d001dac:	00409021 	move	s2,v0
        sklListening.psklNext->hTCP = sklListening.hTCP;
9d001db0:	92040008 	lbu	a0,8(s0)
        sklListening.hTCP = hTCP;  // put the new listening socket in the listing skl      
   
        // and put it at the front of the list
        sklListening.psklNext->psklNext = psklFirst;    // the old first client in the list after this new one
        sklListening.psklNext->psklBack = &sklListening;  // point back to the dummy false client
9d001db4:	26030008 	addiu	v1,s0,8
        SKL *   psklFirst = sklListening.psklNext;

        TCP_SOCKET hTCP = ChipKITServerListenPORT(_port);  // immediately start listening on another socket
        
        // Now create and entry for the connected socket
        sklListening.psklNext = (SKL *) malloc(sizeof(SKL));
9d001db8:	ae020010 	sw	v0,16(s0)
        sklListening.psklNext->hTCP = sklListening.hTCP;
9d001dbc:	a0440000 	sb	a0,0(v0)
        sklListening.hTCP = hTCP;  // put the new listening socket in the listing skl      
   
        // and put it at the front of the list
        sklListening.psklNext->psklNext = psklFirst;    // the old first client in the list after this new one
9d001dc0:	ac510008 	sw	s1,8(v0)
        TCP_SOCKET hTCP = ChipKITServerListenPORT(_port);  // immediately start listening on another socket
        
        // Now create and entry for the connected socket
        sklListening.psklNext = (SKL *) malloc(sizeof(SKL));
        sklListening.psklNext->hTCP = sklListening.hTCP;
        sklListening.hTCP = hTCP;  // put the new listening socket in the listing skl      
9d001dc4:	a2120008 	sb	s2,8(s0)
        // and put it at the front of the list
        sklListening.psklNext->psklNext = psklFirst;    // the old first client in the list after this new one
        sklListening.psklNext->psklBack = &sklListening;  // point back to the dummy false client

        // fix the back point if any to the newly created client
        if(psklFirst != NULL)
9d001dc8:	1220ffd6 	beqz	s1,9d001d24 <_ZN6Server19ServiceSocketListenEv+0x48>
9d001dcc:	ac430004 	sw	v1,4(v0)
        {
            psklFirst->psklBack = sklListening.psklNext;
9d001dd0:	0b400749 	j	9d001d24 <_ZN6Server19ServiceSocketListenEv+0x48>
9d001dd4:	ae220004 	sw	v0,4(s1)

9d001dd8 <_ZN6Server9availableEv>:
*/
Client Server::available()
{
    // just an empty client with an invalid socket
    // static only because we want to construct it once.
    static Client ClientFail;  
9d001dd8:	83828050 	lb	v0,-32688(gp)
**
**      Same as defined by http://arduino.cc/en/Reference/ServerAvailable
**      
*/
Client Server::available()
{
9d001ddc:	27bdffc0 	addiu	sp,sp,-64
9d001de0:	afb00034 	sw	s0,52(sp)
9d001de4:	afbf003c 	sw	ra,60(sp)
9d001de8:	afb10038 	sw	s1,56(sp)
    // just an empty client with an invalid socket
    // static only because we want to construct it once.
    static Client ClientFail;  
9d001dec:	10400027 	beqz	v0,9d001e8c <_ZN6Server9availableEv+0xb4>
9d001df0:	00808021 	move	s0,a0
    SKL * psklNow = NULL; 

    // Process the list for only valid sockets
    // this could mess with our client list, so wait to
    // after this to set psklNow.
    ServiceSocketListen();
9d001df4:	00a02021 	move	a0,a1
9d001df8:	0f400737 	jal	9d001cdc <_ZN6Server19ServiceSocketListenEv>
9d001dfc:	afa50028 	sw	a1,40(sp)

    // go through the list and see if there is any data to read
    // remember the Fist is a false client, we know not to start there.
    psklNow = sklListening.psklNext; 
9d001e00:	8fa50028 	lw	a1,40(sp)
9d001e04:	8cb10010 	lw	s1,16(a1)
    while(psklNow != NULL)
9d001e08:	16200005 	bnez	s1,9d001e20 <_ZN6Server9availableEv+0x48>
9d001e0c:	3c05a000 	lui	a1,0xa000
        psklNow = psklNow->psklNext;
    }

    // nothing found with bytes to read
    // this is our false client
    return(ClientFail);
9d001e10:	0b40079b 	j	9d001e6c <_ZN6Server9availableEv+0x94>
9d001e14:	02002021 	move	a0,s0
    ServiceSocketListen();

    // go through the list and see if there is any data to read
    // remember the Fist is a false client, we know not to start there.
    psklNow = sklListening.psklNext; 
    while(psklNow != NULL)
9d001e18:	12200013 	beqz	s1,9d001e68 <_ZN6Server9availableEv+0x90>
9d001e1c:	3c05a000 	lui	a1,0xa000
    {
        // if we find someone with some available bytes to read, return the client.
        if(ChipKITClientAvailable(psklNow->hTCP) > 0)
9d001e20:	0f400908 	jal	9d002420 <ChipKITClientAvailable>
9d001e24:	92240000 	lbu	a0,0(s1)
9d001e28:	5040fffb 	beqzl	v0,9d001e18 <_ZN6Server9availableEv+0x40>
9d001e2c:	8e310008 	lw	s1,8(s1)
        {
            Client clientActive(psklNow->hTCP);
9d001e30:	92250000 	lbu	a1,0(s1)
9d001e34:	0f400637 	jal	9d0018dc <_ZN6ClientC1Eh>
9d001e38:	27a40010 	addiu	a0,sp,16
            return(clientActive);
9d001e3c:	02002021 	move	a0,s0
9d001e40:	0f40067d 	jal	9d0019f4 <_ZN6ClientC1ERKS_>
9d001e44:	27a50010 	addiu	a1,sp,16
    while(psklNow != NULL)
    {
        // if we find someone with some available bytes to read, return the client.
        if(ChipKITClientAvailable(psklNow->hTCP) > 0)
        {
            Client clientActive(psklNow->hTCP);
9d001e48:	0f400654 	jal	9d001950 <_ZN6ClientD1Ev>
9d001e4c:	27a40010 	addiu	a0,sp,16
    }

    // nothing found with bytes to read
    // this is our false client
    return(ClientFail);
}
9d001e50:	8fbf003c 	lw	ra,60(sp)
9d001e54:	02001021 	move	v0,s0
9d001e58:	8fb10038 	lw	s1,56(sp)
9d001e5c:	8fb00034 	lw	s0,52(sp)
9d001e60:	03e00008 	jr	ra
9d001e64:	27bd0040 	addiu	sp,sp,64
        psklNow = psklNow->psklNext;
    }

    // nothing found with bytes to read
    // this is our false client
    return(ClientFail);
9d001e68:	02002021 	move	a0,s0
9d001e6c:	0f40067d 	jal	9d0019f4 <_ZN6ClientC1ERKS_>
9d001e70:	24a50ab0 	addiu	a1,a1,2736
}
9d001e74:	8fbf003c 	lw	ra,60(sp)
9d001e78:	02001021 	move	v0,s0
9d001e7c:	8fb10038 	lw	s1,56(sp)
9d001e80:	8fb00034 	lw	s0,52(sp)
9d001e84:	03e00008 	jr	ra
9d001e88:	27bd0040 	addiu	sp,sp,64
*/
Client Server::available()
{
    // just an empty client with an invalid socket
    // static only because we want to construct it once.
    static Client ClientFail;  
9d001e8c:	27848050 	addiu	a0,gp,-32688
9d001e90:	0f40314b 	jal	9d00c52c <__cxa_guard_acquire>
9d001e94:	afa50028 	sw	a1,40(sp)
9d001e98:	1040ffd6 	beqz	v0,9d001df4 <_ZN6Server9availableEv+0x1c>
9d001e9c:	8fa50028 	lw	a1,40(sp)
9d001ea0:	3c04a000 	lui	a0,0xa000
9d001ea4:	0f40062c 	jal	9d0018b0 <_ZN6ClientC1Ev>
9d001ea8:	24840ab0 	addiu	a0,a0,2736
9d001eac:	0f403155 	jal	9d00c554 <__cxa_guard_release>
9d001eb0:	27848050 	addiu	a0,gp,-32688
9d001eb4:	3c049d00 	lui	a0,0x9d00
9d001eb8:	0f402dcf 	jal	9d00b73c <atexit>
9d001ebc:	24841bcc 	addiu	a0,a0,7116
9d001ec0:	0b40077d 	j	9d001df4 <_ZN6Server9availableEv+0x1c>
9d001ec4:	8fa50028 	lw	a1,40(sp)

9d001ec8 <_general_exception_handler>:
static void InitAppConfig(void);
static void InitializeBoard(void);
	
	void _general_exception_handler(unsigned cause, unsigned status)
	{
		Nop();
9d001ec8:	00000040 	ssnop
		Nop();
9d001ecc:	00000040 	ssnop
	}
9d001ed0:	03e00008 	jr	ra
9d001ed4:	00000000 	nop

9d001ed8 <ChipKITPeriodicTasks>:
	implicitly so that it is called at the right time to execution the stack
	functions. But this routine is made available to the sketch so that the
	sketch can keep the stack alive while the sketch is idle.
  ***************************************************************************/
void ChipKITPeriodicTasks(void)
{
9d001ed8:	27bdffc8 	addiu	sp,sp,-56
9d001edc:	afb3001c 	sw	s3,28(sp)
9d001ee0:	afb10014 	sw	s1,20(sp)
   	// This task performs normal stack task including checking
   	// for incoming packet, type of packet and calling
    // appropriate stack entity to process it.
    StackTask();
9d001ee4:	3c13a000 	lui	s3,0xa000
9d001ee8:	3c11a001 	lui	s1,0xa001
	implicitly so that it is called at the right time to execution the stack
	functions. But this routine is made available to the sketch so that the
	sketch can keep the stack alive while the sketch is idle.
  ***************************************************************************/
void ChipKITPeriodicTasks(void)
{
9d001eec:	afb50024 	sw	s5,36(sp)
9d001ef0:	afb40020 	sw	s4,32(sp)
9d001ef4:	afb20018 	sw	s2,24(sp)
9d001ef8:	afb00010 	sw	s0,16(sp)
9d001efc:	afbf0034 	sw	ra,52(sp)
9d001f00:	afbe0030 	sw	s8,48(sp)
9d001f04:	afb7002c 	sw	s7,44(sp)
9d001f08:	afb60028 	sw	s6,40(sp)
   	// This task performs normal stack task including checking
   	// for incoming packet, type of packet and calling
    // appropriate stack entity to process it.
    StackTask();
9d001f0c:	0f400bba 	jal	9d002ee8 <StackTask>
9d001f10:	26730ac8 	addiu	s3,s3,2760
9d001f14:	26319a9c 	addiu	s1,s1,-25956
9d001f18:	00009021 	move	s2,zero
	WORD	cbCopy = 0;
	WORD	iWrite = 0;

	while(cbWrite > 0)
	{
		cbCopy = sizeof(pUDPSB->rgbBuffer) - pUDPSB->iEnd;
9d001f1c:	24100600 	li	s0,1536
	// if we have a buffer overrun, then set the available count
	// to the max size of the buffer.
	pUDPSB->cbAvailable += iWrite;
	if(pUDPSB->cbAvailable > sizeof(pUDPSB->rgbBuffer))
	{
		pUDPSB->cbAvailable = sizeof(pUDPSB->rgbBuffer);
9d001f20:	24150600 	li	s5,1536
	UDP_SOCKET hUDP;
	WORD cbReady = 0;
	UDPSB * pUDPSB = NULL;
	UDP_SOCKET_INFO * pSocketInfo = NULL;

	for(hUDP = 0; hUDP < MAX_UDP_SOCKETS; hUDP++)
9d001f24:	2414000a 	li	s4,10
	{
		if((pUDPSB = rgUDPSocketBuffers[hUDP]) != NULL)
9d001f28:	8e760000 	lw	s6,0(s3)
9d001f2c:	52c0002e 	beqzl	s6,9d001fe8 <ChipKITPeriodicTasks+0x110>
9d001f30:	26520001 	addiu	s2,s2,1
		{
			if((cbReady = UDPIsGetReady(hUDP)) > 0)
9d001f34:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d001f38:	02402021 	move	a0,s2
9d001f3c:	10400029 	beqz	v0,9d001fe4 <ChipKITPeriodicTasks+0x10c>
9d001f40:	0040b821 	move	s7,v0
9d001f44:	0000f021 	move	s8,zero
	WORD	cbCopy = 0;
	WORD	iWrite = 0;

	while(cbWrite > 0)
	{
		cbCopy = sizeof(pUDPSB->rgbBuffer) - pUDPSB->iEnd;
9d001f48:	96c40000 	lhu	a0,0(s6)
		cbCopy = cbCopy < cbWrite ? cbCopy : cbWrite;
9d001f4c:	02e02821 	move	a1,s7
9d001f50:	02041023 	subu	v0,s0,a0
9d001f54:	3042ffff 	andi	v0,v0,0xffff
9d001f58:	0057182b 	sltu	v1,v0,s7
		cbCopy = UDPGetArray(&pUDPSB->rgbBuffer[pUDPSB->iEnd], cbCopy);
9d001f5c:	24840010 	addiu	a0,a0,16
9d001f60:	0043280b 	movn	a1,v0,v1
9d001f64:	0f401313 	jal	9d004c4c <UDPGetArray>
9d001f68:	02c42021 	addu	a0,s6,a0
		iWrite += cbCopy;
		pUDPSB->iEnd += cbCopy;
9d001f6c:	96c30000 	lhu	v1,0(s6)
	while(cbWrite > 0)
	{
		cbCopy = sizeof(pUDPSB->rgbBuffer) - pUDPSB->iEnd;
		cbCopy = cbCopy < cbWrite ? cbCopy : cbWrite;
		cbCopy = UDPGetArray(&pUDPSB->rgbBuffer[pUDPSB->iEnd], cbCopy);
		iWrite += cbCopy;
9d001f70:	005ef021 	addu	s8,v0,s8
		pUDPSB->iEnd += cbCopy;
		cbWrite -= cbCopy;
9d001f74:	02e2b823 	subu	s7,s7,v0
	{
		cbCopy = sizeof(pUDPSB->rgbBuffer) - pUDPSB->iEnd;
		cbCopy = cbCopy < cbWrite ? cbCopy : cbWrite;
		cbCopy = UDPGetArray(&pUDPSB->rgbBuffer[pUDPSB->iEnd], cbCopy);
		iWrite += cbCopy;
		pUDPSB->iEnd += cbCopy;
9d001f78:	00431021 	addu	v0,v0,v1
9d001f7c:	3042ffff 	andi	v0,v0,0xffff
9d001f80:	a6c20000 	sh	v0,0(s6)
		cbWrite -= cbCopy;
9d001f84:	32f7ffff 	andi	s7,s7,0xffff
		
		// run to the front of the bufer if we used it all up
		if(pUDPSB->iEnd == sizeof(pUDPSB->rgbBuffer))
9d001f88:	10500026 	beq	v0,s0,9d002024 <ChipKITPeriodicTasks+0x14c>
9d001f8c:	33deffff 	andi	s8,s8,0xffff
static WORD UDPSBWrite(UDPSB * pUDPSB, WORD cbWrite)
{
	WORD	cbCopy = 0;
	WORD	iWrite = 0;

	while(cbWrite > 0)
9d001f90:	56e0ffee 	bnezl	s7,9d001f4c <ChipKITPeriodicTasks+0x74>
9d001f94:	96c40000 	lhu	a0,0(s6)
		}	
	}

	// if we have a buffer overrun, then set the available count
	// to the max size of the buffer.
	pUDPSB->cbAvailable += iWrite;
9d001f98:	96c20002 	lhu	v0,2(s6)
9d001f9c:	03c2f021 	addu	s8,s8,v0
9d001fa0:	33deffff 	andi	s8,s8,0xffff
	if(pUDPSB->cbAvailable > sizeof(pUDPSB->rgbBuffer))
9d001fa4:	2fc20601 	sltiu	v0,s8,1537
9d001fa8:	14400002 	bnez	v0,9d001fb4 <ChipKITPeriodicTasks+0xdc>
9d001fac:	a6de0002 	sh	s8,2(s6)
	{
		pUDPSB->cbAvailable = sizeof(pUDPSB->rgbBuffer);
9d001fb0:	a6d50002 	sh	s5,2(s6)
		{
			if((cbReady = UDPIsGetReady(hUDP)) > 0)
			{
				UDPSBWrite(pUDPSB, cbReady);
				pSocketInfo = PUDPSocketInfoFromUDPSocket(hUDP);
				pUDPSB->remoteNodeInfo = pSocketInfo->remoteNode;
9d001fb4:	96270000 	lhu	a3,0(s1)
9d001fb8:	96260002 	lhu	a2,2(s1)
9d001fbc:	96250004 	lhu	a1,4(s1)
9d001fc0:	96240006 	lhu	a0,6(s1)
9d001fc4:	96230008 	lhu	v1,8(s1)
				pUDPSB->remotePort = pSocketInfo->remotePort;;
9d001fc8:	9622000a 	lhu	v0,10(s1)
		{
			if((cbReady = UDPIsGetReady(hUDP)) > 0)
			{
				UDPSBWrite(pUDPSB, cbReady);
				pSocketInfo = PUDPSocketInfoFromUDPSocket(hUDP);
				pUDPSB->remoteNodeInfo = pSocketInfo->remoteNode;
9d001fcc:	a6c70004 	sh	a3,4(s6)
9d001fd0:	a6c60006 	sh	a2,6(s6)
9d001fd4:	a6c50008 	sh	a1,8(s6)
9d001fd8:	a6c4000a 	sh	a0,10(s6)
9d001fdc:	a6c3000c 	sh	v1,12(s6)
				pUDPSB->remotePort = pSocketInfo->remotePort;;
9d001fe0:	a6c2000e 	sh	v0,14(s6)
9d001fe4:	26520001 	addiu	s2,s2,1
9d001fe8:	26730004 	addiu	s3,s3,4
	UDP_SOCKET hUDP;
	WORD cbReady = 0;
	UDPSB * pUDPSB = NULL;
	UDP_SOCKET_INFO * pSocketInfo = NULL;

	for(hUDP = 0; hUDP < MAX_UDP_SOCKETS; hUDP++)
9d001fec:	1654ffce 	bne	s2,s4,9d001f28 <ChipKITPeriodicTasks+0x50>
9d001ff0:	2631000e 	addiu	s1,s1,14
    // buffer the UDP data so we don't lose it.
	ChipKITUDPUpdateBufferCache();

    // This tasks invokes each of the core stack application tasks
    StackApplications();
}
9d001ff4:	8fbf0034 	lw	ra,52(sp)
9d001ff8:	8fbe0030 	lw	s8,48(sp)
9d001ffc:	8fb7002c 	lw	s7,44(sp)
9d002000:	8fb60028 	lw	s6,40(sp)
9d002004:	8fb50024 	lw	s5,36(sp)
9d002008:	8fb40020 	lw	s4,32(sp)
9d00200c:	8fb3001c 	lw	s3,28(sp)
9d002010:	8fb20018 	lw	s2,24(sp)
9d002014:	8fb10014 	lw	s1,20(sp)
9d002018:	8fb00010 	lw	s0,16(sp)
    // UDP buffer for another iteration of StackTask, so we must
    // buffer the UDP data so we don't lose it.
	ChipKITUDPUpdateBufferCache();

    // This tasks invokes each of the core stack application tasks
    StackApplications();
9d00201c:	0b400c30 	j	9d0030c0 <StackApplications>
9d002020:	27bd0038 	addiu	sp,sp,56
static WORD UDPSBWrite(UDPSB * pUDPSB, WORD cbWrite)
{
	WORD	cbCopy = 0;
	WORD	iWrite = 0;

	while(cbWrite > 0)
9d002024:	16e0ffc8 	bnez	s7,9d001f48 <ChipKITPeriodicTasks+0x70>
9d002028:	a6c00000 	sh	zero,0(s6)
		}	
	}

	// if we have a buffer overrun, then set the available count
	// to the max size of the buffer.
	pUDPSB->cbAvailable += iWrite;
9d00202c:	0b4007e7 	j	9d001f9c <ChipKITPeriodicTasks+0xc4>
9d002030:	96c20002 	lhu	v0,2(s6)

9d002034 <ChipKITEthernetBegin>:
  Remarks:
    None
  ***************************************************************************/
static void InitializeBoard(void)
{	
	TRISEbits.TRISE9 = 0;   // output phy enable SMSC8720, data part of the NIC
9d002034:	3c03bf88 	lui	v1,0xbf88
9d002038:	8c686100 	lw	t0,24832(v1)
	LATEbits.LATE9 = 1; 	// high, enable the phy
9d00203c:	3c02bf88 	lui	v0,0xbf88

  Remarks:
    None
  ***************************************************************************/
void ChipKITEthernetBegin(const BYTE *rgbMac, const BYTE *rgbIP, const BYTE *rgbGateWay, const BYTE *rgbSubNet, const BYTE *rgbDNS1, const BYTE *rgbDNS2)
{
9d002040:	27bdffc8 	addiu	sp,sp,-56
  Remarks:
    None
  ***************************************************************************/
static void InitializeBoard(void)
{	
	TRISEbits.TRISE9 = 0;   // output phy enable SMSC8720, data part of the NIC
9d002044:	7c084a44 	ins	t0,zero,0x9,0x1
9d002048:	ac686100 	sw	t0,24832(v1)
	LATEbits.LATE9 = 1; 	// high, enable the phy
9d00204c:	8c436120 	lw	v1,24864(v0)

  Remarks:
    None
  ***************************************************************************/
void ChipKITEthernetBegin(const BYTE *rgbMac, const BYTE *rgbIP, const BYTE *rgbGateWay, const BYTE *rgbSubNet, const BYTE *rgbDNS1, const BYTE *rgbDNS2)
{
9d002050:	afb30028 	sw	s3,40(sp)
9d002054:	00809821 	move	s3,a0
    None
  ***************************************************************************/
static void InitializeBoard(void)
{	
	TRISEbits.TRISE9 = 0;   // output phy enable SMSC8720, data part of the NIC
	LATEbits.LATE9 = 1; 	// high, enable the phy
9d002058:	24040001 	li	a0,1
9d00205c:	7c834a44 	ins	v1,a0,0x9,0x1
	// Initialize application specific hardware
	InitializeBoard();

	// Initialize stack-related hardware components that may be 
	// required by the UART configuration routines
    TickInit();
9d002060:	afa60010 	sw	a2,16(sp)
9d002064:	afa70014 	sw	a3,20(sp)

  Remarks:
    None
  ***************************************************************************/
void ChipKITEthernetBegin(const BYTE *rgbMac, const BYTE *rgbIP, const BYTE *rgbGateWay, const BYTE *rgbSubNet, const BYTE *rgbDNS1, const BYTE *rgbDNS2)
{
9d002068:	afbf0034 	sw	ra,52(sp)
    None
  ***************************************************************************/
static void InitializeBoard(void)
{	
	TRISEbits.TRISE9 = 0;   // output phy enable SMSC8720, data part of the NIC
	LATEbits.LATE9 = 1; 	// high, enable the phy
9d00206c:	ac436120 	sw	v1,24864(v0)

  Remarks:
    None
  ***************************************************************************/
void ChipKITEthernetBegin(const BYTE *rgbMac, const BYTE *rgbIP, const BYTE *rgbGateWay, const BYTE *rgbSubNet, const BYTE *rgbDNS1, const BYTE *rgbDNS2)
{
9d002070:	afb50030 	sw	s5,48(sp)
9d002074:	afb4002c 	sw	s4,44(sp)
9d002078:	afb20024 	sw	s2,36(sp)
9d00207c:	afb10020 	sw	s1,32(sp)
9d002080:	afb0001c 	sw	s0,28(sp)
9d002084:	00a0a021 	move	s4,a1
9d002088:	8fb20048 	lw	s2,72(sp)
	// Initialize application specific hardware
	InitializeBoard();

	// Initialize stack-related hardware components that may be 
	// required by the UART configuration routines
    TickInit();
9d00208c:	0f400b39 	jal	9d002ce4 <TickInit>
9d002090:	8fb1004c 	lw	s1,76(sp)
		AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2<<8ul  | MY_DEFAULT_PRIMARY_DNS_BYTE3<<16ul  | MY_DEFAULT_PRIMARY_DNS_BYTE4<<24ul;
		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
	
	
		// Load the default NetBIOS Host Name
		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
9d002094:	3c049d01 	lui	a0,0x9d01
9d002098:	2482dbd8 	addiu	v0,a0,-9256
9d00209c:	88490003 	lwl	t1,3(v0)
9d0020a0:	88480007 	lwl	t0,7(v0)
9d0020a4:	8845000b 	lwl	a1,11(v0)
9d0020a8:	8843000f 	lwl	v1,15(v0)
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
		
		AppConfig.Flags.bIsDHCPEnabled = TRUE;
		AppConfig.Flags.bInConfigMode = TRUE;
		memcpypgm2ram((void*)&AppConfig.MyMACAddr, (ROM void*)SerializedMACAddress, sizeof(AppConfig.MyMACAddr));
9d0020ac:	3c0a9d01 	lui	t2,0x9d01
9d0020b0:	8d4bdbe0 	lw	t3,-9248(t2)
	
	while(1)
	{
		// Start out zeroing all AppConfig bytes to ensure all fields are 
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
9d0020b4:	3c15a001 	lui	s5,0xa001
		
		AppConfig.Flags.bIsDHCPEnabled = TRUE;
		AppConfig.Flags.bInConfigMode = TRUE;
		memcpypgm2ram((void*)&AppConfig.MyMACAddr, (ROM void*)SerializedMACAddress, sizeof(AppConfig.MyMACAddr));
9d0020b8:	254adbe0 	addiu	t2,t2,-9248
	
	while(1)
	{
		// Start out zeroing all AppConfig bytes to ensure all fields are 
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
9d0020bc:	26b09a5c 	addiu	s0,s5,-26020
		AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2<<8ul  | MY_DEFAULT_PRIMARY_DNS_BYTE3<<16ul  | MY_DEFAULT_PRIMARY_DNS_BYTE4<<24ul;
		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
	
	
		// Load the default NetBIOS Host Name
		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
9d0020c0:	9843000c 	lwr	v1,12(v0)
9d0020c4:	98480004 	lwr	t0,4(v0)
9d0020c8:	98450008 	lwr	a1,8(v0)
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
		
		AppConfig.Flags.bIsDHCPEnabled = TRUE;
		AppConfig.Flags.bInConfigMode = TRUE;
		memcpypgm2ram((void*)&AppConfig.MyMACAddr, (ROM void*)SerializedMACAddress, sizeof(AppConfig.MyMACAddr));
9d0020cc:	914d0004 	lbu	t5,4(t2)
9d0020d0:	914c0005 	lbu	t4,5(t2)
		AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2<<8ul  | MY_DEFAULT_PRIMARY_DNS_BYTE3<<16ul  | MY_DEFAULT_PRIMARY_DNS_BYTE4<<24ul;
		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
	
	
		// Load the default NetBIOS Host Name
		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
9d0020d4:	9889dbd8 	lwr	t1,-9256(a0)
		// Start out zeroing all AppConfig bytes to ensure all fields are 
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
		
		AppConfig.Flags.bIsDHCPEnabled = TRUE;
		AppConfig.Flags.bInConfigMode = TRUE;
9d0020d8:	240400c0 	li	a0,192
	
	while(1)
	{
		// Start out zeroing all AppConfig bytes to ensure all fields are 
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
9d0020dc:	aea09a5c 	sw	zero,-26020(s5)
//		{
//			_prog_addressT MACAddressAddress;
//			MACAddressAddress.next = 0x157F8;
//			_memcpy_p2d24((char*)&AppConfig.MyMACAddr, MACAddressAddress, sizeof(AppConfig.MyMACAddr));
//		}
		AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2<<8ul | MY_DEFAULT_IP_ADDR_BYTE3<<16ul | MY_DEFAULT_IP_ADDR_BYTE4<<24ul;
9d0020e0:	3c020101 	lui	v0,0x101
		// Start out zeroing all AppConfig bytes to ensure all fields are 
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
		
		AppConfig.Flags.bIsDHCPEnabled = TRUE;
		AppConfig.Flags.bInConfigMode = TRUE;
9d0020e4:	ae04002c 	sw	a0,44(s0)
		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
	
	
		// Load the default NetBIOS Host Name
		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
		FormatNetBIOSName(AppConfig.NetBIOSName);
9d0020e8:	3c04a001 	lui	a0,0xa001
//		{
//			_prog_addressT MACAddressAddress;
//			MACAddressAddress.next = 0x157F8;
//			_memcpy_p2d24((char*)&AppConfig.MyMACAddr, MACAddressAddress, sizeof(AppConfig.MyMACAddr));
//		}
		AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2<<8ul | MY_DEFAULT_IP_ADDR_BYTE3<<16ul | MY_DEFAULT_IP_ADDR_BYTE4<<24ul;
9d0020ec:	3442fea9 	ori	v0,v0,0xfea9
		AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
		AppConfig.MyMask.Val = MY_DEFAULT_MASK_BYTE1 | MY_DEFAULT_MASK_BYTE2<<8ul | MY_DEFAULT_MASK_BYTE3<<16ul | MY_DEFAULT_MASK_BYTE4<<24ul;
9d0020f0:	340affff 	li	t2,0xffff
		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
	
	
		// Load the default NetBIOS Host Name
		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
		FormatNetBIOSName(AppConfig.NetBIOSName);
9d0020f4:	24849a78 	addiu	a0,a0,-25992
	
	while(1)
	{
		// Start out zeroing all AppConfig bytes to ensure all fields are 
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
9d0020f8:	a6000030 	sh	zero,48(s0)
9d0020fc:	ae000004 	sw	zero,4(s0)
9d002100:	ae000008 	sw	zero,8(s0)
9d002104:	ae00000c 	sw	zero,12(s0)
9d002108:	ae000014 	sw	zero,20(s0)
9d00210c:	ae000018 	sw	zero,24(s0)
9d002110:	a2000032 	sb	zero,50(s0)
9d002114:	ae000010 	sw	zero,16(s0)
9d002118:	ae00001c 	sw	zero,28(s0)
9d00211c:	ae000020 	sw	zero,32(s0)
9d002120:	ae000024 	sw	zero,36(s0)
9d002124:	ae000028 	sw	zero,40(s0)
		
		AppConfig.Flags.bIsDHCPEnabled = TRUE;
		AppConfig.Flags.bInConfigMode = TRUE;
		memcpypgm2ram((void*)&AppConfig.MyMACAddr, (ROM void*)SerializedMACAddress, sizeof(AppConfig.MyMACAddr));
9d002128:	aa0b0030 	swl	t3,48(s0)
9d00212c:	ba0b002d 	swr	t3,45(s0)
//		{
//			_prog_addressT MACAddressAddress;
//			MACAddressAddress.next = 0x157F8;
//			_memcpy_p2d24((char*)&AppConfig.MyMACAddr, MACAddressAddress, sizeof(AppConfig.MyMACAddr));
//		}
		AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2<<8ul | MY_DEFAULT_IP_ADDR_BYTE3<<16ul | MY_DEFAULT_IP_ADDR_BYTE4<<24ul;
9d002130:	aea29a5c 	sw	v0,-26020(s5)
		AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2<<8ul  | MY_DEFAULT_PRIMARY_DNS_BYTE3<<16ul  | MY_DEFAULT_PRIMARY_DNS_BYTE4<<24ul;
		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
	
	
		// Load the default NetBIOS Host Name
		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
9d002134:	ae030028 	sw	v1,40(s0)
		// deterministic for checksum generation
		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
		
		AppConfig.Flags.bIsDHCPEnabled = TRUE;
		AppConfig.Flags.bInConfigMode = TRUE;
		memcpypgm2ram((void*)&AppConfig.MyMACAddr, (ROM void*)SerializedMACAddress, sizeof(AppConfig.MyMACAddr));
9d002138:	a20d0031 	sb	t5,49(s0)
9d00213c:	a20c0032 	sb	t4,50(s0)
//			_prog_addressT MACAddressAddress;
//			MACAddressAddress.next = 0x157F8;
//			_memcpy_p2d24((char*)&AppConfig.MyMACAddr, MACAddressAddress, sizeof(AppConfig.MyMACAddr));
//		}
		AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2<<8ul | MY_DEFAULT_IP_ADDR_BYTE3<<16ul | MY_DEFAULT_IP_ADDR_BYTE4<<24ul;
		AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
9d002140:	ae020014 	sw	v0,20(s0)
		AppConfig.MyMask.Val = MY_DEFAULT_MASK_BYTE1 | MY_DEFAULT_MASK_BYTE2<<8ul | MY_DEFAULT_MASK_BYTE3<<16ul | MY_DEFAULT_MASK_BYTE4<<24ul;
9d002144:	ae0a0004 	sw	t2,4(s0)
		AppConfig.DefaultMask.Val = AppConfig.MyMask.Val;
9d002148:	ae0a0018 	sw	t2,24(s0)
		AppConfig.MyGateway.Val = MY_DEFAULT_GATE_BYTE1 | MY_DEFAULT_GATE_BYTE2<<8ul | MY_DEFAULT_GATE_BYTE3<<16ul | MY_DEFAULT_GATE_BYTE4<<24ul;
9d00214c:	ae020008 	sw	v0,8(s0)
		AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2<<8ul  | MY_DEFAULT_PRIMARY_DNS_BYTE3<<16ul  | MY_DEFAULT_PRIMARY_DNS_BYTE4<<24ul;
9d002150:	ae02000c 	sw	v0,12(s0)
		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
	
	
		// Load the default NetBIOS Host Name
		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
9d002154:	ae09001c 	sw	t1,28(s0)
9d002158:	ae080020 	sw	t0,32(s0)
		FormatNetBIOSName(AppConfig.NetBIOSName);
9d00215c:	0f40263a 	jal	9d0098e8 <FormatNetBIOSName>
9d002160:	ae050024 	sw	a1,36(s0)

		// Compute the checksum of the AppConfig defaults as loaded from ROM
		wOriginalAppConfigChecksum = CalcIPChecksum((BYTE*)&AppConfig, sizeof(AppConfig));
9d002164:	02002021 	move	a0,s0
9d002168:	0f40261b 	jal	9d00986c <CalcIPChecksum>
9d00216c:	24050033 	li	a1,51
9d002170:	a7828058 	sh	v0,-32680(gp)

	// Initialize Stack and application related NV variables into AppConfig.
	InitAppConfig();

	// see if we have something other than to use our MAC address
	if((rgbMac[0] | rgbMac[1] | rgbMac[2] | rgbMac[3] | rgbMac[4] | rgbMac[5]) != 0)
9d002174:	92640001 	lbu	a0,1(s3)
9d002178:	92620002 	lbu	v0,2(s3)
9d00217c:	92630000 	lbu	v1,0(s3)
9d002180:	92650003 	lbu	a1,3(s3)
9d002184:	00821025 	or	v0,a0,v0
9d002188:	92640004 	lbu	a0,4(s3)
9d00218c:	00431025 	or	v0,v0,v1
9d002190:	92630005 	lbu	v1,5(s3)
9d002194:	00451025 	or	v0,v0,a1
9d002198:	00441025 	or	v0,v0,a0
9d00219c:	00431025 	or	v0,v0,v1
9d0021a0:	304200ff 	andi	v0,v0,0xff
9d0021a4:	8fa60010 	lw	a2,16(sp)
9d0021a8:	10400009 	beqz	v0,9d0021d0 <ChipKITEthernetBegin+0x19c>
9d0021ac:	8fa70014 	lw	a3,20(sp)
	{
		memcpy(&AppConfig.MyMACAddr, rgbMac, 6);
9d0021b0:	8a620003 	lwl	v0,3(s3)
9d0021b4:	9a620000 	lwr	v0,0(s3)
9d0021b8:	aa020030 	swl	v0,48(s0)
9d0021bc:	ba02002d 	swr	v0,45(s0)
9d0021c0:	92620004 	lbu	v0,4(s3)
9d0021c4:	a2020031 	sb	v0,49(s0)
9d0021c8:	92620005 	lbu	v0,5(s3)
9d0021cc:	a2020032 	sb	v0,50(s0)
	}

	// if we are not to use DHCP; fill in what came in.
	if((rgbIP[0] | rgbIP[1] | rgbIP[2] | rgbIP[3]) != 0)
9d0021d0:	92850001 	lbu	a1,1(s4)
9d0021d4:	92820002 	lbu	v0,2(s4)
9d0021d8:	92840000 	lbu	a0,0(s4)
9d0021dc:	92830003 	lbu	v1,3(s4)
9d0021e0:	00a21025 	or	v0,a1,v0
9d0021e4:	00441025 	or	v0,v0,a0
9d0021e8:	00431025 	or	v0,v0,v1
9d0021ec:	304200ff 	andi	v0,v0,0xff
9d0021f0:	54400032 	bnezl	v0,9d0022bc <ChipKITEthernetBegin+0x288>
9d0021f4:	8e02002c 	lw	v0,44(s0)
		AppConfig.DefaultMask = AppConfig.MyMask;
	}


	// make sure our static array is zeroed out.
	memset(rgUDPSocketBuffers, 0, sizeof(rgUDPSocketBuffers));
9d0021f8:	3c03a000 	lui	v1,0xa000
9d0021fc:	24620ac8 	addiu	v0,v1,2760
9d002200:	ac400004 	sw	zero,4(v0)
9d002204:	ac400008 	sw	zero,8(v0)
9d002208:	ac40000c 	sw	zero,12(v0)
9d00220c:	ac400010 	sw	zero,16(v0)
9d002210:	ac400014 	sw	zero,20(v0)
9d002214:	ac400018 	sw	zero,24(v0)
9d002218:	ac40001c 	sw	zero,28(v0)
9d00221c:	ac400020 	sw	zero,32(v0)
9d002220:	ac400024 	sw	zero,36(v0)

	// Initialize core stack layers (MAC, ARP, TCP, UDP) and
	// application modules (HTTP, SNMP, etc.)
    StackInit();
9d002224:	0f400b97 	jal	9d002e5c <StackInit>
9d002228:	ac600ac8 	sw	zero,2760(v1)

	// arp will not work right until DHCP finishes
	// if DHCP won't configure after the timeout; then just go with it
	// maybe later it will configure, but until then, things might not work right.
	t = TickGet();
9d00222c:	0f400b53 	jal	9d002d4c <TickGet>
9d002230:	00000000 	nop
9d002234:	00408821 	move	s1,v0
	while(AppConfig.Flags.bIsDHCPEnabled && !DHCPIsBound(0) && ((TickGet() - t) < tDHCPTimeout))
9d002238:	9202002c 	lbu	v0,44(s0)
9d00223c:	30420040 	andi	v0,v0,0x40
9d002240:	304200ff 	andi	v0,v0,0xff
9d002244:	10400014 	beqz	v0,9d002298 <ChipKITEthernetBegin+0x264>
9d002248:	3c12008f 	lui	s2,0x8f
9d00224c:	0b4008a2 	j	9d002288 <ChipKITEthernetBegin+0x254>
9d002250:	26520d18 	addiu	s2,s2,3352
9d002254:	0f400b53 	jal	9d002d4c <TickGet>
9d002258:	00000000 	nop
9d00225c:	00511023 	subu	v0,v0,s1
9d002260:	0052102b 	sltu	v0,v0,s2
9d002264:	1040000d 	beqz	v0,9d00229c <ChipKITEthernetBegin+0x268>
9d002268:	8fbf0034 	lw	ra,52(sp)
	{
		ChipKITPeriodicTasks();
9d00226c:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002270:	00000000 	nop

	// arp will not work right until DHCP finishes
	// if DHCP won't configure after the timeout; then just go with it
	// maybe later it will configure, but until then, things might not work right.
	t = TickGet();
	while(AppConfig.Flags.bIsDHCPEnabled && !DHCPIsBound(0) && ((TickGet() - t) < tDHCPTimeout))
9d002274:	9202002c 	lbu	v0,44(s0)
9d002278:	30420040 	andi	v0,v0,0x40
9d00227c:	304200ff 	andi	v0,v0,0xff
9d002280:	10400006 	beqz	v0,9d00229c <ChipKITEthernetBegin+0x268>
9d002284:	8fbf0034 	lw	ra,52(sp)
9d002288:	0f40235a 	jal	9d008d68 <DHCPIsBound>
9d00228c:	00002021 	move	a0,zero
9d002290:	1040fff0 	beqz	v0,9d002254 <ChipKITEthernetBegin+0x220>
9d002294:	00000000 	nop
	{
		ChipKITPeriodicTasks();
	}
}
9d002298:	8fbf0034 	lw	ra,52(sp)
9d00229c:	8fb50030 	lw	s5,48(sp)
9d0022a0:	8fb4002c 	lw	s4,44(sp)
9d0022a4:	8fb30028 	lw	s3,40(sp)
9d0022a8:	8fb20024 	lw	s2,36(sp)
9d0022ac:	8fb10020 	lw	s1,32(sp)
9d0022b0:	8fb0001c 	lw	s0,28(sp)
9d0022b4:	03e00008 	jr	ra
9d0022b8:	27bd0038 	addiu	sp,sp,56
	// if we are not to use DHCP; fill in what came in.
	if((rgbIP[0] | rgbIP[1] | rgbIP[2] | rgbIP[3]) != 0)
	{
		AppConfig.Flags.bIsDHCPEnabled = FALSE;		// don't use dhcp
		memcpy(&AppConfig.MyIPAddr, rgbIP, 4);
		memcpy(&AppConfig.MyGateway, rgbGateWay, 4);
9d0022bc:	3c04a001 	lui	a0,0xa001
		memcpy(&AppConfig.MyMask,rgbSubNet, 4);
		memcpy(&AppConfig.PrimaryDNSServer, rgbDNS1, 4);
9d0022c0:	3c05a001 	lui	a1,0xa001
	}

	// if we are not to use DHCP; fill in what came in.
	if((rgbIP[0] | rgbIP[1] | rgbIP[2] | rgbIP[3]) != 0)
	{
		AppConfig.Flags.bIsDHCPEnabled = FALSE;		// don't use dhcp
9d0022c4:	7c023184 	ins	v0,zero,0x6,0x1
9d0022c8:	ae02002c 	sw	v0,44(s0)
		memcpy(&AppConfig.MyIPAddr, rgbIP, 4);
9d0022cc:	8a820003 	lwl	v0,3(s4)
9d0022d0:	9a820000 	lwr	v0,0(s4)
9d0022d4:	aea29a5c 	sw	v0,-26020(s5)
		memcpy(&AppConfig.MyGateway, rgbGateWay, 4);
9d0022d8:	88c30003 	lwl	v1,3(a2)
9d0022dc:	98c30000 	lwr	v1,0(a2)
9d0022e0:	ac839a64 	sw	v1,-26012(a0)
		memcpy(&AppConfig.MyMask,rgbSubNet, 4);
9d0022e4:	88e30003 	lwl	v1,3(a3)
9d0022e8:	3c04a001 	lui	a0,0xa001
9d0022ec:	98e30000 	lwr	v1,0(a3)
9d0022f0:	ac839a60 	sw	v1,-26016(a0)
		memcpy(&AppConfig.PrimaryDNSServer, rgbDNS1, 4);
9d0022f4:	8a430003 	lwl	v1,3(s2)
		memcpy(&AppConfig.SecondaryDNSServer, rgbDNS2, 4);
		
		AppConfig.DefaultIPAddr = AppConfig.MyIPAddr;
		AppConfig.DefaultMask = AppConfig.MyMask;
9d0022f8:	8e040004 	lw	a0,4(s0)
	{
		AppConfig.Flags.bIsDHCPEnabled = FALSE;		// don't use dhcp
		memcpy(&AppConfig.MyIPAddr, rgbIP, 4);
		memcpy(&AppConfig.MyGateway, rgbGateWay, 4);
		memcpy(&AppConfig.MyMask,rgbSubNet, 4);
		memcpy(&AppConfig.PrimaryDNSServer, rgbDNS1, 4);
9d0022fc:	9a430000 	lwr	v1,0(s2)
9d002300:	aca39a68 	sw	v1,-26008(a1)
		memcpy(&AppConfig.SecondaryDNSServer, rgbDNS2, 4);
9d002304:	8a230003 	lwl	v1,3(s1)
9d002308:	9a230000 	lwr	v1,0(s1)
		
		AppConfig.DefaultIPAddr = AppConfig.MyIPAddr;
9d00230c:	ae020014 	sw	v0,20(s0)
		AppConfig.Flags.bIsDHCPEnabled = FALSE;		// don't use dhcp
		memcpy(&AppConfig.MyIPAddr, rgbIP, 4);
		memcpy(&AppConfig.MyGateway, rgbGateWay, 4);
		memcpy(&AppConfig.MyMask,rgbSubNet, 4);
		memcpy(&AppConfig.PrimaryDNSServer, rgbDNS1, 4);
		memcpy(&AppConfig.SecondaryDNSServer, rgbDNS2, 4);
9d002310:	3c02a001 	lui	v0,0xa001
		
		AppConfig.DefaultIPAddr = AppConfig.MyIPAddr;
		AppConfig.DefaultMask = AppConfig.MyMask;
9d002314:	ae040018 	sw	a0,24(s0)
		AppConfig.Flags.bIsDHCPEnabled = FALSE;		// don't use dhcp
		memcpy(&AppConfig.MyIPAddr, rgbIP, 4);
		memcpy(&AppConfig.MyGateway, rgbGateWay, 4);
		memcpy(&AppConfig.MyMask,rgbSubNet, 4);
		memcpy(&AppConfig.PrimaryDNSServer, rgbDNS1, 4);
		memcpy(&AppConfig.SecondaryDNSServer, rgbDNS2, 4);
9d002318:	0b40087e 	j	9d0021f8 <ChipKITEthernetBegin+0x1c4>
9d00231c:	ac439a6c 	sw	v1,-26004(v0)

9d002320 <ChipKITClientConnect>:
	This routine will attempt to wait until the connection is made for client, but will return immediately for servers as servers
	listen for connections. For the client case, if cSecTimout is exceeded, the connection is close and the socket released back to
	the stack for reuse.
   ***************************************************************************/
TCP_SOCKET ChipKITClientConnect(unsigned int dwOpenVal, BYTE vRemoteHostType, unsigned short wPort, unsigned int cSecTimout)
{
9d002320:	27bdffd8 	addiu	sp,sp,-40
9d002324:	afb20018 	sw	s2,24(sp)
9d002328:	30b200ff 	andi	s2,a1,0xff
9d00232c:	afb00010 	sw	s0,16(sp)
	TCP_SOCKET hTCP = UNKNOWN_SOCKET;
	DWORD t = 0;

	hTCP = TCPOpen((DWORD) dwOpenVal, vRemoteHostType, (WORD) wPort, TCP_PURPOSE_DEFAULT);
9d002330:	02402821 	move	a1,s2
9d002334:	30c6ffff 	andi	a2,a2,0xffff
	This routine will attempt to wait until the connection is made for client, but will return immediately for servers as servers
	listen for connections. For the client case, if cSecTimout is exceeded, the connection is close and the socket released back to
	the stack for reuse.
   ***************************************************************************/
TCP_SOCKET ChipKITClientConnect(unsigned int dwOpenVal, BYTE vRemoteHostType, unsigned short wPort, unsigned int cSecTimout)
{
9d002338:	00e08021 	move	s0,a3
	TCP_SOCKET hTCP = UNKNOWN_SOCKET;
	DWORD t = 0;

	hTCP = TCPOpen((DWORD) dwOpenVal, vRemoteHostType, (WORD) wPort, TCP_PURPOSE_DEFAULT);
9d00233c:	24070009 	li	a3,9
	This routine will attempt to wait until the connection is made for client, but will return immediately for servers as servers
	listen for connections. For the client case, if cSecTimout is exceeded, the connection is close and the socket released back to
	the stack for reuse.
   ***************************************************************************/
TCP_SOCKET ChipKITClientConnect(unsigned int dwOpenVal, BYTE vRemoteHostType, unsigned short wPort, unsigned int cSecTimout)
{
9d002340:	afbf0024 	sw	ra,36(sp)
9d002344:	afb10014 	sw	s1,20(sp)
9d002348:	afb50020 	sw	s5,32(sp)
	TCP_SOCKET hTCP = UNKNOWN_SOCKET;
	DWORD t = 0;

	hTCP = TCPOpen((DWORD) dwOpenVal, vRemoteHostType, (WORD) wPort, TCP_PURPOSE_DEFAULT);
9d00234c:	0f4016e8 	jal	9d005ba0 <TCPOpen>
9d002350:	afb4001c 	sw	s4,28(sp)
	ChipKITPeriodicTasks();
9d002354:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002358:	00408821 	move	s1,v0

	// if it just fails, don't even attempt a retry
	if(hTCP == INVALID_SOCKET)
9d00235c:	240200fe 	li	v0,254
9d002360:	12220003 	beq	s1,v0,9d002370 <ChipKITClientConnect+0x50>
9d002364:	8fbf0024 	lw	ra,36(sp)
		return(hTCP);
	}

	// if this is a client, we have to wait until we connect
	// No need to do this for servers as they connect when some one comes in on the listen
	if(vRemoteHostType != TCP_OPEN_SERVER) 
9d002368:	16400009 	bnez	s2,9d002390 <ChipKITClientConnect+0x70>
9d00236c:	3c140004 	lui	s4,0x4
				
		ChipKITPeriodicTasks();
	}

	return(hTCP);
}
9d002370:	02201021 	move	v0,s1
9d002374:	8fb50020 	lw	s5,32(sp)
9d002378:	8fb4001c 	lw	s4,28(sp)
9d00237c:	8fb20018 	lw	s2,24(sp)
9d002380:	8fb10014 	lw	s1,20(sp)
9d002384:	8fb00010 	lw	s0,16(sp)
9d002388:	03e00008 	jr	ra
9d00238c:	27bd0028 	addiu	sp,sp,40

	// if this is a client, we have to wait until we connect
	// No need to do this for servers as they connect when some one comes in on the listen
	if(vRemoteHostType != TCP_OPEN_SERVER) 
	{
		t = TickGet(); // so we don't loop forever
9d002390:	0f400b53 	jal	9d002d4c <TickGet>
9d002394:	3694c4b4 	ori	s4,s4,0xc4b4
		while(!TCPIsConnected(hTCP))
		{
		 	ChipKITPeriodicTasks();
	
			// if after 10 seconds we do not connect, just fail and clean up
			if( (TickGet() - t) >= (cSecTimout * TICK_SECOND))
9d002398:	02140019 	multu	s0,s4

	// if this is a client, we have to wait until we connect
	// No need to do this for servers as they connect when some one comes in on the listen
	if(vRemoteHostType != TCP_OPEN_SERVER) 
	{
		t = TickGet(); // so we don't loop forever
9d00239c:	00409021 	move	s2,v0
		while(!TCPIsConnected(hTCP))
		{
		 	ChipKITPeriodicTasks();
	
			// if after 10 seconds we do not connect, just fail and clean up
			if( (TickGet() - t) >= (cSecTimout * TICK_SECOND))
9d0023a0:	0000a810 	mfhi	s5
9d0023a4:	0015802b 	sltu	s0,zero,s5
9d0023a8:	0000a012 	mflo	s4
	// if this is a client, we have to wait until we connect
	// No need to do this for servers as they connect when some one comes in on the listen
	if(vRemoteHostType != TCP_OPEN_SERVER) 
	{
		t = TickGet(); // so we don't loop forever
		while(!TCPIsConnected(hTCP))
9d0023ac:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d0023b0:	02202021 	move	a0,s1
9d0023b4:	1440000f 	bnez	v0,9d0023f4 <ChipKITClientConnect+0xd4>
9d0023b8:	00000000 	nop
		{
		 	ChipKITPeriodicTasks();
9d0023bc:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d0023c0:	00000000 	nop
	
			// if after 10 seconds we do not connect, just fail and clean up
			if( (TickGet() - t) >= (cSecTimout * TICK_SECOND))
9d0023c4:	0f400b53 	jal	9d002d4c <TickGet>
9d0023c8:	00000000 	nop
9d0023cc:	1600fff7 	bnez	s0,9d0023ac <ChipKITClientConnect+0x8c>
9d0023d0:	00521023 	subu	v0,v0,s2
9d0023d4:	0054102b 	sltu	v0,v0,s4
9d0023d8:	1440fff4 	bnez	v0,9d0023ac <ChipKITClientConnect+0x8c>
9d0023dc:	00000000 	nop
			{
				TCPClose(hTCP);
9d0023e0:	0f401802 	jal	9d006008 <TCPClose>
9d0023e4:	02202021 	move	a0,s1
				TCPDiscard(hTCP);
9d0023e8:	0f40196b 	jal	9d0065ac <TCPDiscard>
9d0023ec:	02202021 	move	a0,s1
				hTCP = INVALID_SOCKET;
9d0023f0:	241100fe 	li	s1,254
				// so don't return here, break out of the while to clean up
				break;  
			}
		}
				
		ChipKITPeriodicTasks();
9d0023f4:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d0023f8:	00000000 	nop
	}

	return(hTCP);
}
9d0023fc:	8fbf0024 	lw	ra,36(sp)
9d002400:	02201021 	move	v0,s1
9d002404:	8fb50020 	lw	s5,32(sp)
9d002408:	8fb4001c 	lw	s4,28(sp)
9d00240c:	8fb20018 	lw	s2,24(sp)
9d002410:	8fb10014 	lw	s1,20(sp)
9d002414:	8fb00010 	lw	s0,16(sp)
9d002418:	03e00008 	jr	ra
9d00241c:	27bd0028 	addiu	sp,sp,40

9d002420 <ChipKITClientAvailable>:

  Remarks:
	This is to match functionality of the Arduino Client class available method
  ***************************************************************************/
unsigned int ChipKITClientAvailable(TCP_SOCKET hTCP)
{
9d002420:	27bdffe0 	addiu	sp,sp,-32
9d002424:	308400ff 	andi	a0,a0,0xff
9d002428:	afbf001c 	sw	ra,28(sp)
	ChipKITPeriodicTasks();
9d00242c:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002430:	afa40010 	sw	a0,16(sp)
	return(TCPIsGetReady(hTCP));
9d002434:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d002438:	8fa40010 	lw	a0,16(sp)
}
9d00243c:	8fbf001c 	lw	ra,28(sp)
9d002440:	03e00008 	jr	ra
9d002444:	27bd0020 	addiu	sp,sp,32

9d002448 <ChipKITClientGetByte>:

  Remarks:
	This is to match functionality of the Arduino Client class Read method
  ***************************************************************************/
int ChipKITClientGetByte(TCP_SOCKET hTCP)
{
9d002448:	27bdffd8 	addiu	sp,sp,-40
9d00244c:	afb0001c 	sw	s0,28(sp)
9d002450:	309000ff 	andi	s0,a0,0xff
9d002454:	afbf0024 	sw	ra,36(sp)
	BYTE b;

	// run our tasks
	ChipKITPeriodicTasks();
9d002458:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d00245c:	afb10020 	sw	s1,32(sp)

	// Follow the Ardunio rules
    if( TCPIsGetReady(hTCP)> 0 && TCPGet(hTCP, &b))
9d002460:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d002464:	02002021 	move	a0,s0
9d002468:	14400007 	bnez	v0,9d002488 <ChipKITClientGetByte+0x40>
9d00246c:	2411ffff 	li	s1,-1
	}
	else
	{
		return(-1);
	}
}
9d002470:	8fbf0024 	lw	ra,36(sp)
9d002474:	02201021 	move	v0,s1
9d002478:	8fb10020 	lw	s1,32(sp)
9d00247c:	8fb0001c 	lw	s0,28(sp)
9d002480:	03e00008 	jr	ra
9d002484:	27bd0028 	addiu	sp,sp,40

	// run our tasks
	ChipKITPeriodicTasks();

	// Follow the Ardunio rules
    if( TCPIsGetReady(hTCP)> 0 && TCPGet(hTCP, &b))
9d002488:	02002021 	move	a0,s0
9d00248c:	0f401985 	jal	9d006614 <TCPGet>
9d002490:	27a50010 	addiu	a1,sp,16
	{
		return((int) ((unsigned int) b));
9d002494:	93a30010 	lbu	v1,16(sp)
9d002498:	0b40091c 	j	9d002470 <ChipKITClientGetByte+0x28>
9d00249c:	0062880b 	movn	s1,v1,v0

9d0024a0 <ChipKITClientGetBuff>:

  Remarks:
	This is to match functionality of the Arduino Client class Read method
  ***************************************************************************/
unsigned int ChipKITClientGetBuff(TCP_SOCKET hTCP, BYTE * rgBuff, unsigned short cbRead)
{
9d0024a0:	27bdffd8 	addiu	sp,sp,-40
9d0024a4:	afb00014 	sw	s0,20(sp)
9d0024a8:	30d0ffff 	andi	s0,a2,0xffff
9d0024ac:	afb30020 	sw	s3,32(sp)
9d0024b0:	afb2001c 	sw	s2,28(sp)
9d0024b4:	afb10018 	sw	s1,24(sp)
9d0024b8:	afbf0024 	sw	ra,36(sp)
9d0024bc:	00a09821 	move	s3,a1
9d0024c0:	309200ff 	andi	s2,a0,0xff
	WORD cb = 0;
	WORD cbCur = 0;

	// run our tasks
	ChipKITPeriodicTasks();
9d0024c4:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d0024c8:	00008821 	move	s1,zero
	// if there is anything to read
	// we don't even have to be connected for this to
	// return what is in the buffer.
	// we will return when we empty the buffer so we will not 
	// have an infinite loop problem waiting for data.
	while(cbRead > 0 && (cb = TCPIsGetReady(hTCP)) > 0)
9d0024cc:	1600000c 	bnez	s0,9d002500 <ChipKITClientGetBuff+0x60>
9d0024d0:	00001021 	move	v0,zero
		ChipKITPeriodicTasks();
	}

	// return what we read
	return(cbCur);
}
9d0024d4:	0b40094a 	j	9d002528 <ChipKITClientGetBuff+0x88>
9d0024d8:	8fbf0024 	lw	ra,36(sp)
	{
		// get as much as we want or can read
		cb = cb > cbRead ? cbRead : cb;

		// read it
		cb = TCPGetArray(hTCP, &rgBuff[cbCur], cb);
9d0024dc:	0f4019dc 	jal	9d006770 <TCPGetArray>
9d0024e0:	00000000 	nop

		cbCur += cb;
		cbRead -= cb;
9d0024e4:	02028023 	subu	s0,s0,v0
		cb = cb > cbRead ? cbRead : cb;

		// read it
		cb = TCPGetArray(hTCP, &rgBuff[cbCur], cb);

		cbCur += cb;
9d0024e8:	00518821 	addu	s1,v0,s1
		cbRead -= cb;
9d0024ec:	3210ffff 	andi	s0,s0,0xffff

		// run our tasks so everything is updated after the read
		ChipKITPeriodicTasks();
9d0024f0:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d0024f4:	3231ffff 	andi	s1,s1,0xffff
	// if there is anything to read
	// we don't even have to be connected for this to
	// return what is in the buffer.
	// we will return when we empty the buffer so we will not 
	// have an infinite loop problem waiting for data.
	while(cbRead > 0 && (cb = TCPIsGetReady(hTCP)) > 0)
9d0024f8:	1200000a 	beqz	s0,9d002524 <ChipKITClientGetBuff+0x84>
9d0024fc:	02201021 	move	v0,s1
9d002500:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d002504:	02402021 	move	a0,s2
	{
		// get as much as we want or can read
		cb = cb > cbRead ? cbRead : cb;
9d002508:	0050202b 	sltu	a0,v0,s0
9d00250c:	02003021 	move	a2,s0
9d002510:	0044300b 	movn	a2,v0,a0

		// read it
		cb = TCPGetArray(hTCP, &rgBuff[cbCur], cb);
9d002514:	02712821 	addu	a1,s3,s1
	// if there is anything to read
	// we don't even have to be connected for this to
	// return what is in the buffer.
	// we will return when we empty the buffer so we will not 
	// have an infinite loop problem waiting for data.
	while(cbRead > 0 && (cb = TCPIsGetReady(hTCP)) > 0)
9d002518:	1440fff0 	bnez	v0,9d0024dc <ChipKITClientGetBuff+0x3c>
9d00251c:	02402021 	move	a0,s2
9d002520:	02201021 	move	v0,s1
		ChipKITPeriodicTasks();
	}

	// return what we read
	return(cbCur);
}
9d002524:	8fbf0024 	lw	ra,36(sp)
9d002528:	8fb30020 	lw	s3,32(sp)
9d00252c:	8fb2001c 	lw	s2,28(sp)
9d002530:	8fb10018 	lw	s1,24(sp)
9d002534:	8fb00014 	lw	s0,20(sp)
9d002538:	03e00008 	jr	ra
9d00253c:	27bd0028 	addiu	sp,sp,40

9d002540 <ChipKITClientPutByte>:
	This is an expensive function to call as it flushes the1 byte out; we don't know
	how many bytes will be written, and the Arduino code expects the byte to go out.
	Also, this will run the periodic tasks, so a lot of over head is used for this task.
  ***************************************************************************/
BOOL ChipKITClientPutByte(TCP_SOCKET hTCP, BYTE b)
{
9d002540:	27bdffe0 	addiu	sp,sp,-32
9d002544:	afb00014 	sw	s0,20(sp)
9d002548:	309000ff 	andi	s0,a0,0xff
	BOOL fRet = FALSE;
	
	// really don't care if it is connected or not
	// just return the error
	fRet = TCPPut(hTCP, b);
9d00254c:	02002021 	move	a0,s0
	This is an expensive function to call as it flushes the1 byte out; we don't know
	how many bytes will be written, and the Arduino code expects the byte to go out.
	Also, this will run the periodic tasks, so a lot of over head is used for this task.
  ***************************************************************************/
BOOL ChipKITClientPutByte(TCP_SOCKET hTCP, BYTE b)
{
9d002550:	afb10018 	sw	s1,24(sp)
9d002554:	afbf001c 	sw	ra,28(sp)
	BOOL fRet = FALSE;
	
	// really don't care if it is connected or not
	// just return the error
	fRet = TCPPut(hTCP, b);
9d002558:	0f401847 	jal	9d00611c <TCPPut>
9d00255c:	30a500ff 	andi	a1,a1,0xff

	// this is very expensive!
	if(TCPIsConnected(hTCP))
9d002560:	02002021 	move	a0,s0
9d002564:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d002568:	00408821 	move	s1,v0
9d00256c:	10400003 	beqz	v0,9d00257c <ChipKITClientPutByte+0x3c>
9d002570:	00000000 	nop
	{
		TCPFlush(hTCP);				// flush any remaining stuff out
9d002574:	0f40180f 	jal	9d00603c <TCPFlush>
9d002578:	02002021 	move	a0,s0
	}

	// run our tasks so things can be put out and come in.
	ChipKITPeriodicTasks();
9d00257c:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002580:	00000000 	nop

	return(fRet);
}
9d002584:	8fbf001c 	lw	ra,28(sp)
9d002588:	02201021 	move	v0,s1
9d00258c:	8fb10018 	lw	s1,24(sp)
9d002590:	8fb00014 	lw	s0,20(sp)
9d002594:	03e00008 	jr	ra
9d002598:	27bd0020 	addiu	sp,sp,32

9d00259c <ChipKITClientPutSz>:
  Remarks:
	This is to match functionality of the Arduino Client class write method
	A flush to push the bytes out on the wire is done.
  ***************************************************************************/
unsigned int ChipKITClientPutSz(TCP_SOCKET hTCP, const char * sz, unsigned int cSecTimout)
{
9d00259c:	27bdffc0 	addiu	sp,sp,-64
9d0025a0:	afb30028 	sw	s3,40(sp)
9d0025a4:	afb20024 	sw	s2,36(sp)
9d0025a8:	afb10020 	sw	s1,32(sp)
9d0025ac:	00a09821 	move	s3,a1
	// there is a rare potential that this could loop forever
	// if the connection stays active yet the otherside does not read
	// the buffer.

	// loop until this is written out, or timeout
	t = TickGet();
9d0025b0:	afa60010 	sw	a2,16(sp)
  Remarks:
	This is to match functionality of the Arduino Client class write method
	A flush to push the bytes out on the wire is done.
  ***************************************************************************/
unsigned int ChipKITClientPutSz(TCP_SOCKET hTCP, const char * sz, unsigned int cSecTimout)
{
9d0025b4:	afbf003c 	sw	ra,60(sp)
9d0025b8:	afb70038 	sw	s7,56(sp)
9d0025bc:	afb60034 	sw	s6,52(sp)
9d0025c0:	afb50030 	sw	s5,48(sp)
9d0025c4:	afb4002c 	sw	s4,44(sp)
9d0025c8:	afb0001c 	sw	s0,28(sp)
	// there is a rare potential that this could loop forever
	// if the connection stays active yet the otherside does not read
	// the buffer.

	// loop until this is written out, or timeout
	t = TickGet();
9d0025cc:	0f400b53 	jal	9d002d4c <TickGet>
9d0025d0:	309100ff 	andi	s1,a0,0xff
9d0025d4:	00409021 	move	s2,v0
	while(*szCur !=0x00) 
9d0025d8:	82620000 	lb	v0,0(s3)
9d0025dc:	1040003a 	beqz	v0,9d0026c8 <ChipKITClientPutSz+0x12c>
9d0025e0:	8fa60010 	lw	a2,16(sp)
			szLast = szCur;	// last written location
			t = TickGet();	// reset wait timer, we are moving forward
		}

		// we have not moved forward, so check our timeout value
		else if((TickGet() - t) >= (cSecTimout * TICK_SECOND)) 
9d0025e4:	3c160004 	lui	s6,0x4
9d0025e8:	36d6c4b4 	ori	s6,s6,0xc4b4
9d0025ec:	00d60019 	multu	a2,s6
9d0025f0:	02608021 	move	s0,s3
9d0025f4:	0000b810 	mfhi	s7
9d0025f8:	0017a02b 	sltu	s4,zero,s7
9d0025fc:	0b400989 	j	9d002624 <ChipKITClientPutSz+0x88>
9d002600:	0000b012 	mflo	s6
		
		// we did move forward, so reset our timers and pointers.
		else if(szCur != szLast)
		{
			szLast = szCur;	// last written location
			t = TickGet();	// reset wait timer, we are moving forward
9d002604:	0f400b53 	jal	9d002d4c <TickGet>
9d002608:	00000000 	nop
9d00260c:	00409021 	move	s2,v0
		}
			
		// if the buffer is full, it should automatically flush
		// so we should not need to write TCPFlush
		// run our tasks so things can be put out and come in.
		ChipKITPeriodicTasks();
9d002610:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002614:	02a08021 	move	s0,s5
	// if the connection stays active yet the otherside does not read
	// the buffer.

	// loop until this is written out, or timeout
	t = TickGet();
	while(*szCur !=0x00) 
9d002618:	82a20000 	lb	v0,0(s5)
9d00261c:	50400016 	beqzl	v0,9d002678 <ChipKITClientPutSz+0xdc>
9d002620:	02b39823 	subu	s3,s5,s3
	{
		// if we lost the connection, get out
		if( !TCPIsConnected(hTCP) )
9d002624:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d002628:	02202021 	move	a0,s1
		{
			break;
		}

		// try to write some char out
		szCur = TCPPutString(hTCP, szCur);
9d00262c:	02002821 	move	a1,s0
	// loop until this is written out, or timeout
	t = TickGet();
	while(*szCur !=0x00) 
	{
		// if we lost the connection, get out
		if( !TCPIsConnected(hTCP) )
9d002630:	10400010 	beqz	v0,9d002674 <ChipKITClientPutSz+0xd8>
9d002634:	02202021 	move	a0,s1
		{
			break;
		}

		// try to write some char out
		szCur = TCPPutString(hTCP, szCur);
9d002638:	0f401942 	jal	9d006508 <TCPPutString>
9d00263c:	00000000 	nop
9d002640:	0040a821 	move	s5,v0

		// if we are done, get out.
		if(*szCur == 0x00)
9d002644:	80420000 	lb	v0,0(v0)
9d002648:	5040000b 	beqzl	v0,9d002678 <ChipKITClientPutSz+0xdc>
9d00264c:	02b39823 	subu	s3,s5,s3
		{
			break;
		}
		
		// we did move forward, so reset our timers and pointers.
		else if(szCur != szLast)
9d002650:	16b0ffec 	bne	s5,s0,9d002604 <ChipKITClientPutSz+0x68>
9d002654:	00000000 	nop
			szLast = szCur;	// last written location
			t = TickGet();	// reset wait timer, we are moving forward
		}

		// we have not moved forward, so check our timeout value
		else if((TickGet() - t) >= (cSecTimout * TICK_SECOND)) 
9d002658:	0f400b53 	jal	9d002d4c <TickGet>
9d00265c:	00000000 	nop
9d002660:	1680ffeb 	bnez	s4,9d002610 <ChipKITClientPutSz+0x74>
9d002664:	00521023 	subu	v0,v0,s2
9d002668:	0056102b 	sltu	v0,v0,s6
9d00266c:	1440ffe8 	bnez	v0,9d002610 <ChipKITClientPutSz+0x74>
9d002670:	00000000 	nop
9d002674:	02139823 	subu	s3,s0,s3
		// so we should not need to write TCPFlush
		// run our tasks so things can be put out and come in.
		ChipKITPeriodicTasks();
	}

	if(TCPIsConnected(hTCP))
9d002678:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d00267c:	02202021 	move	a0,s1
9d002680:	10400003 	beqz	v0,9d002690 <ChipKITClientPutSz+0xf4>
9d002684:	00000000 	nop
	{
		TCPFlush(hTCP);				// flush any remaining stuff out
9d002688:	0f40180f 	jal	9d00603c <TCPFlush>
9d00268c:	02202021 	move	a0,s1
	}

	ChipKITPeriodicTasks();		// run the tasks to get it done
9d002690:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002694:	00000000 	nop
	return( ((unsigned int) (szCur - sz)) / sizeof(char) ); // return # char written
}
9d002698:	8fbf003c 	lw	ra,60(sp)
9d00269c:	02601021 	move	v0,s3
9d0026a0:	8fb70038 	lw	s7,56(sp)
9d0026a4:	8fb60034 	lw	s6,52(sp)
9d0026a8:	8fb50030 	lw	s5,48(sp)
9d0026ac:	8fb4002c 	lw	s4,44(sp)
9d0026b0:	8fb30028 	lw	s3,40(sp)
9d0026b4:	8fb20024 	lw	s2,36(sp)
9d0026b8:	8fb10020 	lw	s1,32(sp)
9d0026bc:	8fb0001c 	lw	s0,28(sp)
9d0026c0:	03e00008 	jr	ra
9d0026c4:	27bd0040 	addiu	sp,sp,64
	// if the connection stays active yet the otherside does not read
	// the buffer.

	// loop until this is written out, or timeout
	t = TickGet();
	while(*szCur !=0x00) 
9d0026c8:	0b40099e 	j	9d002678 <ChipKITClientPutSz+0xdc>
9d0026cc:	00009821 	move	s3,zero

9d0026d0 <ChipKITClientPutBuff>:
  Remarks:
	This is to match functionality of the Arduino Client class write method
	A flush to push the bytes out on the wire is done.
  ***************************************************************************/
unsigned int ChipKITClientPutBuff(TCP_SOCKET hTCP, const BYTE * rgBuff, unsigned short cbWrite, unsigned int cSecTimeout)
{
9d0026d0:	27bdffc0 	addiu	sp,sp,-64
9d0026d4:	afb50030 	sw	s5,48(sp)
9d0026d8:	afb30028 	sw	s3,40(sp)
9d0026dc:	afb20024 	sw	s2,36(sp)
9d0026e0:	afb10020 	sw	s1,32(sp)
9d0026e4:	afb0001c 	sw	s0,28(sp)
	WORD cbToWrite = 0;
	WORD cbPutTotal = 0;
	DWORD t = 0;

	// loop until this is written out, or timeout
	t = TickGet();
9d0026e8:	afa70010 	sw	a3,16(sp)
  Remarks:
	This is to match functionality of the Arduino Client class write method
	A flush to push the bytes out on the wire is done.
  ***************************************************************************/
unsigned int ChipKITClientPutBuff(TCP_SOCKET hTCP, const BYTE * rgBuff, unsigned short cbWrite, unsigned int cSecTimeout)
{
9d0026ec:	afbf003c 	sw	ra,60(sp)
9d0026f0:	afb70038 	sw	s7,56(sp)
9d0026f4:	afb60034 	sw	s6,52(sp)
9d0026f8:	afb4002c 	sw	s4,44(sp)
9d0026fc:	30d2ffff 	andi	s2,a2,0xffff
9d002700:	00a0a821 	move	s5,a1
	WORD cbToWrite = 0;
	WORD cbPutTotal = 0;
	DWORD t = 0;

	// loop until this is written out, or timeout
	t = TickGet();
9d002704:	0f400b53 	jal	9d002d4c <TickGet>
9d002708:	309000ff 	andi	s0,a0,0xff
9d00270c:	00408821 	move	s1,v0
	while(cbWrite > 0) 
9d002710:	8fa70010 	lw	a3,16(sp)
9d002714:	1240001a 	beqz	s2,9d002780 <ChipKITClientPutBuff+0xb0>
9d002718:	00009821 	move	s3,zero
		{
			t = TickGet();	// reset wait timer, we are moving forward
		}

		// didn't move forward, see if we are timing out
		else if((TickGet() - t) >= (cSecTimeout * TICK_SECOND)) 
9d00271c:	3c160004 	lui	s6,0x4
9d002720:	36d6c4b4 	ori	s6,s6,0xc4b4
9d002724:	00f60019 	multu	a3,s6
	// loop until this is written out, or timeout
	t = TickGet();
	while(cbWrite > 0) 
	{
		// get out if we lost connection
		if(!TCPIsConnected(hTCP))
9d002728:	02002021 	move	a0,s0
unsigned int ChipKITClientPutBuff(TCP_SOCKET hTCP, const BYTE * rgBuff, unsigned short cbWrite, unsigned int cSecTimeout)
{
	WORD cbReady = 0;
	WORD cbPut = 0;
	WORD cbToWrite = 0;
	WORD cbPutTotal = 0;
9d00272c:	00009821 	move	s3,zero
		{
			t = TickGet();	// reset wait timer, we are moving forward
		}

		// didn't move forward, see if we are timing out
		else if((TickGet() - t) >= (cSecTimeout * TICK_SECOND)) 
9d002730:	0000b810 	mfhi	s7
9d002734:	0017a02b 	sltu	s4,zero,s7
	// loop until this is written out, or timeout
	t = TickGet();
	while(cbWrite > 0) 
	{
		// get out if we lost connection
		if(!TCPIsConnected(hTCP))
9d002738:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d00273c:	0000b012 	mflo	s6
9d002740:	1040000f 	beqz	v0,9d002780 <ChipKITClientPutBuff+0xb0>
9d002744:	02002021 	move	a0,s0
		{
			break;
		}

		// see how much buffer space is available
		if((cbReady = TCPIsPutReady(hTCP)) > 0)
9d002748:	0f401825 	jal	9d006094 <TCPIsPutReady>
9d00274c:	00000000 	nop
9d002750:	1440001f 	bnez	v0,9d0027d0 <ChipKITClientPutBuff+0x100>
9d002754:	00403021 	move	a2,v0
		{
			t = TickGet();	// reset wait timer, we are moving forward
		}

		// didn't move forward, see if we are timing out
		else if((TickGet() - t) >= (cSecTimeout * TICK_SECOND)) 
9d002758:	0f400b53 	jal	9d002d4c <TickGet>
9d00275c:	00000000 	nop
9d002760:	1280002d 	beqz	s4,9d002818 <ChipKITClientPutBuff+0x148>
9d002764:	00511023 	subu	v0,v0,s1
			break;
		}

		// run our tasks so things can be put out and come in.
		cbPut = 0;	// to see if we are moving forward
		ChipKITPeriodicTasks();
9d002768:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d00276c:	00000000 	nop
	// loop until this is written out, or timeout
	t = TickGet();
	while(cbWrite > 0) 
	{
		// get out if we lost connection
		if(!TCPIsConnected(hTCP))
9d002770:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d002774:	02002021 	move	a0,s0
9d002778:	1440fff3 	bnez	v0,9d002748 <ChipKITClientPutBuff+0x78>
9d00277c:	02002021 	move	a0,s0
		// run our tasks so things can be put out and come in.
		cbPut = 0;	// to see if we are moving forward
		ChipKITPeriodicTasks();
	}
	
	if(TCPIsConnected(hTCP))
9d002780:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d002784:	02002021 	move	a0,s0
9d002788:	10400003 	beqz	v0,9d002798 <ChipKITClientPutBuff+0xc8>
9d00278c:	00000000 	nop
	{
		TCPFlush(hTCP);				// flush any remaining stuff out
9d002790:	0f40180f 	jal	9d00603c <TCPFlush>
9d002794:	02002021 	move	a0,s0
	}

	ChipKITPeriodicTasks();		// run tasks to do it
9d002798:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d00279c:	00000000 	nop
	return(cbPutTotal);
}
9d0027a0:	8fbf003c 	lw	ra,60(sp)
9d0027a4:	02601021 	move	v0,s3
9d0027a8:	8fb70038 	lw	s7,56(sp)
9d0027ac:	8fb60034 	lw	s6,52(sp)
9d0027b0:	8fb50030 	lw	s5,48(sp)
9d0027b4:	8fb4002c 	lw	s4,44(sp)
9d0027b8:	8fb30028 	lw	s3,40(sp)
9d0027bc:	8fb20024 	lw	s2,36(sp)
9d0027c0:	8fb10020 	lw	s1,32(sp)
9d0027c4:	8fb0001c 	lw	s0,28(sp)
9d0027c8:	03e00008 	jr	ra
9d0027cc:	27bd0040 	addiu	sp,sp,64

		// see how much buffer space is available
		if((cbReady = TCPIsPutReady(hTCP)) > 0)
		{
			// only put out what we can
			cbToWrite = cbWrite > cbReady ? cbReady : cbWrite;
9d0027d0:	0242102b 	sltu	v0,s2,v0

			// put the data out
			cbPut = TCPPutArray(hTCP, (BYTE *) &rgBuff[cbPutTotal], cbToWrite);
9d0027d4:	02b32821 	addu	a1,s5,s3
9d0027d8:	0242300b 	movn	a2,s2,v0
9d0027dc:	0f4018b2 	jal	9d0062c8 <TCPPutArray>
9d0027e0:	02002021 	move	a0,s0

			// update our loop counters
			cbPutTotal += cbPut;
			cbWrite -= cbPut;
9d0027e4:	02429023 	subu	s2,s2,v0

			// put the data out
			cbPut = TCPPutArray(hTCP, (BYTE *) &rgBuff[cbPutTotal], cbToWrite);

			// update our loop counters
			cbPutTotal += cbPut;
9d0027e8:	00539821 	addu	s3,v0,s3
			cbWrite -= cbPut;
9d0027ec:	3252ffff 	andi	s2,s2,0xffff
		}

		// if we are done get out
		if(cbWrite == 0)
9d0027f0:	1240ffe3 	beqz	s2,9d002780 <ChipKITClientPutBuff+0xb0>
9d0027f4:	3273ffff 	andi	s3,s3,0xffff
		{
			break;
		}

		// check to see if we are moving forward
		else if(cbPut > 0) 
9d0027f8:	1040ffd7 	beqz	v0,9d002758 <ChipKITClientPutBuff+0x88>
9d0027fc:	00000000 	nop
		{
			t = TickGet();	// reset wait timer, we are moving forward
9d002800:	0f400b53 	jal	9d002d4c <TickGet>
9d002804:	00000000 	nop
			break;
		}

		// run our tasks so things can be put out and come in.
		cbPut = 0;	// to see if we are moving forward
		ChipKITPeriodicTasks();
9d002808:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d00280c:	00408821 	move	s1,v0
9d002810:	0b4009dc 	j	9d002770 <ChipKITClientPutBuff+0xa0>
9d002814:	00000000 	nop
		{
			t = TickGet();	// reset wait timer, we are moving forward
		}

		// didn't move forward, see if we are timing out
		else if((TickGet() - t) >= (cSecTimeout * TICK_SECOND)) 
9d002818:	0056102b 	sltu	v0,v0,s6
9d00281c:	1040ffd8 	beqz	v0,9d002780 <ChipKITClientPutBuff+0xb0>
9d002820:	00000000 	nop
			break;
		}

		// run our tasks so things can be put out and come in.
		cbPut = 0;	// to see if we are moving forward
		ChipKITPeriodicTasks();
9d002824:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002828:	00000000 	nop
9d00282c:	0b4009dc 	j	9d002770 <ChipKITClientPutBuff+0xa0>
9d002830:	00000000 	nop

9d002834 <ChipKITClientStop>:

  Remarks:
	This is to match functionality of the Arduino Client class stop method
  ***************************************************************************/
void ChipKITClientStop(TCP_SOCKET hTCP)
{
9d002834:	27bdffe8 	addiu	sp,sp,-24
9d002838:	afb00010 	sw	s0,16(sp)
9d00283c:	309000ff 	andi	s0,a0,0xff

	// the MAL can hang if you attempt to close an invalid socket
	if(hTCP == INVALID_SOCKET || hTCP == UNKNOWN_SOCKET)
9d002840:	26020002 	addiu	v0,s0,2
9d002844:	304200ff 	andi	v0,v0,0xff
9d002848:	2c420002 	sltiu	v0,v0,2
9d00284c:	1440000b 	bnez	v0,9d00287c <ChipKITClientStop+0x48>
9d002850:	afbf0014 	sw	ra,20(sp)
	{
		return;
	}

	// close the handle
	TCPClose(hTCP);
9d002854:	0f401802 	jal	9d006008 <TCPClose>
9d002858:	02002021 	move	a0,s0

	// empty the receive buffer because we are killing it.
	TCPDiscard(hTCP);
9d00285c:	0f40196b 	jal	9d0065ac <TCPDiscard>
9d002860:	02002021 	move	a0,s0

	// loop until it is acknowledged to be closed
	do
	{
		ChipKITPeriodicTasks();
9d002864:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d002868:	00000000 	nop
	} while(TCPIsConnected(hTCP));	
9d00286c:	0f40178e 	jal	9d005e38 <TCPIsConnected>
9d002870:	02002021 	move	a0,s0
9d002874:	1440fffb 	bnez	v0,9d002864 <ChipKITClientStop+0x30>
9d002878:	00000000 	nop

}
9d00287c:	8fbf0014 	lw	ra,20(sp)
9d002880:	8fb00010 	lw	s0,16(sp)
9d002884:	03e00008 	jr	ra
9d002888:	27bd0018 	addiu	sp,sp,24

9d00288c <ChipKITClientConnected>:
	This is to match functionality of the Arduino Client class Connected method.
	This will return TRUE even if the socket is no longer connected yet there are still
	some unread bytes in the socket buffer. This is to match Arduino functionality
  ***************************************************************************/
BOOL ChipKITClientConnected(TCP_SOCKET hTCP)
{
9d00288c:	27bdffe8 	addiu	sp,sp,-24
9d002890:	afb00010 	sw	s0,16(sp)
9d002894:	309000ff 	andi	s0,a0,0xff
9d002898:	afbf0014 	sw	ra,20(sp)
	// even though we are disconnected we may 
	// still have data in the input buffer
	// Arduino defines this as still open
	// so check to see if we have stuff. 
	if(TCPIsGetReady(hTCP) == 0)
9d00289c:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d0028a0:	02002021 	move	a0,s0
9d0028a4:	10400005 	beqz	v0,9d0028bc <ChipKITClientConnected+0x30>
9d0028a8:	8fbf0014 	lw	ra,20(sp)
	// still have stuff in the buffer, say we are connected.
	else
	{
		return(TRUE);
	}
}
9d0028ac:	24020001 	li	v0,1
9d0028b0:	8fb00010 	lw	s0,16(sp)
9d0028b4:	03e00008 	jr	ra
9d0028b8:	27bd0018 	addiu	sp,sp,24
	// Arduino defines this as still open
	// so check to see if we have stuff. 
	if(TCPIsGetReady(hTCP) == 0)
	{
		// nothing in the buffer, return the truth about the connection
		return(TCPIsConnected(hTCP));
9d0028bc:	02002021 	move	a0,s0
	// still have stuff in the buffer, say we are connected.
	else
	{
		return(TRUE);
	}
}
9d0028c0:	8fb00010 	lw	s0,16(sp)
	// Arduino defines this as still open
	// so check to see if we have stuff. 
	if(TCPIsGetReady(hTCP) == 0)
	{
		// nothing in the buffer, return the truth about the connection
		return(TCPIsConnected(hTCP));
9d0028c4:	0b40178e 	j	9d005e38 <TCPIsConnected>
9d0028c8:	27bd0018 	addiu	sp,sp,24

9d0028cc <ChipKITClientFlush>:
	This is to match functionality of the Arduino Client class flush method
	In Arduino, flush means to discard the input buffer which is different than
	Flush in the MAL which means to push the data out on the wire.
  ***************************************************************************/
void ChipKITClientFlush(TCP_SOCKET hTCP)
{
9d0028cc:	27bdffe8 	addiu	sp,sp,-24
9d0028d0:	afbf0014 	sw	ra,20(sp)
	TCPDiscard(hTCP);
9d0028d4:	0f40196b 	jal	9d0065ac <TCPDiscard>
9d0028d8:	308400ff 	andi	a0,a0,0xff
	ChipKITPeriodicTasks();
}
9d0028dc:	8fbf0014 	lw	ra,20(sp)
	Flush in the MAL which means to push the data out on the wire.
  ***************************************************************************/
void ChipKITClientFlush(TCP_SOCKET hTCP)
{
	TCPDiscard(hTCP);
	ChipKITPeriodicTasks();
9d0028e0:	0b4007b6 	j	9d001ed8 <ChipKITPeriodicTasks>
9d0028e4:	27bd0018 	addiu	sp,sp,24

9d0028e8 <ChipKITClientPeek>:

  Remarks:
	This is to match functionality of the Arduino Client class peek method
  ***************************************************************************/
int ChipKITClientPeek(TCP_SOCKET hTCP)
{
9d0028e8:	27bdffe8 	addiu	sp,sp,-24
9d0028ec:	afb00010 	sw	s0,16(sp)
9d0028f0:	afbf0014 	sw	ra,20(sp)
	unsigned int cb = 0;

	ChipKITPeriodicTasks();
9d0028f4:	0f4007b6 	jal	9d001ed8 <ChipKITPeriodicTasks>
9d0028f8:	309000ff 	andi	s0,a0,0xff

	cb = TCPIsGetReady(hTCP);
9d0028fc:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d002900:	02002021 	move	a0,s0

	// follow the Arduino convension or return -1 on empty
	if(cb == 0)
9d002904:	10400005 	beqz	v0,9d00291c <ChipKITClientPeek+0x34>
9d002908:	2403ffff 	li	v1,-1
	{
		return(-1);
	}
	else
	{
		return( (int) ((unsigned int) TCPPeek(hTCP, 0)));
9d00290c:	02002021 	move	a0,s0
9d002910:	0f401abd 	jal	9d006af4 <TCPPeek>
9d002914:	00002821 	move	a1,zero
9d002918:	00401821 	move	v1,v0
 	}
}
9d00291c:	8fbf0014 	lw	ra,20(sp)
9d002920:	00601021 	move	v0,v1
9d002924:	8fb00010 	lw	s0,16(sp)
9d002928:	03e00008 	jr	ra
9d00292c:	27bd0018 	addiu	sp,sp,24

9d002930 <SNTPClient>:
		SM_UDP_RECV,
		SM_SHORT_WAIT,
		SM_WAIT
	} SNTPState = SM_HOME;

	switch(SNTPState)
9d002930:	8f828064 	lw	v0,-32668(gp)
  Remarks:
	This function requires once available UDP socket while processing, but
	frees that socket when the SNTP module is idle.
  ***************************************************************************/
void SNTPClient(void)
{
9d002934:	27bdffb8 	addiu	sp,sp,-72
9d002938:	afbf0044 	sw	ra,68(sp)
		SM_UDP_RECV,
		SM_SHORT_WAIT,
		SM_WAIT
	} SNTPState = SM_HOME;

	switch(SNTPState)
9d00293c:	2c43000d 	sltiu	v1,v0,13
9d002940:	10600022 	beqz	v1,9d0029cc <SNTPClient+0x9c>
9d002944:	afb00040 	sw	s0,64(sp)
9d002948:	3c039d01 	lui	v1,0x9d01
9d00294c:	00021080 	sll	v0,v0,0x2
9d002950:	2463dbf8 	addiu	v1,v1,-9224
9d002954:	00621021 	addu	v0,v1,v0
9d002958:	8c420000 	lw	v0,0(v0)
9d00295c:	00400008 	jr	v0
9d002960:	00000000 	nop
				}
				break;
			}
			
			// Get the response time packet
			w = UDPGetArray((BYTE*) &pkt, sizeof(pkt));
9d002964:	0f401313 	jal	9d004c4c <UDPGetArray>
9d002968:	27a40010 	addiu	a0,sp,16
			UDPClose(MySocket);
9d00296c:	93848068 	lbu	a0,-32664(gp)
9d002970:	0f40121f 	jal	9d00487c <UDPClose>
9d002974:	00408021 	move	s0,v0
			dwTimer = TickGetDiv64K();
9d002978:	0f400b6b 	jal	9d002dac <TickGetDiv64K>
9d00297c:	00000000 	nop
9d002980:	af82806c 	sw	v0,-32660(gp)
			SNTPState = SM_WAIT;
9d002984:	2402000c 	li	v0,12
9d002988:	af828064 	sw	v0,-32668(gp)

			// Validate packet size
			if(w != sizeof(pkt)) 
9d00298c:	24020030 	li	v0,48
9d002990:	1602000f 	bne	s0,v0,9d0029d0 <SNTPClient+0xa0>
9d002994:	8fbf0044 	lw	ra,68(sp)
			{
				break;	
			}
			
			// Set out local time to match the returned time
			dwLastUpdateTick = TickGet();
9d002998:	0f400b53 	jal	9d002d4c <TickGet>
9d00299c:	00000000 	nop
			dwSNTPSeconds = swapl(pkt.tx_ts_secs) - NTP_EPOCH;
9d0029a0:	8fa40038 	lw	a0,56(sp)
9d0029a4:	0f40260b 	jal	9d00982c <swapl>
9d0029a8:	af82805c 	sw	v0,-32676(gp)
9d0029ac:	3c047c55 	lui	a0,0x7c55
			// Do rounding.  If the partial seconds is > 0.5 then add 1 to the seconds count.
			if(((BYTE*)&pkt.tx_ts_fraq)[0] & 0x80)
9d0029b0:	83a3003c 	lb	v1,60(sp)
				break;	
			}
			
			// Set out local time to match the returned time
			dwLastUpdateTick = TickGet();
			dwSNTPSeconds = swapl(pkt.tx_ts_secs) - NTP_EPOCH;
9d0029b4:	34848180 	ori	a0,a0,0x8180
9d0029b8:	00441021 	addu	v0,v0,a0
			// Do rounding.  If the partial seconds is > 0.5 then add 1 to the seconds count.
			if(((BYTE*)&pkt.tx_ts_fraq)[0] & 0x80)
9d0029bc:	04610003 	bgez	v1,9d0029cc <SNTPClient+0x9c>
9d0029c0:	af828060 	sw	v0,-32672(gp)
				dwSNTPSeconds++;
9d0029c4:	24420001 	addiu	v0,v0,1
9d0029c8:	af828060 	sw	v0,-32672(gp)
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
				SNTPState = SM_HOME;	

			break;
	}
}
9d0029cc:	8fbf0044 	lw	ra,68(sp)
9d0029d0:	8fb00040 	lw	s0,64(sp)
9d0029d4:	03e00008 	jr	ra
9d0029d8:	27bd0048 	addiu	sp,sp,72
			SNTPState = SM_UDP_RECV;		
			break;

		case SM_UDP_RECV:
			// Look for a response time packet
			if(!UDPIsGetReady(MySocket)) 
9d0029dc:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d0029e0:	93848068 	lbu	a0,-32664(gp)
9d0029e4:	1440ffdf 	bnez	v0,9d002964 <SNTPClient+0x34>
9d0029e8:	24050030 	li	a1,48
			{
				if((TickGet()) - dwTimer > NTP_REPLY_TIMEOUT)
9d0029ec:	0f400b53 	jal	9d002d4c <TickGet>
9d0029f0:	00000000 	nop
9d0029f4:	8f83806c 	lw	v1,-32660(gp)
9d0029f8:	3c04001c 	lui	a0,0x1c
9d0029fc:	34849c39 	ori	a0,a0,0x9c39
9d002a00:	00431823 	subu	v1,v0,v1
9d002a04:	0064182b 	sltu	v1,v1,a0
9d002a08:	1460fff1 	bnez	v1,9d0029d0 <SNTPClient+0xa0>
9d002a0c:	8fbf0044 	lw	ra,68(sp)
				{
					// Abort the request and wait until the next timeout period
					UDPClose(MySocket);
9d002a10:	0f40121f 	jal	9d00487c <UDPClose>
9d002a14:	93848068 	lbu	a0,-32664(gp)
					dwTimer = TickGetDiv64K();
9d002a18:	0f400b6b 	jal	9d002dac <TickGetDiv64K>
9d002a1c:	00000000 	nop
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
				SNTPState = SM_HOME;	

			break;
	}
}
9d002a20:	8fbf0044 	lw	ra,68(sp)
			{
				if((TickGet()) - dwTimer > NTP_REPLY_TIMEOUT)
				{
					// Abort the request and wait until the next timeout period
					UDPClose(MySocket);
					dwTimer = TickGetDiv64K();
9d002a24:	af82806c 	sw	v0,-32660(gp)
					SNTPState = SM_SHORT_WAIT;
9d002a28:	2402000b 	li	v0,11
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
				SNTPState = SM_HOME;	

			break;
	}
}
9d002a2c:	8fb00040 	lw	s0,64(sp)
				if((TickGet()) - dwTimer > NTP_REPLY_TIMEOUT)
				{
					// Abort the request and wait until the next timeout period
					UDPClose(MySocket);
					dwTimer = TickGetDiv64K();
					SNTPState = SM_SHORT_WAIT;
9d002a30:	af828064 	sw	v0,-32668(gp)
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
				SNTPState = SM_HOME;	

			break;
	}
}
9d002a34:	03e00008 	jr	ra
9d002a38:	27bd0048 	addiu	sp,sp,72
			SNTPState = SM_SHORT_WAIT;
			break;

		case SM_UDP_SEND:
			// Open up the sending UDP socket
			MySocket = UDPOpen(0, &Server, NTP_SERVER_PORT);
9d002a3c:	3c05a000 	lui	a1,0xa000
9d002a40:	00002021 	move	a0,zero
9d002a44:	24a50af0 	addiu	a1,a1,2800
9d002a48:	0f4011e9 	jal	9d0047a4 <UDPOpen>
9d002a4c:	2406007b 	li	a2,123
			if(MySocket == INVALID_UDP_SOCKET)
9d002a50:	240300ff 	li	v1,255
9d002a54:	1043ffdd 	beq	v0,v1,9d0029cc <SNTPClient+0x9c>
9d002a58:	a3828068 	sb	v0,-32664(gp)
				break;

			// Make certain the socket can be written to
			if(!UDPIsPutReady(MySocket))
9d002a5c:	0f401246 	jal	9d004918 <UDPIsPutReady>
9d002a60:	00402021 	move	a0,v0
9d002a64:	1440005a 	bnez	v0,9d002bd0 <SNTPClient+0x2a0>
9d002a68:	3c0483aa 	lui	a0,0x83aa
			{
				UDPClose(MySocket);
9d002a6c:	0f40121f 	jal	9d00487c <UDPClose>
9d002a70:	93848068 	lbu	a0,-32664(gp)
				break;
9d002a74:	0b400a74 	j	9d0029d0 <SNTPClient+0xa0>
9d002a78:	8fbf0044 	lw	ra,68(sp)

			break;

		case SM_SHORT_WAIT:
			// Attempt to requery the NTP server after a specified NTP_FAST_QUERY_INTERVAL time (ex: 8 seconds) has elapsed.
			if(TickGetDiv64K() - dwTimer > (NTP_FAST_QUERY_INTERVAL/65536ull))
9d002a7c:	0f400b6b 	jal	9d002dac <TickGetDiv64K>
9d002a80:	00000000 	nop
9d002a84:	8f83806c 	lw	v1,-32660(gp)
9d002a88:	00431823 	subu	v1,v0,v1
9d002a8c:	2c630043 	sltiu	v1,v1,67
9d002a90:	1460ffcf 	bnez	v1,9d0029d0 <SNTPClient+0xa0>
9d002a94:	8fbf0044 	lw	ra,68(sp)
			break;

		case SM_WAIT:
			// Requery the NTP server after a specified NTP_QUERY_INTERVAL time (ex: 10 minutes) has elapsed.
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
				SNTPState = SM_HOME;	
9d002a98:	af808064 	sw	zero,-32668(gp)

			break;
	}
}
9d002a9c:	8fbf0044 	lw	ra,68(sp)
9d002aa0:	8fb00040 	lw	s0,64(sp)
9d002aa4:	03e00008 	jr	ra
9d002aa8:	27bd0048 	addiu	sp,sp,72
				SNTPState = SM_HOME;	
			break;

		case SM_WAIT:
			// Requery the NTP server after a specified NTP_QUERY_INTERVAL time (ex: 10 minutes) has elapsed.
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
9d002aac:	0f400b6b 	jal	9d002dac <TickGetDiv64K>
9d002ab0:	00000000 	nop
9d002ab4:	8f83806c 	lw	v1,-32660(gp)
9d002ab8:	00431823 	subu	v1,v0,v1
9d002abc:	2c630b2e 	sltiu	v1,v1,2862
9d002ac0:	1460ffc3 	bnez	v1,9d0029d0 <SNTPClient+0xa0>
9d002ac4:	8fbf0044 	lw	ra,68(sp)
				SNTPState = SM_HOME;	
9d002ac8:	0b400aa7 	j	9d002a9c <SNTPClient+0x16c>
9d002acc:	af808064 	sw	zero,-32668(gp)
			SNTPState = SM_NAME_RESOLVE;
			break;

		case SM_NAME_RESOLVE:
			// Wait for DNS resolution to complete
			if(!DNSIsResolved(&Server.IPAddr)) 
9d002ad0:	3c10a000 	lui	s0,0xa000
9d002ad4:	0f401021 	jal	9d004084 <DNSIsResolved>
9d002ad8:	26040af0 	addiu	a0,s0,2800
9d002adc:	14400036 	bnez	v0,9d002bb8 <SNTPClient+0x288>
9d002ae0:	00000000 	nop
			{
				if((TickGet() - dwTimer) > (5 * TICK_SECOND)) 
9d002ae4:	0f400b53 	jal	9d002d4c <TickGet>
9d002ae8:	00000000 	nop
9d002aec:	8f83806c 	lw	v1,-32660(gp)
9d002af0:	3c040017 	lui	a0,0x17
9d002af4:	3484d785 	ori	a0,a0,0xd785
9d002af8:	00431823 	subu	v1,v0,v1
9d002afc:	0064182b 	sltu	v1,v1,a0
9d002b00:	1460ffb3 	bnez	v1,9d0029d0 <SNTPClient+0xa0>
9d002b04:	8fbf0044 	lw	ra,68(sp)
				{
					DNSEndUsage();
9d002b08:	0f400fef 	jal	9d003fbc <DNSEndUsage>
9d002b0c:	00000000 	nop
					dwTimer = TickGetDiv64K();
9d002b10:	0f400b6b 	jal	9d002dac <TickGetDiv64K>
9d002b14:	00000000 	nop
9d002b18:	af82806c 	sw	v0,-32660(gp)
					SNTPState = SM_SHORT_WAIT;
9d002b1c:	2402000b 	li	v0,11
9d002b20:	0b400a73 	j	9d0029cc <SNTPClient+0x9c>
9d002b24:	af828064 	sw	v0,-32668(gp)

	switch(SNTPState)
	{
		case SM_HOME:
			// Obtain ownership of the DNS resolution module
			if(!DNSBeginUsage())
9d002b28:	0f400fe6 	jal	9d003f98 <DNSBeginUsage>
9d002b2c:	00000000 	nop
9d002b30:	1040ffa7 	beqz	v0,9d0029d0 <SNTPClient+0xa0>
9d002b34:	8fbf0044 	lw	ra,68(sp)
				break;

			// Obtain the IP address associated with the server name
			DNSResolveROM((ROM BYTE*)NTP_SERVER, DNS_TYPE_A);
9d002b38:	3c049d01 	lui	a0,0x9d01
9d002b3c:	2484dbe8 	addiu	a0,a0,-9240
9d002b40:	0f401001 	jal	9d004004 <DNSResolve>
9d002b44:	24050001 	li	a1,1
			dwTimer = TickGet();
9d002b48:	0f400b53 	jal	9d002d4c <TickGet>
9d002b4c:	00000000 	nop
9d002b50:	af82806c 	sw	v0,-32660(gp)
			SNTPState = SM_NAME_RESOLVE;
9d002b54:	24020001 	li	v0,1
			break;
9d002b58:	0b400a73 	j	9d0029cc <SNTPClient+0x9c>
9d002b5c:	af828064 	sw	v0,-32668(gp)

		case SM_ARP_RESOLVE:
		case SM_ARP_RESOLVE2:
		case SM_ARP_RESOLVE3:
			// Wait for the MAC address to finish being obtained
			if(!ARPIsResolved(&Server.IPAddr, &Server.MACAddr))
9d002b60:	3c04a000 	lui	a0,0xa000
9d002b64:	3c05a000 	lui	a1,0xa000
9d002b68:	24840af0 	addiu	a0,a0,2800
9d002b6c:	0f400e57 	jal	9d00395c <ARPIsResolved>
9d002b70:	24a50af4 	addiu	a1,a1,2804
9d002b74:	10400031 	beqz	v0,9d002c3c <SNTPClient+0x30c>
9d002b78:	24020009 	li	v0,9
					SNTPState++;
				}
				break;
			}
			SNTPState = SM_UDP_SEND;
			break;
9d002b7c:	0b400a73 	j	9d0029cc <SNTPClient+0x9c>
9d002b80:	af828064 	sw	v0,-32668(gp)
9d002b84:	3c10a000 	lui	s0,0xa000

		case SM_ARP_START_RESOLVE:
		case SM_ARP_START_RESOLVE2:
		case SM_ARP_START_RESOLVE3:
			// Obtain the MAC address associated with the server's IP address 
			ARPResolve(&Server.IPAddr);
9d002b88:	0f400eb9 	jal	9d003ae4 <ARPResolve>
9d002b8c:	26040af0 	addiu	a0,s0,2800
			dwTimer = TickGet();
9d002b90:	0f400b53 	jal	9d002d4c <TickGet>
9d002b94:	00000000 	nop
9d002b98:	af82806c 	sw	v0,-32660(gp)
			SNTPState++;
9d002b9c:	8f828064 	lw	v0,-32668(gp)
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
				SNTPState = SM_HOME;	

			break;
	}
}
9d002ba0:	8fbf0044 	lw	ra,68(sp)
9d002ba4:	8fb00040 	lw	s0,64(sp)
		case SM_ARP_START_RESOLVE2:
		case SM_ARP_START_RESOLVE3:
			// Obtain the MAC address associated with the server's IP address 
			ARPResolve(&Server.IPAddr);
			dwTimer = TickGet();
			SNTPState++;
9d002ba8:	24420001 	addiu	v0,v0,1
9d002bac:	af828064 	sw	v0,-32668(gp)
			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
				SNTPState = SM_HOME;	

			break;
	}
}
9d002bb0:	03e00008 	jr	ra
9d002bb4:	27bd0048 	addiu	sp,sp,72
				}
				break;
			}
			
			// Obtain DNS resolution result
			if(!DNSEndUsage())
9d002bb8:	0f400fef 	jal	9d003fbc <DNSEndUsage>
9d002bbc:	00000000 	nop
9d002bc0:	1040ff95 	beqz	v0,9d002a18 <SNTPClient+0xe8>
9d002bc4:	24020002 	li	v0,2
				// server.  Quit and fail for a while if host is not valid.
				dwTimer = TickGetDiv64K();
				SNTPState = SM_SHORT_WAIT;
				break;
			}
			SNTPState = SM_ARP_START_RESOLVE;
9d002bc8:	0b400ae2 	j	9d002b88 <SNTPClient+0x258>
9d002bcc:	af828064 	sw	v0,-32668(gp)

			// Transmit a time request packet
			memset(&pkt, 0, sizeof(pkt));
			pkt.flags.versionNumber = 3;	// NTP Version 3
			pkt.flags.mode = 3;				// NTP Client
			pkt.orig_ts_secs = swapl(NTP_EPOCH);
9d002bd0:	24847e80 	addiu	a0,a0,32384
			}

			// Transmit a time request packet
			memset(&pkt, 0, sizeof(pkt));
			pkt.flags.versionNumber = 3;	// NTP Version 3
			pkt.flags.mode = 3;				// NTP Client
9d002bd4:	2402001b 	li	v0,27
				UDPClose(MySocket);
				break;
			}

			// Transmit a time request packet
			memset(&pkt, 0, sizeof(pkt));
9d002bd8:	afa00014 	sw	zero,20(sp)
9d002bdc:	afa00018 	sw	zero,24(sp)
9d002be0:	afa0001c 	sw	zero,28(sp)
9d002be4:	afa00020 	sw	zero,32(sp)
9d002be8:	afa00024 	sw	zero,36(sp)
9d002bec:	afa00028 	sw	zero,40(sp)
9d002bf0:	afa0002c 	sw	zero,44(sp)
9d002bf4:	afa00030 	sw	zero,48(sp)
9d002bf8:	afa00034 	sw	zero,52(sp)
9d002bfc:	afa00038 	sw	zero,56(sp)
9d002c00:	afa0003c 	sw	zero,60(sp)
			pkt.flags.versionNumber = 3;	// NTP Version 3
			pkt.flags.mode = 3;				// NTP Client
			pkt.orig_ts_secs = swapl(NTP_EPOCH);
9d002c04:	0f40260b 	jal	9d00982c <swapl>
9d002c08:	afa20010 	sw	v0,16(sp)
			UDPPutArray((BYTE*) &pkt, sizeof(pkt));	
9d002c0c:	27a40010 	addiu	a0,sp,16
9d002c10:	24050030 	li	a1,48
9d002c14:	0f401275 	jal	9d0049d4 <UDPPutArray>
9d002c18:	afa20028 	sw	v0,40(sp)
			UDPFlush();	
9d002c1c:	0f40128c 	jal	9d004a30 <UDPFlush>
9d002c20:	00000000 	nop
			
			dwTimer = TickGet();
9d002c24:	0f400b53 	jal	9d002d4c <TickGet>
9d002c28:	00000000 	nop
9d002c2c:	af82806c 	sw	v0,-32660(gp)
			SNTPState = SM_UDP_RECV;		
9d002c30:	2402000a 	li	v0,10
			break;
9d002c34:	0b400a73 	j	9d0029cc <SNTPClient+0x9c>
9d002c38:	af828064 	sw	v0,-32668(gp)
		case SM_ARP_RESOLVE3:
			// Wait for the MAC address to finish being obtained
			if(!ARPIsResolved(&Server.IPAddr, &Server.MACAddr))
			{
				// Time out if too much time is spent in this state
				if(TickGet() - dwTimer > 1*TICK_SECOND)
9d002c3c:	0f400b53 	jal	9d002d4c <TickGet>
9d002c40:	00000000 	nop
9d002c44:	8f83806c 	lw	v1,-32660(gp)
9d002c48:	3c040004 	lui	a0,0x4
9d002c4c:	3484c4b5 	ori	a0,a0,0xc4b5
9d002c50:	00431823 	subu	v1,v0,v1
9d002c54:	0064182b 	sltu	v1,v1,a0
9d002c58:	1460ff5d 	bnez	v1,9d0029d0 <SNTPClient+0xa0>
9d002c5c:	8fbf0044 	lw	ra,68(sp)
				{
					// Retransmit ARP request by going to next SM_ARP_START_RESOLVE state or fail by going to SM_ARP_RESOLVE_FAIL state.
					SNTPState++;
9d002c60:	8f828064 	lw	v0,-32668(gp)
9d002c64:	24420001 	addiu	v0,v0,1
9d002c68:	0b400a73 	j	9d0029cc <SNTPClient+0x9c>
9d002c6c:	af828064 	sw	v0,-32668(gp)

9d002c70 <GetTickCopy>:

  Returns:
  	None
  ***************************************************************************/
static void GetTickCopy(void)
{
9d002c70:	27bdfff8 	addiu	sp,sp,-8
9d002c74:	3c05bf88 	lui	a1,0xbf88
9d002c78:	3c0bbf88 	lui	t3,0xbf88
9d002c7c:	3c0abf80 	lui	t2,0xbf80
9d002c80:	3c09bf88 	lui	t1,0xbf88
#else	// PIC32
	do
	{
		DWORD dwTempTicks;
		
		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt
9d002c84:	24030010 	li	v1,16
9d002c88:	aca31068 	sw	v1,4200(a1)
		Nop();
9d002c8c:	00000040 	ssnop
		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt
9d002c90:	ad631064 	sw	v1,4196(t3)
		
		// Get low 2 bytes
		((volatile WORD*)vTickReading)[0] = TMR1;
9d002c94:	8d420610 	lw	v0,1552(t2)
9d002c98:	3042ffff 	andi	v0,v0,0xffff
9d002c9c:	a7828074 	sh	v0,-32652(gp)
		
		// Correct corner case where interrupt increments byte[4+] but 
		// TMR1 hasn't rolled over to 0x0000 yet
		dwTempTicks = dwInternalTicks;
9d002ca0:	8f828070 	lw	v0,-32656(gp)
		// Get high 4 bytes
		vTickReading[2] = ((BYTE*)&dwTempTicks)[0];
		vTickReading[3] = ((BYTE*)&dwTempTicks)[1];
		vTickReading[4] = ((BYTE*)&dwTempTicks)[2];
		vTickReading[5] = ((BYTE*)&dwTempTicks)[3];
	} while(IFS0bits.T1IF);
9d002ca4:	8d241030 	lw	a0,4144(t1)
		// Get low 2 bytes
		((volatile WORD*)vTickReading)[0] = TMR1;
		
		// Correct corner case where interrupt increments byte[4+] but 
		// TMR1 hasn't rolled over to 0x0000 yet
		dwTempTicks = dwInternalTicks;
9d002ca8:	afa20000 	sw	v0,0(sp)
		// Get high 4 bytes
		vTickReading[2] = ((BYTE*)&dwTempTicks)[0];
		vTickReading[3] = ((BYTE*)&dwTempTicks)[1];
		vTickReading[4] = ((BYTE*)&dwTempTicks)[2];
		vTickReading[5] = ((BYTE*)&dwTempTicks)[3];
	} while(IFS0bits.T1IF);
9d002cac:	30840010 	andi	a0,a0,0x10
		#elif !defined(__PIC32_FEATURE_SET__)
			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version.
		#endif
		
		// Get high 4 bytes
		vTickReading[2] = ((BYTE*)&dwTempTicks)[0];
9d002cb0:	304800ff 	andi	t0,v0,0xff
		vTickReading[3] = ((BYTE*)&dwTempTicks)[1];
9d002cb4:	7c473a00 	ext	a3,v0,0x8,0x8
		vTickReading[4] = ((BYTE*)&dwTempTicks)[2];
9d002cb8:	7c463c00 	ext	a2,v0,0x10,0x8
		vTickReading[5] = ((BYTE*)&dwTempTicks)[3];
	} while(IFS0bits.T1IF);
9d002cbc:	1480fff2 	bnez	a0,9d002c88 <GetTickCopy+0x18>
9d002cc0:	00021602 	srl	v0,v0,0x18
9d002cc4:	a3828079 	sb	v0,-32647(gp)
	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt
9d002cc8:	24020010 	li	v0,16
		// Get high 4 bytes
		vTickReading[2] = ((BYTE*)&dwTempTicks)[0];
		vTickReading[3] = ((BYTE*)&dwTempTicks)[1];
		vTickReading[4] = ((BYTE*)&dwTempTicks)[2];
		vTickReading[5] = ((BYTE*)&dwTempTicks)[3];
	} while(IFS0bits.T1IF);
9d002ccc:	a3888076 	sb	t0,-32650(gp)
9d002cd0:	a3878077 	sb	a3,-32649(gp)
9d002cd4:	a3868078 	sb	a2,-32648(gp)
	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt
9d002cd8:	aca21068 	sw	v0,4200(a1)
#endif
}
9d002cdc:	03e00008 	jr	ra
9d002ce0:	27bd0008 	addiu	sp,sp,8

9d002ce4 <TickInit>:
    T0CON = 0x87;

#else
	// Use Timer 1 for 16-bit and 32-bit processors
	// 1:256 prescale
	T1CONbits.TCKPS = 3;
9d002ce4:	3c02bf80 	lui	v0,0xbf80
9d002ce8:	8c430600 	lw	v1,1536(v0)
9d002cec:	24040003 	li	a0,3
	// Base
	PR1 = 0xFFFF;
9d002cf0:	3405ffff 	li	a1,0xffff
    T0CON = 0x87;

#else
	// Use Timer 1 for 16-bit and 32-bit processors
	// 1:256 prescale
	T1CONbits.TCKPS = 3;
9d002cf4:	7c832904 	ins	v1,a0,0x4,0x2
9d002cf8:	ac430600 	sw	v1,1536(v0)
	// Base
	PR1 = 0xFFFF;
9d002cfc:	3c03bf80 	lui	v1,0xbf80
9d002d00:	ac650620 	sw	a1,1568(v1)
	// Clear counter
	TMR1 = 0;
9d002d04:	3c03bf80 	lui	v1,0xbf80
9d002d08:	ac600610 	sw	zero,1552(v1)
	#if defined(__C30__)
		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low)
		IFS0bits.T1IF = 0;
		IEC0bits.T1IE = 1;
	#else
		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low)
9d002d0c:	3c04bf88 	lui	a0,0xbf88
9d002d10:	8c8510a0 	lw	a1,4256(a0)
9d002d14:	24060002 	li	a2,2
		IFS0CLR = _IFS0_T1IF_MASK;
9d002d18:	24030010 	li	v1,16
	#if defined(__C30__)
		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low)
		IFS0bits.T1IF = 0;
		IEC0bits.T1IE = 1;
	#else
		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low)
9d002d1c:	7cc52084 	ins	a1,a2,0x2,0x3
9d002d20:	ac8510a0 	sw	a1,4256(a0)
		IFS0CLR = _IFS0_T1IF_MASK;
9d002d24:	3c04bf88 	lui	a0,0xbf88
9d002d28:	ac831034 	sw	v1,4148(a0)
		IEC0SET = _IEC0_T1IE_MASK;
9d002d2c:	3c04bf88 	lui	a0,0xbf88
9d002d30:	ac831068 	sw	v1,4200(a0)
	#endif

	// Start timer
	T1CONbits.TON = 1;
9d002d34:	8c430600 	lw	v1,1536(v0)
9d002d38:	24040001 	li	a0,1
9d002d3c:	7c837bc4 	ins	v1,a0,0xf,0x1
9d002d40:	ac430600 	sw	v1,1536(v0)
#endif
}
9d002d44:	03e00008 	jr	ra
9d002d48:	00000000 	nop

9d002d4c <TickGet>:

  Returns:
  	Lower 32 bits of the current Tick value.
  ***************************************************************************/
DWORD TickGet(void)
{
9d002d4c:	27bdffe8 	addiu	sp,sp,-24
9d002d50:	afbf0014 	sw	ra,20(sp)
	GetTickCopy();
9d002d54:	0f400b1c 	jal	9d002c70 <GetTickCopy>
9d002d58:	00000000 	nop
	return *((DWORD*)&vTickReading[0]);
}
9d002d5c:	8fbf0014 	lw	ra,20(sp)
9d002d60:	8f828074 	lw	v0,-32652(gp)
9d002d64:	03e00008 	jr	ra
9d002d68:	27bd0018 	addiu	sp,sp,24

9d002d6c <TickGetDiv256>:

  Returns:
  	Middle 32 bits of the current Tick value.
  ***************************************************************************/
DWORD TickGetDiv256(void)
{
9d002d6c:	27bdffe0 	addiu	sp,sp,-32
9d002d70:	afbf001c 	sw	ra,28(sp)
	DWORD dw;

	GetTickCopy();
9d002d74:	0f400b1c 	jal	9d002c70 <GetTickCopy>
9d002d78:	00000000 	nop
	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one 
9d002d7c:	93828075 	lbu	v0,-32651(gp)
	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned 
	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC.
	((BYTE*)&dw)[3] = vTickReading[4];
	
	return dw;
}
9d002d80:	8fbf001c 	lw	ra,28(sp)
DWORD TickGetDiv256(void)
{
	DWORD dw;

	GetTickCopy();
	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one 
9d002d84:	a3a20010 	sb	v0,16(sp)
	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned 
9d002d88:	93828076 	lbu	v0,-32650(gp)
9d002d8c:	a3a20011 	sb	v0,17(sp)
	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC.
9d002d90:	93828077 	lbu	v0,-32649(gp)
9d002d94:	a3a20012 	sb	v0,18(sp)
	((BYTE*)&dw)[3] = vTickReading[4];
9d002d98:	93828078 	lbu	v0,-32648(gp)
9d002d9c:	a3a20013 	sb	v0,19(sp)
	
	return dw;
}
9d002da0:	8fa20010 	lw	v0,16(sp)
9d002da4:	03e00008 	jr	ra
9d002da8:	27bd0020 	addiu	sp,sp,32

9d002dac <TickGetDiv64K>:

  Returns:
  	Upper 32 bits of the current Tick value.
  ***************************************************************************/
DWORD TickGetDiv64K(void)
{
9d002dac:	27bdffe0 	addiu	sp,sp,-32
9d002db0:	afbf001c 	sw	ra,28(sp)
	DWORD dw;

	GetTickCopy();
9d002db4:	0f400b1c 	jal	9d002c70 <GetTickCopy>
9d002db8:	00000000 	nop
	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one 
9d002dbc:	93828076 	lbu	v0,-32650(gp)
	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned 
	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC.
	((BYTE*)&dw)[3] = vTickReading[5];
	
	return dw;
}
9d002dc0:	8fbf001c 	lw	ra,28(sp)
DWORD TickGetDiv64K(void)
{
	DWORD dw;

	GetTickCopy();
	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one 
9d002dc4:	a3a20010 	sb	v0,16(sp)
	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned 
9d002dc8:	93828077 	lbu	v0,-32649(gp)
9d002dcc:	a3a20011 	sb	v0,17(sp)
	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC.
9d002dd0:	93828078 	lbu	v0,-32648(gp)
9d002dd4:	a3a20012 	sb	v0,18(sp)
	((BYTE*)&dw)[3] = vTickReading[5];
9d002dd8:	93828079 	lbu	v0,-32647(gp)
9d002ddc:	a3a20013 	sb	v0,19(sp)
	
	return dw;
}
9d002de0:	8fa20010 	lw	v0,16(sp)
9d002de4:	03e00008 	jr	ra
9d002de8:	27bd0020 	addiu	sp,sp,32

9d002dec <_T1Interrupt>:
  Returns:
  	None
  ***************************************************************************/
#elif defined(__PIC32MX__)
void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void)
{
9d002dec:	415de800 	rdpgpr	sp,sp
9d002df0:	401a7000 	mfc0	k0,c0_epc
9d002df4:	401b6000 	mfc0	k1,c0_status
9d002df8:	27bdfff0 	addiu	sp,sp,-16
9d002dfc:	afbb0008 	sw	k1,8(sp)
9d002e00:	7c1b7844 	ins	k1,zero,0x1,0xf
9d002e04:	377b0800 	ori	k1,k1,0x800
9d002e08:	afba000c 	sw	k0,12(sp)
9d002e0c:	409b6000 	mtc0	k1,c0_status
9d002e10:	afa20000 	sw	v0,0(sp)
	// Increment internal high tick counter
	dwInternalTicks++;
9d002e14:	8f828070 	lw	v0,-32656(gp)
  Returns:
  	None
  ***************************************************************************/
#elif defined(__PIC32MX__)
void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void)
{
9d002e18:	afa30004 	sw	v1,4(sp)
	// Increment internal high tick counter
	dwInternalTicks++;

	// Reset interrupt flag
	IFS0CLR = _IFS0_T1IF_MASK;
9d002e1c:	24030010 	li	v1,16
  ***************************************************************************/
#elif defined(__PIC32MX__)
void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void)
{
	// Increment internal high tick counter
	dwInternalTicks++;
9d002e20:	24420001 	addiu	v0,v0,1
9d002e24:	af828070 	sw	v0,-32656(gp)

	// Reset interrupt flag
	IFS0CLR = _IFS0_T1IF_MASK;
9d002e28:	3c02bf88 	lui	v0,0xbf88
9d002e2c:	ac431034 	sw	v1,4148(v0)
}
9d002e30:	8fa30004 	lw	v1,4(sp)
9d002e34:	8fa20000 	lw	v0,0(sp)
9d002e38:	41606000 	di
9d002e3c:	000000c0 	ehb
9d002e40:	8fba000c 	lw	k0,12(sp)
9d002e44:	8fbb0008 	lw	k1,8(sp)
9d002e48:	409a7000 	mtc0	k0,c0_epc
9d002e4c:	27bd0010 	addiu	sp,sp,16
9d002e50:	41dde800 	wrpgpr	sp,sp
9d002e54:	409b6000 	mtc0	k1,c0_status
9d002e58:	42000018 	eret

9d002e5c <StackInit>:
 * Note:            This function must be called before any of the
 *                  stack or its component routines are used.
 *
 ********************************************************************/
void StackInit(void)
{
9d002e5c:	27bdffe8 	addiu	sp,sp,-24
9d002e60:	afb00010 	sw	s0,16(sp)
#if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT)
    /*
     * If DHCP or IP Gleaning is enabled,
     * startup in Config Mode.
     */
    AppConfig.Flags.bInConfigMode = TRUE;
9d002e64:	3c10a001 	lui	s0,0xa001
9d002e68:	26109a5c 	addiu	s0,s0,-26020
9d002e6c:	9202002c 	lbu	v0,44(s0)
9d002e70:	24030001 	li	v1,1
 * Note:            This function must be called before any of the
 *                  stack or its component routines are used.
 *
 ********************************************************************/
void StackInit(void)
{
9d002e74:	afbf0014 	sw	ra,20(sp)
#if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT)
    /*
     * If DHCP or IP Gleaning is enabled,
     * startup in Config Mode.
     */
    AppConfig.Flags.bInConfigMode = TRUE;
9d002e78:	7c6239c4 	ins	v0,v1,0x7,0x1
 *                  stack or its component routines are used.
 *
 ********************************************************************/
void StackInit(void)
{
    smStack                     = SM_STACK_IDLE;
9d002e7c:	af808080 	sw	zero,-32640(gp)
    AppConfig.Flags.bInConfigMode = TRUE;

#endif

	// Seed the LFSRRand() function
	LFSRSeedRand(GenerateRandomDWORD());
9d002e80:	0f402519 	jal	9d009464 <GenerateRandomDWORD>
9d002e84:	a202002c 	sb	v0,44(s0)
9d002e88:	0f402505 	jal	9d009414 <LFSRSeedRand>
9d002e8c:	00402021 	move	a0,v0

    MACInit();
9d002e90:	0f400c60 	jal	9d003180 <MACInit>
9d002e94:	00000000 	nop

#if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG)
    WFEasyConfigInit();
#endif    

    ARPInit();
9d002e98:	0f400e4c 	jal	9d003930 <ARPInit>
9d002e9c:	00000000 	nop

#if defined(STACK_USE_UDP)
    UDPInit();
9d002ea0:	0f4011d1 	jal	9d004744 <UDPInit>
9d002ea4:	00000000 	nop
#endif

#if defined(STACK_USE_TCP)
    TCPInit();
9d002ea8:	0f40168e 	jal	9d005a38 <TCPInit>
9d002eac:	00000000 	nop
#if defined(STACK_USE_SNMP_SERVER)
	SNMPInit();
#endif

#if defined(STACK_USE_DHCP_CLIENT)
	DHCPInit(0);
9d002eb0:	0f40231e 	jal	9d008c78 <DHCPInit>
9d002eb4:	00002021 	move	a0,zero
    if(!AppConfig.Flags.bIsDHCPEnabled)
9d002eb8:	9202002c 	lbu	v0,44(s0)
9d002ebc:	30420040 	andi	v0,v0,0x40
9d002ec0:	304200ff 	andi	v0,v0,0xff
9d002ec4:	10400004 	beqz	v0,9d002ed8 <StackInit+0x7c>
9d002ec8:	8fbf0014 	lw	ra,20(sp)
#endif

#if defined(STACK_USE_RANDOM)
	RandomInit();
#endif
}
9d002ecc:	8fb00010 	lw	s0,16(sp)
9d002ed0:	03e00008 	jr	ra
9d002ed4:	27bd0018 	addiu	sp,sp,24
9d002ed8:	8fb00010 	lw	s0,16(sp)

#if defined(STACK_USE_DHCP_CLIENT)
	DHCPInit(0);
    if(!AppConfig.Flags.bIsDHCPEnabled)
    {
        DHCPDisable(0);
9d002edc:	00002021 	move	a0,zero
9d002ee0:	0b402349 	j	9d008d24 <DHCPDisable>
9d002ee4:	27bd0018 	addiu	sp,sp,24

9d002ee8 <StackTask>:
 *                  This function must be called periodically to
 *                  ensure timely responses.
 *
 ********************************************************************/
void StackTask(void)
{
9d002ee8:	27bdffd0 	addiu	sp,sp,-48
9d002eec:	afb30024 	sw	s3,36(sp)
	#if defined(STACK_USE_DHCP_CLIENT)
	// Normally, an application would not include  DHCP module
	// if it is not enabled. But in case some one wants to disable
	// DHCP module at run-time, remember to not clear our IP
	// address if link is removed.
	if(AppConfig.Flags.bIsDHCPEnabled)
9d002ef0:	3c13a001 	lui	s3,0xa001
 *                  This function must be called periodically to
 *                  ensure timely responses.
 *
 ********************************************************************/
void StackTask(void)
{
9d002ef4:	afb20020 	sw	s2,32(sp)
	#if defined(STACK_USE_DHCP_CLIENT)
	// Normally, an application would not include  DHCP module
	// if it is not enabled. But in case some one wants to disable
	// DHCP module at run-time, remember to not clear our IP
	// address if link is removed.
	if(AppConfig.Flags.bIsDHCPEnabled)
9d002ef8:	26729a5c 	addiu	s2,s3,-26020
9d002efc:	9242002c 	lbu	v0,44(s2)
 *                  This function must be called periodically to
 *                  ensure timely responses.
 *
 ********************************************************************/
void StackTask(void)
{
9d002f00:	afbf002c 	sw	ra,44(sp)
9d002f04:	afb40028 	sw	s4,40(sp)
	#if defined(STACK_USE_DHCP_CLIENT)
	// Normally, an application would not include  DHCP module
	// if it is not enabled. But in case some one wants to disable
	// DHCP module at run-time, remember to not clear our IP
	// address if link is removed.
	if(AppConfig.Flags.bIsDHCPEnabled)
9d002f08:	30420040 	andi	v0,v0,0x40
9d002f0c:	304200ff 	andi	v0,v0,0xff
 *                  This function must be called periodically to
 *                  ensure timely responses.
 *
 ********************************************************************/
void StackTask(void)
{
9d002f10:	afb1001c 	sw	s1,28(sp)
	#if defined(STACK_USE_DHCP_CLIENT)
	// Normally, an application would not include  DHCP module
	// if it is not enabled. But in case some one wants to disable
	// DHCP module at run-time, remember to not clear our IP
	// address if link is removed.
	if(AppConfig.Flags.bIsDHCPEnabled)
9d002f14:	14400049 	bnez	v0,9d00303c <StackTask+0x154>
9d002f18:	afb00018 	sw	s0,24(sp)
    AutoIPTasks();
    #endif

	#if defined(STACK_USE_TCP)
	// Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc)
	TCPTick();
9d002f1c:	0f401ac8 	jal	9d006b20 <TCPTick>
9d002f20:	3c11a001 	lui	s1,0xa001
	#endif


	#if defined(STACK_USE_UDP)
	UDPTask();
9d002f24:	0f4011e6 	jal	9d004798 <UDPTask>
9d002f28:	3c10a001 	lui	s0,0xa001
				
				#if defined(STACK_USE_UDP)
				if(cIPFrameType == IP_PROT_UDP)
				{
					// Stop processing packets if we came upon a UDP frame with application data in it
					if(UDPProcess(&remoteNode, &tempLocalIP, dataCount))
9d002f2c:	26349a90 	addiu	s4,s1,-25968

		// We are about to fetch a new packet, make sure that the 
		// UDP module knows that any old RX data it has laying 
		// around will now be gone.
		#if defined(STACK_USE_UDP)
			UDPDiscard();
9d002f30:	0f40132c 	jal	9d004cb0 <UDPDiscard>
9d002f34:	00000000 	nop
		#endif

		// Fetch a packet (throws old one away, if not thrown away 
		// yet)
		if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType))
9d002f38:	26049a94 	addiu	a0,s0,-25964
9d002f3c:	0f400d96 	jal	9d003658 <MACGetHeader>
9d002f40:	27a50010 	addiu	a1,sp,16
9d002f44:	10400016 	beqz	v0,9d002fa0 <StackTask+0xb8>
9d002f48:	93a20010 	lbu	v0,16(sp)
			if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u)
				continue;
		#endif

		// Dispatch the packet to the appropriate handler
		switch(cFrameType)
9d002f4c:	1440001c 	bnez	v0,9d002fc0 <StackTask+0xd8>
9d002f50:	24030006 	li	v1,6
			case MAC_ARP:
				ARPProcess();
				break;
	
			case MAC_IP:
				if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount))
9d002f54:	27a40014 	addiu	a0,sp,20
9d002f58:	26259a90 	addiu	a1,s1,-25968
9d002f5c:	27a60011 	addiu	a2,sp,17
9d002f60:	0f402479 	jal	9d0091e4 <IPGetHeader>
9d002f64:	27a70012 	addiu	a3,sp,18
9d002f68:	1040fff1 	beqz	v0,9d002f30 <StackTask+0x48>
9d002f6c:	93a20011 	lbu	v0,17(sp)
					break;

				#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
				if(cIPFrameType == IP_PROT_ICMP)
9d002f70:	24030001 	li	v1,1
9d002f74:	10430018 	beq	v0,v1,9d002fd8 <StackTask+0xf0>
9d002f78:	24030006 	li	v1,6
					break;
				}
				#endif
				
				#if defined(STACK_USE_TCP)
				if(cIPFrameType == IP_PROT_TCP)
9d002f7c:	10430029 	beq	v0,v1,9d003024 <StackTask+0x13c>
9d002f80:	24030011 	li	v1,17
					break;
				}
				#endif
				
				#if defined(STACK_USE_UDP)
				if(cIPFrameType == IP_PROT_UDP)
9d002f84:	1443ffea 	bne	v0,v1,9d002f30 <StackTask+0x48>
9d002f88:	97a60012 	lhu	a2,18(sp)
				{
					// Stop processing packets if we came upon a UDP frame with application data in it
					if(UDPProcess(&remoteNode, &tempLocalIP, dataCount))
9d002f8c:	02802021 	move	a0,s4
9d002f90:	0f40133e 	jal	9d004cf8 <UDPProcess>
9d002f94:	27a50014 	addiu	a1,sp,20
9d002f98:	1040ffe5 	beqz	v0,9d002f30 <StackTask+0x48>
9d002f9c:	00000000 	nop
				#endif

				break;
		}
	}
}
9d002fa0:	8fbf002c 	lw	ra,44(sp)
9d002fa4:	8fb40028 	lw	s4,40(sp)
9d002fa8:	8fb30024 	lw	s3,36(sp)
9d002fac:	8fb20020 	lw	s2,32(sp)
9d002fb0:	8fb1001c 	lw	s1,28(sp)
9d002fb4:	8fb00018 	lw	s0,24(sp)
9d002fb8:	03e00008 	jr	ra
9d002fbc:	27bd0030 	addiu	sp,sp,48
			if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u)
				continue;
		#endif

		// Dispatch the packet to the appropriate handler
		switch(cFrameType)
9d002fc0:	1443ffdb 	bne	v0,v1,9d002f30 <StackTask+0x48>
9d002fc4:	00000000 	nop
		{
			case MAC_ARP:
				ARPProcess();
9d002fc8:	0f400edc 	jal	9d003b70 <ARPProcess>
9d002fcc:	00000000 	nop
				break;
9d002fd0:	0b400bcc 	j	9d002f30 <StackTask+0x48>
9d002fd4:	00000000 	nop
						}
					}
					#endif

					// Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees
					if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) ||
9d002fd8:	8a420003 	lwl	v0,3(s2)
9d002fdc:	8fa30014 	lw	v1,20(sp)
9d002fe0:	9a629a5c 	lwr	v0,-26020(s3)
9d002fe4:	1062000a 	beq	v1,v0,9d003010 <StackTask+0x128>
9d002fe8:	2404ffff 	li	a0,-1
9d002fec:	10640009 	beq	v1,a0,9d003014 <StackTask+0x12c>
9d002ff0:	97a50012 	lhu	a1,18(sp)
						(tempLocalIP.Val == 0xFFFFFFFF) ||
#if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD)
                                                (tempLocalIP.Val == 0xFB0000E0) ||
#endif
						(tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val)))
9d002ff4:	8a440007 	lwl	a0,7(s2)
9d002ff8:	9a440004 	lwr	a0,4(s2)
9d002ffc:	00042827 	nor	a1,zero,a0
9d003000:	00821024 	and	v0,a0,v0
9d003004:	00a21025 	or	v0,a1,v0
					}
					#endif

					// Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees
					if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) ||
						(tempLocalIP.Val == 0xFFFFFFFF) ||
9d003008:	1462ffc9 	bne	v1,v0,9d002f30 <StackTask+0x48>
9d00300c:	00000000 	nop
#if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD)
                                                (tempLocalIP.Val == 0xFB0000E0) ||
#endif
						(tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val)))
					{
						ICMPProcess(&remoteNode, dataCount);
9d003010:	97a50012 	lhu	a1,18(sp)
9d003014:	0f400f37 	jal	9d003cdc <ICMPProcess>
9d003018:	26249a90 	addiu	a0,s1,-25968
9d00301c:	0b400bcc 	j	9d002f30 <StackTask+0x48>
9d003020:	00000000 	nop
				#endif
				
				#if defined(STACK_USE_TCP)
				if(cIPFrameType == IP_PROT_TCP)
				{
					TCPProcess(&remoteNode, &tempLocalIP, dataCount);
9d003024:	97a60012 	lhu	a2,18(sp)
9d003028:	02802021 	move	a0,s4
9d00302c:	0f401d4e 	jal	9d007538 <TCPProcess>
9d003030:	27a50014 	addiu	a1,sp,20
					break;
9d003034:	0b400bcc 	j	9d002f30 <StackTask+0x48>
9d003038:	00000000 	nop
	if(AppConfig.Flags.bIsDHCPEnabled)
	{
		static BOOL bLastLinkState = FALSE;
		BOOL bCurrentLinkState;
		
		bCurrentLinkState = MACIsLinked();
9d00303c:	0f400ce6 	jal	9d003398 <MACIsLinked>
9d003040:	00000000 	nop
		if(bCurrentLinkState != bLastLinkState)
9d003044:	8f83807c 	lw	v1,-32644(gp)
9d003048:	10430003 	beq	v0,v1,9d003058 <StackTask+0x170>
9d00304c:	00000000 	nop
		{
			bLastLinkState = bCurrentLinkState;
			if(!bCurrentLinkState)
9d003050:	1040000b 	beqz	v0,9d003080 <StackTask+0x198>
9d003054:	af82807c 	sw	v0,-32644(gp)
	
		// DHCP must be called all the time even after IP configuration is
		// discovered.
		// DHCP has to account lease expiration time and renew the configuration
		// time.
		DHCPTask();
9d003058:	0f40235e 	jal	9d008d78 <DHCPTask>
9d00305c:	00000000 	nop
		
		if(DHCPIsBound(0))
9d003060:	0f40235a 	jal	9d008d68 <DHCPIsBound>
9d003064:	00002021 	move	a0,zero
9d003068:	1040ffac 	beqz	v0,9d002f1c <StackTask+0x34>
9d00306c:	00000000 	nop
			AppConfig.Flags.bInConfigMode = FALSE;
9d003070:	9242002c 	lbu	v0,44(s2)
9d003074:	7c0239c4 	ins	v0,zero,0x7,0x1
9d003078:	0b400bc7 	j	9d002f1c <StackTask+0x34>
9d00307c:	a242002c 	sb	v0,44(s2)
		if(bCurrentLinkState != bLastLinkState)
		{
			bLastLinkState = bCurrentLinkState;
			if(!bCurrentLinkState)
			{
				AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
9d003080:	8a420017 	lwl	v0,23(s2)
				AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
				AppConfig.Flags.bInConfigMode = TRUE;
9d003084:	24030001 	li	v1,1
				DHCPInit(0);
9d003088:	00002021 	move	a0,zero
		if(bCurrentLinkState != bLastLinkState)
		{
			bLastLinkState = bCurrentLinkState;
			if(!bCurrentLinkState)
			{
				AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
9d00308c:	9a420014 	lwr	v0,20(s2)
9d003090:	aa420003 	swl	v0,3(s2)
9d003094:	ba629a5c 	swr	v0,-26020(s3)
				AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
9d003098:	8a42001b 	lwl	v0,27(s2)
9d00309c:	9a420018 	lwr	v0,24(s2)
9d0030a0:	aa420007 	swl	v0,7(s2)
9d0030a4:	ba420004 	swr	v0,4(s2)
				AppConfig.Flags.bInConfigMode = TRUE;
9d0030a8:	9242002c 	lbu	v0,44(s2)
9d0030ac:	7c6239c4 	ins	v0,v1,0x7,0x1
				DHCPInit(0);
9d0030b0:	0f40231e 	jal	9d008c78 <DHCPInit>
9d0030b4:	a242002c 	sb	v0,44(s2)
9d0030b8:	0b400c16 	j	9d003058 <StackTask+0x170>
9d0030bc:	00000000 	nop

9d0030c0 <StackApplications>:
 * Note:            This function must be called periodically to
 *                  ensure timely responses.
 *
 ********************************************************************/
void StackApplications(void)
{
9d0030c0:	27bdffe8 	addiu	sp,sp,-24
9d0030c4:	afbf0014 	sw	ra,20(sp)
	#if defined(STACK_USE_ANNOUNCE)
	DiscoveryTask();
	#endif
	
	#if defined(STACK_USE_NBNS)
	NBNSTask();
9d0030c8:	0f40269c 	jal	9d009a70 <NBNSTask>
9d0030cc:	00000000 	nop
	#if defined(STACK_USE_TELNET_SERVER)
	TelnetTask();
	#endif
	
	#if defined(STACK_USE_REBOOT_SERVER)
	RebootTask();
9d0030d0:	0f402663 	jal	9d00998c <RebootTask>
9d0030d4:	00000000 	nop
	#endif
	
	#if defined(STACK_USE_UART2TCP_BRIDGE)
	UART2TCPBridgeTask();
	#endif
}
9d0030d8:	8fbf0014 	lw	ra,20(sp)
	#if defined(STACK_USE_REBOOT_SERVER)
	RebootTask();
	#endif
	
	#if defined(STACK_USE_SNTP_CLIENT)
	SNTPClient();
9d0030dc:	0b400a4c 	j	9d002930 <SNTPClient>
9d0030e0:	27bd0018 	addiu	sp,sp,24

9d0030e4 <_TxAckCallback>:
{
	volatile sEthTxDcpt*	pDcpt;

	pDcpt=(sEthTxDcpt*)((char*)pPktBuff-offsetof(sEthTxDcpt, dataBuff));

	pDcpt->txBusy=0;
9d0030e4:	ac80fffc 	sw	zero,-4(a0)

}
9d0030e8:	03e00008 	jr	ra
9d0030ec:	00000000 	nop

9d0030f0 <_LinkReconfigure>:
 * Overview:        Performs re-configuration after auto-negotiation performed.
 * 
 * Note:            None
 ********************************************************************/
static int _LinkReconfigure(void)
{
9d0030f0:	27bdffe0 	addiu	sp,sp,-32
9d0030f4:	afb00018 	sw	s0,24(sp)
9d0030f8:	afbf001c 	sw	ra,28(sp)
	eEthMacPauseType pauseType;
	eEthRes		     phyRes;
	int	        	 success=0;


	phyRes=EthPhyNegotiationComplete(0);	// see if negotiation complete
9d0030fc:	0f4027cb 	jal	9d009f2c <EthPhyNegotiationComplete>
9d003100:	00002021 	move	a0,zero
	if(phyRes==ETH_RES_OK)
9d003104:	10400006 	beqz	v0,9d003120 <_LinkReconfigure+0x30>
9d003108:	00008021 	move	s0,zero
			success=1;
		}
	}

	return success;
}
9d00310c:	8fbf001c 	lw	ra,28(sp)
9d003110:	02001021 	move	v0,s0
9d003114:	8fb00018 	lw	s0,24(sp)
9d003118:	03e00008 	jr	ra
9d00311c:	27bd0020 	addiu	sp,sp,32


	phyRes=EthPhyNegotiationComplete(0);	// see if negotiation complete
	if(phyRes==ETH_RES_OK)
	{	
		linkStat=EthPhyGetNegotiationResult(&linkFlags, &pauseType);
9d003120:	27a40010 	addiu	a0,sp,16
9d003124:	0f402835 	jal	9d00a0d4 <EthPhyGetNegotiationResult>
9d003128:	27a50014 	addiu	a1,sp,20
		if(linkStat&ETH_LINK_ST_UP)
9d00312c:	30420001 	andi	v0,v0,0x1
9d003130:	1040fff7 	beqz	v0,9d003110 <_LinkReconfigure+0x20>
9d003134:	8fbf001c 	lw	ra,28(sp)
		{	// negotiation succeeded; properly update the MAC
            linkFlags|=(EthPhyGetHwConfigFlags()&ETH_PHY_CFG_RMII)?ETH_OPEN_RMII:ETH_OPEN_MII;                       
9d003138:	0f4027bf 	jal	9d009efc <EthPhyGetHwConfigFlags>
9d00313c:	24100001 	li	s0,1
9d003140:	30420001 	andi	v0,v0,0x1
9d003144:	24030400 	li	v1,1024
9d003148:	0002180a 	movz	v1,zero,v0
9d00314c:	8fa20010 	lw	v0,16(sp)
			EthMACOpen(linkFlags, pauseType);
9d003150:	8fa50014 	lw	a1,20(sp)
	if(phyRes==ETH_RES_OK)
	{	
		linkStat=EthPhyGetNegotiationResult(&linkFlags, &pauseType);
		if(linkStat&ETH_LINK_ST_UP)
		{	// negotiation succeeded; properly update the MAC
            linkFlags|=(EthPhyGetHwConfigFlags()&ETH_PHY_CFG_RMII)?ETH_OPEN_RMII:ETH_OPEN_MII;                       
9d003154:	00621025 	or	v0,v1,v0
			EthMACOpen(linkFlags, pauseType);
9d003158:	00402021 	move	a0,v0
9d00315c:	0f4033b1 	jal	9d00cec4 <EthMACOpen>
9d003160:	afa20010 	sw	v0,16(sp)
			success=1;
		}
	}

	return success;
}
9d003164:	8fbf001c 	lw	ra,28(sp)
9d003168:	02001021 	move	v0,s0
9d00316c:	8fb00018 	lw	s0,24(sp)
9d003170:	03e00008 	jr	ra
9d003174:	27bd0020 	addiu	sp,sp,32

9d003178 <_MacAllocCallback>:
 * 
 * Note:            None
 ********************************************************************/
static void* _MacAllocCallback( size_t nitems, size_t size, void* param )
{
    return calloc(nitems, size);
9d003178:	0b402dd9 	j	9d00b764 <calloc>
9d00317c:	00000000 	nop

9d003180 <MACInit>:
        BYTE		addr[6];            // address itself
    }SysMACAddr;        // aligned MAC address

    int		ix;
	eEthRes		ethRes, phyInitRes;
	BYTE		useFactMACAddr[6] = {0x00, 0x04, 0xa3, 0x00, 0x00, 0x00};		// to check if factory programmed MAC address needed
9d003180:	3c029d01 	lui	v0,0x9d01
9d003184:	2443dc2c 	addiu	v1,v0,-9172
9d003188:	8c45dc2c 	lw	a1,-9172(v0)
9d00318c:	94640004 	lhu	a0,4(v1)
	_CurrWrPtr=_CurrRdPtr=0;

	// set the TX/RX pointers
	for(ix=0; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
	{
		_TxDescriptors[ix].txBusy=0;
9d003190:	3c03a000 	lui	v1,0xa000
 *                  any Eth transmit or receive operation.
 *
 * Note:            None 
 *****************************************************************************/
void MACInit(void)
{
9d003194:	27bdffc0 	addiu	sp,sp,-64
	_CurrWrPtr=_CurrRdPtr=0;

	// set the TX/RX pointers
	for(ix=0; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
	{
		_TxDescriptors[ix].txBusy=0;
9d003198:	24620afc 	addiu	v0,v1,2812
9d00319c:	ac600afc 	sw	zero,2812(v1)
 *                  any Eth transmit or receive operation.
 *
 * Note:            None 
 *****************************************************************************/
void MACInit(void)
{
9d0031a0:	afbf003c 	sw	ra,60(sp)
9d0031a4:	afb10034 	sw	s1,52(sp)
9d0031a8:	afb00030 	sw	s0,48(sp)
9d0031ac:	afb20038 	sw	s2,56(sp)
	_CurrWrPtr=_CurrRdPtr=0;

	// set the TX/RX pointers
	for(ix=0; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
	{
		_TxDescriptors[ix].txBusy=0;
9d0031b0:	ac4005f0 	sw	zero,1520(v0)
        BYTE		addr[6];            // address itself
    }SysMACAddr;        // aligned MAC address

    int		ix;
	eEthRes		ethRes, phyInitRes;
	BYTE		useFactMACAddr[6] = {0x00, 0x04, 0xa3, 0x00, 0x00, 0x00};		// to check if factory programmed MAC address needed
9d0031b4:	afa50018 	sw	a1,24(sp)
9d0031b8:	a7a4001c 	sh	a0,28(sp)
	BYTE		unsetMACAddr[6] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};		// not set MAC address
9d0031bc:	a3a00020 	sb	zero,32(sp)
9d0031c0:	a3a00021 	sb	zero,33(sp)
9d0031c4:	a3a00022 	sb	zero,34(sp)
9d0031c8:	a3a00023 	sb	zero,35(sp)
9d0031cc:	a3a00024 	sb	zero,36(sp)
9d0031d0:	a3a00025 	sb	zero,37(sp)

    int		initFail=0;

	_stackMgrRxBadPkts=_stackMgrRxOkPkts=_stackMgrInGetHdr=_stackMgrRxDiscarded=0;
9d0031d4:	af808090 	sw	zero,-32624(gp)
9d0031d8:	af80808c 	sw	zero,-32628(gp)
9d0031dc:	af808084 	sw	zero,-32636(gp)
9d0031e0:	af808088 	sw	zero,-32632(gp)
	_CurrWrPtr=_CurrRdPtr=0;
9d0031e4:	af80809c 	sw	zero,-32612(gp)
9d0031e8:	af8080a0 	sw	zero,-32608(gp)
	// set the TX/RX pointers
	for(ix=0; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
	{
		_TxDescriptors[ix].txBusy=0;
	}
	_pTxCurrDcpt=_TxDescriptors+0; _TxLastDcptIx=0; _TxCurrSize=0;
9d0031ec:	af8280b8 	sw	v0,-32584(gp)
9d0031f0:	af8080c0 	sw	zero,-32576(gp)
9d0031f4:	a78080bc 	sh	zero,-32580(gp)

	_pRxCurrBuff=0; _RxCurrSize=0;	
9d0031f8:	af808098 	sw	zero,-32616(gp)
9d0031fc:	a78080b4 	sh	zero,-32588(gp)

	_linkNegotiation=_linkPresent=0;
9d003200:	af8080a4 	sw	zero,-32604(gp)
9d003204:	af8080ac 	sw	zero,-32596(gp)

		
		pauseType=(oFlags&ETH_OPEN_FDUPLEX)?ETH_MAC_PAUSE_CPBL_MASK:ETH_MAC_PAUSE_TYPE_NONE;
		
		// start the initialization sequence	
		EthInit();
9d003208:	0f403384 	jal	9d00ce10 <EthInit>
9d00320c:	af8080b0 	sw	zero,-32592(gp)

		phyInitRes=EthPhyInit(oFlags, cfgFlags, &linkFlags);
9d003210:	24050001 	li	a1,1
9d003214:	27a60010 	addiu	a2,sp,16
9d003218:	0f4028fb 	jal	9d00a3ec <EthPhyInit>
9d00321c:	2404011f 	li	a0,287
		EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
		EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT|ETH_FILT_RUNT_REJECT|ETH_FILT_ME_UCAST_ACCEPT|ETH_FILT_MCAST_ACCEPT|ETH_FILT_BCAST_ACCEPT);

		
		// set the MAC address
        memcpy(SysMACAddr.addr, AppConfig.MyMACAddr.v, sizeof(SysMACAddr.addr));
9d003220:	3c11a001 	lui	s1,0xa001

		phyInitRes=EthPhyInit(oFlags, cfgFlags, &linkFlags);
		
		// let the auto-negotiation (if any) take place
		// continue the initialization
		EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
9d003224:	3404c0ff 	li	a0,0xc0ff
		EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT|ETH_FILT_RUNT_REJECT|ETH_FILT_ME_UCAST_ACCEPT|ETH_FILT_MCAST_ACCEPT|ETH_FILT_BCAST_ACCEPT);

		
		// set the MAC address
        memcpy(SysMACAddr.addr, AppConfig.MyMACAddr.v, sizeof(SysMACAddr.addr));
9d003228:	26319a5c 	addiu	s1,s1,-26020

		phyInitRes=EthPhyInit(oFlags, cfgFlags, &linkFlags);
		
		// let the auto-negotiation (if any) take place
		// continue the initialization
		EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
9d00322c:	0f40348d 	jal	9d00d234 <EthRxFiltersClr>
9d003230:	00408021 	move	s0,v0
		EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT|ETH_FILT_RUNT_REJECT|ETH_FILT_ME_UCAST_ACCEPT|ETH_FILT_MCAST_ACCEPT|ETH_FILT_BCAST_ACCEPT);
9d003234:	0f403489 	jal	9d00d224 <EthRxFiltersSet>
9d003238:	2404005b 	li	a0,91

		
		// set the MAC address
        memcpy(SysMACAddr.addr, AppConfig.MyMACAddr.v, sizeof(SysMACAddr.addr));
9d00323c:	8a220030 	lwl	v0,48(s1)
9d003240:	92270031 	lbu	a3,49(s1)
9d003244:	92230032 	lbu	v1,50(s1)
9d003248:	9a22002d 	lwr	v0,45(s1)
        if(memcmp(SysMACAddr.addr, useFactMACAddr, sizeof(useFactMACAddr))==0 || memcmp(SysMACAddr.addr, unsetMACAddr, sizeof(unsetMACAddr))==0 )
9d00324c:	27a40028 	addiu	a0,sp,40
9d003250:	27a50018 	addiu	a1,sp,24
9d003254:	24060006 	li	a2,6
		EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
		EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT|ETH_FILT_RUNT_REJECT|ETH_FILT_ME_UCAST_ACCEPT|ETH_FILT_MCAST_ACCEPT|ETH_FILT_BCAST_ACCEPT);

		
		// set the MAC address
        memcpy(SysMACAddr.addr, AppConfig.MyMACAddr.v, sizeof(SysMACAddr.addr));
9d003258:	afa20028 	sw	v0,40(sp)
9d00325c:	a3a7002c 	sb	a3,44(sp)
        if(memcmp(SysMACAddr.addr, useFactMACAddr, sizeof(useFactMACAddr))==0 || memcmp(SysMACAddr.addr, unsetMACAddr, sizeof(unsetMACAddr))==0 )
9d003260:	0f402fc1 	jal	9d00bf04 <memcmp>
9d003264:	a3a3002d 	sb	v1,45(sp)
9d003268:	10400007 	beqz	v0,9d003288 <MACInit+0x108>
9d00326c:	3c02bf89 	lui	v0,0xbf89
9d003270:	27a40028 	addiu	a0,sp,40
9d003274:	27a50020 	addiu	a1,sp,32
9d003278:	0f402fc1 	jal	9d00bf04 <memcmp>
9d00327c:	24060006 	li	a2,6
9d003280:	14400041 	bnez	v0,9d003388 <MACInit+0x208>
9d003284:	3c02bf89 	lui	v0,0xbf89
		{	// use the factory programmed address existent in the MAC
            unsigned short* pS=(unsigned short*)SysMACAddr.addr;
            *pS++=EMACxSA2;
9d003288:	8c449320 	lw	a0,-27872(v0)
            *pS++=EMACxSA1;
9d00328c:	3c02bf89 	lui	v0,0xbf89
9d003290:	8c439310 	lw	v1,-27888(v0)
            *pS=EMACxSA0;
9d003294:	3c02bf89 	lui	v0,0xbf89
9d003298:	8c429300 	lw	v0,-27904(v0)
		// set the MAC address
        memcpy(SysMACAddr.addr, AppConfig.MyMACAddr.v, sizeof(SysMACAddr.addr));
        if(memcmp(SysMACAddr.addr, useFactMACAddr, sizeof(useFactMACAddr))==0 || memcmp(SysMACAddr.addr, unsetMACAddr, sizeof(unsetMACAddr))==0 )
		{	// use the factory programmed address existent in the MAC
            unsigned short* pS=(unsigned short*)SysMACAddr.addr;
            *pS++=EMACxSA2;
9d00329c:	a7a40028 	sh	a0,40(sp)
            *pS++=EMACxSA1;
9d0032a0:	a7a3002a 	sh	v1,42(sp)
            *pS=EMACxSA0;
9d0032a4:	a7a2002c 	sh	v0,44(sp)
            memcpy(AppConfig.MyMACAddr.v, SysMACAddr.addr, sizeof(SysMACAddr.addr));
9d0032a8:	8fa20028 	lw	v0,40(sp)
9d0032ac:	aa220030 	swl	v0,48(s1)
9d0032b0:	ba22002d 	swr	v0,45(s1)
9d0032b4:	93a2002c 	lbu	v0,44(sp)
9d0032b8:	a2220031 	sb	v0,49(s1)
9d0032bc:	93a2002d 	lbu	v0,45(sp)
9d0032c0:	a2220032 	sb	v0,50(s1)
        else
        {   // use the supplied address
			EthMACSetAddress(SysMACAddr.addr);                
        }
				
		if(EthDescriptorsPoolAdd(EMAC_TX_DESCRIPTORS, ETH_DCPT_TYPE_TX, _MacAllocCallback, 0)!=EMAC_TX_DESCRIPTORS)
9d0032c4:	3c119d00 	lui	s1,0x9d00
9d0032c8:	26263178 	addiu	a2,s1,12664
9d0032cc:	24040002 	li	a0,2
9d0032d0:	24050002 	li	a1,2
9d0032d4:	0f403337 	jal	9d00ccdc <EthDescriptorsPoolAdd>
9d0032d8:	00003821 	move	a3,zero
		{
			initFail++;
		}

		if(EthDescriptorsPoolAdd(EMAC_RX_DESCRIPTORS, ETH_DCPT_TYPE_RX, _MacAllocCallback, 0)!=EMAC_RX_DESCRIPTORS)
9d0032dc:	26263178 	addiu	a2,s1,12664
9d0032e0:	24050001 	li	a1,1
9d0032e4:	00003821 	move	a3,zero
9d0032e8:	0f403337 	jal	9d00ccdc <EthDescriptorsPoolAdd>
9d0032ec:	24040008 	li	a0,8
		EthRxSetBufferSize(EMAC_RX_BUFF_SIZE);

		// set the RX buffers as permanent receive buffers
		for(ix=0, ethRes=ETH_RES_OK; ix<EMAC_RX_DESCRIPTORS && ethRes==ETH_RES_OK; ix++)
		{
			void* pRxBuff=_RxBuffers[ix];
9d0032f0:	3c11a000 	lui	s1,0xa000
		if(EthDescriptorsPoolAdd(EMAC_RX_DESCRIPTORS, ETH_DCPT_TYPE_RX, _MacAllocCallback, 0)!=EMAC_RX_DESCRIPTORS)
		{
			initFail++;
		}

		EthRxSetBufferSize(EMAC_RX_BUFF_SIZE);
9d0032f4:	0f403500 	jal	9d00d400 <EthRxSetBufferSize>
9d0032f8:	24040600 	li	a0,1536

		// set the RX buffers as permanent receive buffers
		for(ix=0, ethRes=ETH_RES_OK; ix<EMAC_RX_DESCRIPTORS && ethRes==ETH_RES_OK; ix++)
		{
			void* pRxBuff=_RxBuffers[ix];
9d0032fc:	263116dc 	addiu	s1,s1,5852
			ethRes=EthRxBuffersAppend(&pRxBuff, 1, ETH_BUFF_FLAG_RX_STICKY);
9d003300:	27a40014 	addiu	a0,sp,20
9d003304:	24050001 	li	a1,1
9d003308:	24060001 	li	a2,1
9d00330c:	3c12a000 	lui	s2,0xa000
		EthRxSetBufferSize(EMAC_RX_BUFF_SIZE);

		// set the RX buffers as permanent receive buffers
		for(ix=0, ethRes=ETH_RES_OK; ix<EMAC_RX_DESCRIPTORS && ethRes==ETH_RES_OK; ix++)
		{
			void* pRxBuff=_RxBuffers[ix];
9d003310:	afb10014 	sw	s1,20(sp)
			ethRes=EthRxBuffersAppend(&pRxBuff, 1, ETH_BUFF_FLAG_RX_STICKY);
9d003314:	0f4033f0 	jal	9d00cfc0 <EthRxBuffersAppend>
9d003318:	26521cdc 	addiu	s2,s2,7388
 * Overview:        This function initializes the Eth controller, the MAC and the PHY. It should be called to be able to schedule
 *                  any Eth transmit or receive operation.
 *
 * Note:            None 
 *****************************************************************************/
void MACInit(void)
9d00331c:	26313000 	addiu	s1,s1,12288

		// set the RX buffers as permanent receive buffers
		for(ix=0, ethRes=ETH_RES_OK; ix<EMAC_RX_DESCRIPTORS && ethRes==ETH_RES_OK; ix++)
		{
			void* pRxBuff=_RxBuffers[ix];
			ethRes=EthRxBuffersAppend(&pRxBuff, 1, ETH_BUFF_FLAG_RX_STICKY);
9d003320:	27a40014 	addiu	a0,sp,20
9d003324:	24050001 	li	a1,1
		}

		EthRxSetBufferSize(EMAC_RX_BUFF_SIZE);

		// set the RX buffers as permanent receive buffers
		for(ix=0, ethRes=ETH_RES_OK; ix<EMAC_RX_DESCRIPTORS && ethRes==ETH_RES_OK; ix++)
9d003328:	14400006 	bnez	v0,9d003344 <MACInit+0x1c4>
9d00332c:	24060001 	li	a2,1
		{
			void* pRxBuff=_RxBuffers[ix];
9d003330:	afb20014 	sw	s2,20(sp)
			ethRes=EthRxBuffersAppend(&pRxBuff, 1, ETH_BUFF_FLAG_RX_STICKY);
9d003334:	0f4033f0 	jal	9d00cfc0 <EthRxBuffersAppend>
9d003338:	26520600 	addiu	s2,s2,1536
		}

		EthRxSetBufferSize(EMAC_RX_BUFF_SIZE);

		// set the RX buffers as permanent receive buffers
		for(ix=0, ethRes=ETH_RES_OK; ix<EMAC_RX_DESCRIPTORS && ethRes==ETH_RES_OK; ix++)
9d00333c:	1651fff9 	bne	s2,s1,9d003324 <MACInit+0x1a4>
9d003340:	27a40014 	addiu	a0,sp,20
		{
			initFail++;
		}


		if(phyInitRes==ETH_RES_OK)
9d003344:	1600000b 	bnez	s0,9d003374 <MACInit+0x1f4>
9d003348:	8fbf003c 	lw	ra,60(sp)
		{	// PHY was detected
			_linkPresent=1;
9d00334c:	24020001 	li	v0,1
9d003350:	af8280a4 	sw	v0,-32604(gp)
			if(oFlags&ETH_OPEN_AUTO)
			{	// we'll just wait for the negotiation to be done
				_linkNegotiation=1;	// performing the negotiation
				linkStat=_LinkReconfigure()?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;	// if negotiation not done yet we need to try it next time
9d003354:	0f400c3c 	jal	9d0030f0 <_LinkReconfigure>
9d003358:	af8280ac 	sw	v0,-32596(gp)
			{	// no need of negotiation results; just update the MAC
				EthMACOpen(linkFlags, pauseType);
				linkStat=EthPhyGetLinkStatus(0);
			}
			
			_linkUpdTick=TickGet();		// the last time we performed the link read
9d00335c:	0f400b53 	jal	9d002d4c <TickGet>
9d003360:	00408021 	move	s0,v0
		{	// PHY was detected
			_linkPresent=1;
			if(oFlags&ETH_OPEN_AUTO)
			{	// we'll just wait for the negotiation to be done
				_linkNegotiation=1;	// performing the negotiation
				linkStat=_LinkReconfigure()?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;	// if negotiation not done yet we need to try it next time
9d003364:	0010182b 	sltu	v1,zero,s0
			{	// no need of negotiation results; just update the MAC
				EthMACOpen(linkFlags, pauseType);
				linkStat=EthPhyGetLinkStatus(0);
			}
			
			_linkUpdTick=TickGet();		// the last time we performed the link read
9d003368:	af8280a8 	sw	v0,-32600(gp)
			_linkPrev=linkStat;
9d00336c:	af8380b0 	sw	v1,-32592(gp)
	}

	
//	return !initFail;	// at this point initFail gives some indication of any existent problems
	
}
9d003370:	8fbf003c 	lw	ra,60(sp)
9d003374:	8fb20038 	lw	s2,56(sp)
9d003378:	8fb10034 	lw	s1,52(sp)
9d00337c:	8fb00030 	lw	s0,48(sp)
9d003380:	03e00008 	jr	ra
9d003384:	27bd0040 	addiu	sp,sp,64
            *pS=EMACxSA0;
            memcpy(AppConfig.MyMACAddr.v, SysMACAddr.addr, sizeof(SysMACAddr.addr));
		}
        else
        {   // use the supplied address
			EthMACSetAddress(SysMACAddr.addr);                
9d003388:	0f4033de 	jal	9d00cf78 <EthMACSetAddress>
9d00338c:	27a40028 	addiu	a0,sp,40
        }
				
		if(EthDescriptorsPoolAdd(EMAC_TX_DESCRIPTORS, ETH_DCPT_TYPE_TX, _MacAllocCallback, 0)!=EMAC_TX_DESCRIPTORS)
9d003390:	0b400cb2 	j	9d0032c8 <MACInit+0x148>
9d003394:	3c119d00 	lui	s1,0x9d00

9d003398 <MACIsLinked>:
 *
 * Note:            None 
 *****************************************************************************/
BOOL MACIsLinked(void)
{
	return (_linkPrev&ETH_LINK_ST_UP)!=0;
9d003398:	8f8280b0 	lw	v0,-32592(gp)
}
9d00339c:	03e00008 	jr	ra
9d0033a0:	30420001 	andi	v0,v0,0x1

9d0033a4 <MACGetTxBaseAddr>:
 *
 * Note:            The returned value could be 0 if currently there's no available TX buffer. 
 *****************************************************************************/
PTR_BASE MACGetTxBaseAddr(void)
{
	return _pTxCurrDcpt?(PTR_BASE)_pTxCurrDcpt->dataBuff:0;
9d0033a4:	8f8280b8 	lw	v0,-32584(gp)
9d0033a8:	24430004 	addiu	v1,v0,4
}
9d0033ac:	0002180a 	movz	v1,zero,v0
9d0033b0:	03e00008 	jr	ra
9d0033b4:	00601021 	move	v0,v1

9d0033b8 <MACSetWritePtr>:
 *****************************************************************************/
PTR_BASE MACSetWritePtr(PTR_BASE address)
{
	unsigned char* oldPtr;

	oldPtr=_CurrWrPtr;
9d0033b8:	8f8280a0 	lw	v0,-32608(gp)
	_CurrWrPtr=(unsigned char*)address;
	return (PTR_BASE)oldPtr;
}
9d0033bc:	03e00008 	jr	ra
9d0033c0:	af8480a0 	sw	a0,-32608(gp)

9d0033c4 <MACIsTxReady>:
 *****************************************************************************/
BOOL MACIsTxReady(void)
{
	int	ix;

	EthTxAcknowledgeBuffer(0, _TxAckCallback, 0);		// acknowledge everything
9d0033c4:	3c059d00 	lui	a1,0x9d00
 * Overview:        Checks if there is an available current TX buffer
 *
 * Note:            None
 *****************************************************************************/
BOOL MACIsTxReady(void)
{
9d0033c8:	27bdffe8 	addiu	sp,sp,-24
	int	ix;

	EthTxAcknowledgeBuffer(0, _TxAckCallback, 0);		// acknowledge everything
9d0033cc:	00002021 	move	a0,zero
9d0033d0:	24a530e4 	addiu	a1,a1,12516
 * Overview:        Checks if there is an available current TX buffer
 *
 * Note:            None
 *****************************************************************************/
BOOL MACIsTxReady(void)
{
9d0033d4:	afbf0014 	sw	ra,20(sp)
	int	ix;

	EthTxAcknowledgeBuffer(0, _TxAckCallback, 0);		// acknowledge everything
9d0033d8:	0f40332b 	jal	9d00ccac <EthTxAcknowledgeBuffer>
9d0033dc:	00003021 	move	a2,zero

	if(_pTxCurrDcpt==0)
9d0033e0:	8f8280b8 	lw	v0,-32584(gp)
9d0033e4:	10400005 	beqz	v0,9d0033fc <MACIsTxReady+0x38>
9d0033e8:	8f8980c0 	lw	t1,-32576(gp)
	{
		_stackMgrTxNotReady++;
	}
	
	return _pTxCurrDcpt!=0;
}
9d0033ec:	8fbf0014 	lw	ra,20(sp)
9d0033f0:	0002102b 	sltu	v0,zero,v0
9d0033f4:	03e00008 	jr	ra
9d0033f8:	27bd0018 	addiu	sp,sp,24

	EthTxAcknowledgeBuffer(0, _TxAckCallback, 0);		// acknowledge everything

	if(_pTxCurrDcpt==0)
	{
		for(ix=_TxLastDcptIx+1; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
9d0033fc:	25230001 	addiu	v1,t1,1
9d003400:	2c640002 	sltiu	a0,v1,2
9d003404:	1080001b 	beqz	a0,9d003474 <MACIsTxReady+0xb0>
9d003408:	00000000 	nop
		{			
			if(_TxDescriptors[ix].txBusy==0)
9d00340c:	00032140 	sll	a0,v1,0x5
9d003410:	000329c0 	sll	a1,v1,0x7
9d003414:	00a43023 	subu	a2,a1,a0
9d003418:	3c08a000 	lui	t0,0xa000
9d00341c:	00c33023 	subu	a2,a2,v1
9d003420:	00063100 	sll	a2,a2,0x4
9d003424:	25080afc 	addiu	t0,t0,2812
9d003428:	01063021 	addu	a2,t0,a2
9d00342c:	8cc60000 	lw	a2,0(a2)
9d003430:	54c00007 	bnezl	a2,9d003450 <MACIsTxReady+0x8c>
9d003434:	24630001 	addiu	v1,v1,1
		{
			for(ix=0; ix<_TxLastDcptIx; ix++)
			{
				if(_TxDescriptors[ix].txBusy==0)
				{	// found a non busy descriptor
					_pTxCurrDcpt=_TxDescriptors+ix;
9d003438:	0b400d3a 	j	9d0034e8 <MACIsTxReady+0x124>
9d00343c:	00a41023 	subu	v0,a1,a0

	if(_pTxCurrDcpt==0)
	{
		for(ix=_TxLastDcptIx+1; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
		{			
			if(_TxDescriptors[ix].txBusy==0)
9d003440:	8ce60000 	lw	a2,0(a3)
9d003444:	50c00028 	beqzl	a2,9d0034e8 <MACIsTxReady+0x124>
9d003448:	00a41023 	subu	v0,a1,a0

	EthTxAcknowledgeBuffer(0, _TxAckCallback, 0);		// acknowledge everything

	if(_pTxCurrDcpt==0)
	{
		for(ix=_TxLastDcptIx+1; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
9d00344c:	24630001 	addiu	v1,v1,1
		{			
			if(_TxDescriptors[ix].txBusy==0)
9d003450:	00032140 	sll	a0,v1,0x5
9d003454:	000329c0 	sll	a1,v1,0x7
9d003458:	00a43023 	subu	a2,a1,a0
9d00345c:	00c33023 	subu	a2,a2,v1
9d003460:	00063100 	sll	a2,a2,0x4
9d003464:	01063821 	addu	a3,t0,a2

	EthTxAcknowledgeBuffer(0, _TxAckCallback, 0);		// acknowledge everything

	if(_pTxCurrDcpt==0)
	{
		for(ix=_TxLastDcptIx+1; ix<sizeof(_TxDescriptors)/sizeof(*_TxDescriptors); ix++)
9d003468:	2c660002 	sltiu	a2,v1,2
9d00346c:	14c0fff4 	bnez	a2,9d003440 <MACIsTxReady+0x7c>
9d003470:	00000000 	nop
				break;
			}
		}
		if(_pTxCurrDcpt==0)
		{
			for(ix=0; ix<_TxLastDcptIx; ix++)
9d003474:	19200015 	blez	t1,9d0034cc <MACIsTxReady+0x108>
9d003478:	8f838094 	lw	v1,-32620(gp)
			{
				if(_TxDescriptors[ix].txBusy==0)
9d00347c:	3c08a000 	lui	t0,0xa000
9d003480:	8d030afc 	lw	v1,2812(t0)
9d003484:	10600014 	beqz	v1,9d0034d8 <MACIsTxReady+0x114>
9d003488:	00001821 	move	v1,zero
9d00348c:	0b400d28 	j	9d0034a0 <MACIsTxReady+0xdc>
9d003490:	25060afc 	addiu	a2,t0,2812
9d003494:	8d070000 	lw	a3,0(t0)
9d003498:	10e00012 	beqz	a3,9d0034e4 <MACIsTxReady+0x120>
9d00349c:	00c04021 	move	t0,a2
				break;
			}
		}
		if(_pTxCurrDcpt==0)
		{
			for(ix=0; ix<_TxLastDcptIx; ix++)
9d0034a0:	24630001 	addiu	v1,v1,1
			{
				if(_TxDescriptors[ix].txBusy==0)
9d0034a4:	00032140 	sll	a0,v1,0x5
9d0034a8:	000329c0 	sll	a1,v1,0x7
9d0034ac:	00a43823 	subu	a3,a1,a0
9d0034b0:	00e33823 	subu	a3,a3,v1
9d0034b4:	00073900 	sll	a3,a3,0x4
9d0034b8:	00c74021 	addu	t0,a2,a3
				break;
			}
		}
		if(_pTxCurrDcpt==0)
		{
			for(ix=0; ix<_TxLastDcptIx; ix++)
9d0034bc:	0069382a 	slt	a3,v1,t1
9d0034c0:	14e0fff4 	bnez	a3,9d003494 <MACIsTxReady+0xd0>
9d0034c4:	00000000 	nop
	}


	if( _pTxCurrDcpt==0)
	{
		_stackMgrTxNotReady++;
9d0034c8:	8f838094 	lw	v1,-32620(gp)
9d0034cc:	24630001 	addiu	v1,v1,1
9d0034d0:	0b400cfb 	j	9d0033ec <MACIsTxReady+0x28>
9d0034d4:	af838094 	sw	v1,-32620(gp)
9d0034d8:	25080afc 	addiu	t0,t0,2812
9d0034dc:	00002021 	move	a0,zero
9d0034e0:	00002821 	move	a1,zero
		{
			for(ix=0; ix<_TxLastDcptIx; ix++)
			{
				if(_TxDescriptors[ix].txBusy==0)
				{	// found a non busy descriptor
					_pTxCurrDcpt=_TxDescriptors+ix;
9d0034e4:	00a41023 	subu	v0,a1,a0
9d0034e8:	00431023 	subu	v0,v0,v1
9d0034ec:	00021100 	sll	v0,v0,0x4
9d0034f0:	01021021 	addu	v0,t0,v0
9d0034f4:	af8280b8 	sw	v0,-32584(gp)
					_TxLastDcptIx=ix;
9d0034f8:	0b400cfb 	j	9d0033ec <MACIsTxReady+0x28>
9d0034fc:	af8380c0 	sw	v1,-32576(gp)

9d003500 <MACPut>:
 *
 * Note:            None
 *****************************************************************************/
void MACPut(BYTE val)
{
	*_CurrWrPtr++=val;
9d003500:	8f8280a0 	lw	v0,-32608(gp)
9d003504:	24430001 	addiu	v1,v0,1
9d003508:	a0440000 	sb	a0,0(v0)
}
9d00350c:	03e00008 	jr	ra
9d003510:	af8380a0 	sw	v1,-32608(gp)

9d003514 <MACPutArray>:
 * Overview:        Writes a buffer to the current write location and updates the write pointer. 
 *
 * Note:            None
 *****************************************************************************/
void MACPutArray(BYTE *buff, WORD len)
{
9d003514:	27bdffe0 	addiu	sp,sp,-32
9d003518:	afb10018 	sw	s1,24(sp)
	memcpy(_CurrWrPtr, buff, len);
9d00351c:	8f9180a0 	lw	s1,-32608(gp)
 * Overview:        Writes a buffer to the current write location and updates the write pointer. 
 *
 * Note:            None
 *****************************************************************************/
void MACPutArray(BYTE *buff, WORD len)
{
9d003520:	afb00014 	sw	s0,20(sp)
9d003524:	30b0ffff 	andi	s0,a1,0xffff
	memcpy(_CurrWrPtr, buff, len);
9d003528:	02003021 	move	a2,s0
9d00352c:	00802821 	move	a1,a0
 * Overview:        Writes a buffer to the current write location and updates the write pointer. 
 *
 * Note:            None
 *****************************************************************************/
void MACPutArray(BYTE *buff, WORD len)
{
9d003530:	afbf001c 	sw	ra,28(sp)
	memcpy(_CurrWrPtr, buff, len);
9d003534:	0f402fce 	jal	9d00bf38 <memcpy>
9d003538:	02202021 	move	a0,s1
	_CurrWrPtr+=len;
}
9d00353c:	8fbf001c 	lw	ra,28(sp)
 * Note:            None
 *****************************************************************************/
void MACPutArray(BYTE *buff, WORD len)
{
	memcpy(_CurrWrPtr, buff, len);
	_CurrWrPtr+=len;
9d003540:	02308021 	addu	s0,s1,s0
9d003544:	af9080a0 	sw	s0,-32608(gp)
}
9d003548:	8fb10018 	lw	s1,24(sp)
9d00354c:	8fb00014 	lw	s0,20(sp)
9d003550:	03e00008 	jr	ra
9d003554:	27bd0020 	addiu	sp,sp,32

9d003558 <MACPutHeader>:
 *
 * Note:            Assumes there is an available TX buffer, i.e. MACIsTxReady() returned !0
 *****************************************************************************/
void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
{
	_TxCurrSize=dataLen+sizeof(ETHER_HEADER);
9d003558:	24c6000e 	addiu	a2,a2,14
9d00355c:	a78680bc 	sh	a2,-32580(gp)
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
9d003560:	88830003 	lwl	v1,3(a0)
 * Note:            Assumes there is an available TX buffer, i.e. MACIsTxReady() returned !0
 *****************************************************************************/
void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
{
	_TxCurrSize=dataLen+sizeof(ETHER_HEADER);
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
9d003564:	8f8280b8 	lw	v0,-32584(gp)
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
	_CurrWrPtr+=sizeof(*remote);
	memcpy(_CurrWrPtr, &AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9d003568:	3c06a001 	lui	a2,0xa001
{
	_TxCurrSize=dataLen+sizeof(ETHER_HEADER);
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
9d00356c:	98830000 	lwr	v1,0(a0)
 * Note:            Assumes there is an available TX buffer, i.e. MACIsTxReady() returned !0
 *****************************************************************************/
void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
{
	_TxCurrSize=dataLen+sizeof(ETHER_HEADER);
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
9d003570:	24470004 	addiu	a3,v0,4
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
	_CurrWrPtr+=sizeof(*remote);
	memcpy(_CurrWrPtr, &AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9d003574:	24c69a5c 	addiu	a2,a2,-26020
{
	_TxCurrSize=dataLen+sizeof(ETHER_HEADER);
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
9d003578:	a8430007 	swl	v1,7(v0)
9d00357c:	b8e30000 	swr	v1,0(a3)
9d003580:	90880004 	lbu	t0,4(a0)
	_CurrWrPtr+=sizeof(*remote);
9d003584:	2443000a 	addiu	v1,v0,10
 *                 and sets the ETH header and the frame length. Updates the write pointer
 *
 * Note:            Assumes there is an available TX buffer, i.e. MACIsTxReady() returned !0
 *****************************************************************************/
void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
{
9d003588:	30a500ff 	andi	a1,a1,0xff
	_TxCurrSize=dataLen+sizeof(ETHER_HEADER);
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
9d00358c:	a0e80004 	sb	t0,4(a3)
9d003590:	90840005 	lbu	a0,5(a0)
9d003594:	a0e40005 	sb	a0,5(a3)
	_CurrWrPtr+=sizeof(*remote);
	memcpy(_CurrWrPtr, &AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9d003598:	88c40030 	lwl	a0,48(a2)
	_CurrWrPtr+=sizeof(AppConfig.MyMACAddr);

	
	*_CurrWrPtr++=0x08;
	*_CurrWrPtr++=(type == MAC_IP) ? ETHER_IP : ETHER_ARP;
9d00359c:	24070006 	li	a3,6
9d0035a0:	0005380a 	movz	a3,zero,a1
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
	_CurrWrPtr+=sizeof(*remote);
	memcpy(_CurrWrPtr, &AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9d0035a4:	98c4002d 	lwr	a0,45(a2)
	_CurrWrPtr+=sizeof(AppConfig.MyMACAddr);

	
	*_CurrWrPtr++=0x08;
	*_CurrWrPtr++=(type == MAC_IP) ? ETHER_IP : ETHER_ARP;
9d0035a8:	00e02821 	move	a1,a3
9d0035ac:	24470012 	addiu	a3,v0,18
	_CurrWrPtr=(unsigned char*)_pTxCurrDcpt->dataBuff;		// point at the beg of the buffer
       	

	memcpy(_CurrWrPtr, remote, sizeof(*remote));
	_CurrWrPtr+=sizeof(*remote);
	memcpy(_CurrWrPtr, &AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9d0035b0:	a844000d 	swl	a0,13(v0)
9d0035b4:	b8640000 	swr	a0,0(v1)
9d0035b8:	90c40031 	lbu	a0,49(a2)
9d0035bc:	a0640004 	sb	a0,4(v1)
9d0035c0:	90c40032 	lbu	a0,50(a2)
9d0035c4:	a0640005 	sb	a0,5(v1)
	_CurrWrPtr+=sizeof(AppConfig.MyMACAddr);

	
	*_CurrWrPtr++=0x08;
9d0035c8:	24030008 	li	v1,8
9d0035cc:	a0430010 	sb	v1,16(v0)
	*_CurrWrPtr++=(type == MAC_IP) ? ETHER_IP : ETHER_ARP;
9d0035d0:	a0450011 	sb	a1,17(v0)
	
}
9d0035d4:	03e00008 	jr	ra
9d0035d8:	af8780a0 	sw	a3,-32608(gp)

9d0035dc <MACFlush>:



void MACFlush(void)
{
	if(_pTxCurrDcpt && _TxCurrSize)
9d0035dc:	8f8480b8 	lw	a0,-32584(gp)
}



void MACFlush(void)
{
9d0035e0:	27bdffe8 	addiu	sp,sp,-24
	if(_pTxCurrDcpt && _TxCurrSize)
9d0035e4:	1080000a 	beqz	a0,9d003610 <MACFlush+0x34>
9d0035e8:	afbf0014 	sw	ra,20(sp)
9d0035ec:	978580bc 	lhu	a1,-32580(gp)
9d0035f0:	10a00008 	beqz	a1,9d003614 <MACFlush+0x38>
9d0035f4:	8fbf0014 	lw	ra,20(sp)
	{	// there is a buffer to transmit
		_pTxCurrDcpt->txBusy=1;	
9d0035f8:	24020001 	li	v0,1
9d0035fc:	ac820000 	sw	v0,0(a0)
		EthTxSendBuffer((void*)_pTxCurrDcpt->dataBuff, _TxCurrSize);
9d003600:	0f40355a 	jal	9d00d568 <EthTxSendBuffer>
9d003604:	24840004 	addiu	a0,a0,4
		// res should be ETH_RES_OK since we made sure we had a descriptor available
		// by the call to MACIsTxReady and the number of the buffers matches the number of descriptors
		_pTxCurrDcpt=0;
9d003608:	af8080b8 	sw	zero,-32584(gp)
		_TxCurrSize=0;
9d00360c:	a78080bc 	sh	zero,-32580(gp)
	}
}
9d003610:	8fbf0014 	lw	ra,20(sp)
9d003614:	03e00008 	jr	ra
9d003618:	27bd0018 	addiu	sp,sp,24

9d00361c <MACDiscardRx>:
 *                  MACGetHeader() calls.  Extra packets won't be thrown away 
 *                  until MACGetHeader() makes it available.
 *****************************************************************************/
void MACDiscardRx(void)
{
	if(_pRxCurrBuff)
9d00361c:	8f848098 	lw	a0,-32616(gp)
 * Note:            Is is safe to call this function multiple times between
 *                  MACGetHeader() calls.  Extra packets won't be thrown away 
 *                  until MACGetHeader() makes it available.
 *****************************************************************************/
void MACDiscardRx(void)
{
9d003620:	27bdffe8 	addiu	sp,sp,-24
	if(_pRxCurrBuff)
9d003624:	10800009 	beqz	a0,9d00364c <MACDiscardRx+0x30>
9d003628:	afbf0014 	sw	ra,20(sp)
	{	// an already existing packet
		EthRxAcknowledgeBuffer(_pRxCurrBuff, 0, 0);
9d00362c:	00002821 	move	a1,zero
9d003630:	0f403324 	jal	9d00cc90 <EthRxAcknowledgeBuffer>
9d003634:	00003021 	move	a2,zero
		_pRxCurrBuff=0;
		_RxCurrSize=0;

		_stackMgrRxDiscarded++;
9d003638:	8f828090 	lw	v0,-32624(gp)
void MACDiscardRx(void)
{
	if(_pRxCurrBuff)
	{	// an already existing packet
		EthRxAcknowledgeBuffer(_pRxCurrBuff, 0, 0);
		_pRxCurrBuff=0;
9d00363c:	af808098 	sw	zero,-32616(gp)
		_RxCurrSize=0;
9d003640:	a78080b4 	sh	zero,-32588(gp)

		_stackMgrRxDiscarded++;
9d003644:	24420001 	addiu	v0,v0,1
9d003648:	af828090 	sw	v0,-32624(gp)
	}	
}
9d00364c:	8fbf0014 	lw	ra,20(sp)
9d003650:	03e00008 	jr	ra
9d003654:	27bd0018 	addiu	sp,sp,24

9d003658 <MACGetHeader>:
{
	void*			pNewPkt;
	const sEthRxPktStat*	pRxPktStat;
	eEthRes			res;

	_stackMgrInGetHdr++;
9d003658:	8f82808c 	lw	v0,-32628(gp)
 * Overview:        None
 *
 * Note:            Sets the read pointer at the beginning of the new packet
 *****************************************************************************/
BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
{
9d00365c:	27bdffd8 	addiu	sp,sp,-40
9d003660:	afb1001c 	sw	s1,28(sp)
	void*			pNewPkt;
	const sEthRxPktStat*	pRxPktStat;
	eEthRes			res;

	_stackMgrInGetHdr++;
9d003664:	24420001 	addiu	v0,v0,1
9d003668:	af82808c 	sw	v0,-32628(gp)

	// verify the link status
	// if auto negotiation is enabled we may have to reconfigure the MAC

	while(_linkPresent)
9d00366c:	8f8280a4 	lw	v0,-32604(gp)
 * Overview:        None
 *
 * Note:            Sets the read pointer at the beginning of the new packet
 *****************************************************************************/
BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
{
9d003670:	afb00018 	sw	s0,24(sp)
9d003674:	afbf0024 	sw	ra,36(sp)
9d003678:	afb20020 	sw	s2,32(sp)
9d00367c:	00808021 	move	s0,a0
	_stackMgrInGetHdr++;

	// verify the link status
	// if auto negotiation is enabled we may have to reconfigure the MAC

	while(_linkPresent)
9d003680:	14400036 	bnez	v0,9d00375c <MACGetHeader+0x104>
9d003684:	00a08821 	move	s1,a1
	
		break;
	}


	MACDiscardRx();		// discard/acknowledge the old RX buffer, if any
9d003688:	0f400d87 	jal	9d00361c <MACDiscardRx>
9d00368c:	00000000 	nop
	
	res=EthRxGetBuffer(&pNewPkt, &pRxPktStat);
9d003690:	27a40010 	addiu	a0,sp,16
9d003694:	0f4034f1 	jal	9d00d3c4 <EthRxGetBuffer>
9d003698:	27a50014 	addiu	a1,sp,20
	
	if(res==ETH_RES_OK)
9d00369c:	14400007 	bnez	v0,9d0036bc <MACGetHeader+0x64>
9d0036a0:	8f828098 	lw	v0,-32616(gp)
	{	// available packet; minimum check

		if(pRxPktStat->rxOk && !pRxPktStat->runtPkt && !pRxPktStat->crcError)
9d0036a4:	8fa20014 	lw	v0,20(sp)
9d0036a8:	8c430004 	lw	v1,4(v0)
9d0036ac:	7c6405c0 	ext	a0,v1,0x17,0x1
9d0036b0:	5480000b 	bnezl	a0,9d0036e0 <MACGetHeader+0x88>
9d0036b4:	8c440000 	lw	a0,0(v0)
			
			_stackMgrRxOkPkts++;
		}
	}

	if(_pRxCurrBuff==0 && pNewPkt)
9d0036b8:	8f828098 	lw	v0,-32616(gp)
9d0036bc:	10400040 	beqz	v0,9d0037c0 <MACGetHeader+0x168>
9d0036c0:	8fa40010 	lw	a0,16(sp)
		_stackMgrRxBadPkts++;
	}
		
	
	return _pRxCurrBuff!=0;
}
9d0036c4:	8fbf0024 	lw	ra,36(sp)
9d0036c8:	0002102b 	sltu	v0,zero,v0
9d0036cc:	8fb20020 	lw	s2,32(sp)
9d0036d0:	8fb1001c 	lw	s1,28(sp)
9d0036d4:	8fb00018 	lw	s0,24(sp)
9d0036d8:	03e00008 	jr	ra
9d0036dc:	27bd0028 	addiu	sp,sp,40
	res=EthRxGetBuffer(&pNewPkt, &pRxPktStat);
	
	if(res==ETH_RES_OK)
	{	// available packet; minimum check

		if(pRxPktStat->rxOk && !pRxPktStat->runtPkt && !pRxPktStat->crcError)
9d0036e0:	7c840600 	ext	a0,a0,0x18,0x1
9d0036e4:	5480fff5 	bnezl	a0,9d0036bc <MACGetHeader+0x64>
9d0036e8:	8f828098 	lw	v0,-32616(gp)
9d0036ec:	7c630500 	ext	v1,v1,0x14,0x1
9d0036f0:	5460fff2 	bnezl	v1,9d0036bc <MACGetHeader+0x64>
9d0036f4:	8f828098 	lw	v0,-32616(gp)
		{	// valid packet;
			WORD_VAL newType;
			_RxCurrSize=pRxPktStat->rxBytes;
			_pRxCurrBuff=pNewPkt;
9d0036f8:	8fa30010 	lw	v1,16(sp)
	{	// available packet; minimum check

		if(pRxPktStat->rxOk && !pRxPktStat->runtPkt && !pRxPktStat->crcError)
		{	// valid packet;
			WORD_VAL newType;
			_RxCurrSize=pRxPktStat->rxBytes;
9d0036fc:	94440004 	lhu	a0,4(v0)
			_pRxCurrBuff=pNewPkt;
			_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER);	// skip the packet header
9d003700:	2462000e 	addiu	v0,v1,14

		if(pRxPktStat->rxOk && !pRxPktStat->runtPkt && !pRxPktStat->crcError)
		{	// valid packet;
			WORD_VAL newType;
			_RxCurrSize=pRxPktStat->rxBytes;
			_pRxCurrBuff=pNewPkt;
9d003704:	af838098 	sw	v1,-32616(gp)
			_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER);	// skip the packet header
9d003708:	af82809c 	sw	v0,-32612(gp)
	{	// available packet; minimum check

		if(pRxPktStat->rxOk && !pRxPktStat->runtPkt && !pRxPktStat->crcError)
		{	// valid packet;
			WORD_VAL newType;
			_RxCurrSize=pRxPktStat->rxBytes;
9d00370c:	a78480b4 	sh	a0,-32588(gp)
			_pRxCurrBuff=pNewPkt;
			_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER);	// skip the packet header
			// set the packet type
			memcpy(remote, &((ETHER_HEADER*)pNewPkt)->SourceMACAddr, sizeof(*remote));
9d003710:	24620006 	addiu	v0,v1,6
9d003714:	88440003 	lwl	a0,3(v0)
9d003718:	98440000 	lwr	a0,0(v0)
9d00371c:	aa040003 	swl	a0,3(s0)
9d003720:	ba040000 	swr	a0,0(s0)
9d003724:	90440004 	lbu	a0,4(v0)
9d003728:	a2040004 	sb	a0,4(s0)
9d00372c:	90420005 	lbu	v0,5(v0)
9d003730:	a2020005 	sb	v0,5(s0)
			*type=MAC_UNKNOWN;
9d003734:	2402ffff 	li	v0,-1
9d003738:	a2220000 	sb	v0,0(s1)
			newType=((ETHER_HEADER*)pNewPkt)->Type;
			if( newType.v[0]==0x08 && (newType.v[1]==ETHER_IP || newType.v[1]==ETHER_ARP) )
9d00373c:	9064000c 	lbu	a0,12(v1)
9d003740:	24020008 	li	v0,8
9d003744:	1082002e 	beq	a0,v0,9d003800 <MACGetHeader+0x1a8>
9d003748:	9063000d 	lbu	v1,13(v1)
			{
				*type=newType.v[1];
			}
			
			_stackMgrRxOkPkts++;
9d00374c:	8f828084 	lw	v0,-32636(gp)
9d003750:	24420001 	addiu	v0,v0,1
9d003754:	0b400dae 	j	9d0036b8 <MACGetHeader+0x60>
9d003758:	af828084 	sw	v0,-32636(gp)
	// if auto negotiation is enabled we may have to reconfigure the MAC

	while(_linkPresent)
	{
		eEthLinkStat	linkCurr;
		DWORD		currTick=TickGet();
9d00375c:	0f400b53 	jal	9d002d4c <TickGet>
9d003760:	00000000 	nop
9d003764:	00409021 	move	s2,v0
		
		if(currTick-_linkUpdTick< (TICKS_PER_SECOND/1000)*LINK_REFRESH_MS)
9d003768:	8f8280a8 	lw	v0,-32600(gp)
9d00376c:	02421023 	subu	v0,s2,v0
9d003770:	2c4279e0 	sltiu	v0,v0,31200
9d003774:	1440ffc4 	bnez	v0,9d003688 <MACGetHeader+0x30>
9d003778:	00000000 	nop
		{	// not time to do anything yet
			break;
		}

		linkCurr=EthPhyGetLinkStatus(0);	// read current PHY status
9d00377c:	0f4028a4 	jal	9d00a290 <EthPhyGetLinkStatus>
9d003780:	00002021 	move	a0,zero
		_linkUpdTick=currTick;			// start a new counting period

		if(_linkNegotiation)
9d003784:	8f8380ac 	lw	v1,-32596(gp)
9d003788:	1060000b 	beqz	v1,9d0037b8 <MACGetHeader+0x160>
9d00378c:	af9280a8 	sw	s2,-32600(gp)
		{	// the auto-negotiation turned on
			if((linkCurr&ETH_LINK_ST_UP) && !(_linkPrev&ETH_LINK_ST_UP))
9d003790:	30430001 	andi	v1,v0,0x1
9d003794:	5060ffbc 	beqzl	v1,9d003688 <MACGetHeader+0x30>
9d003798:	af8280b0 	sw	v0,-32592(gp)
9d00379c:	8f8380b0 	lw	v1,-32592(gp)
9d0037a0:	30630001 	andi	v1,v1,0x1
9d0037a4:	5460ffb8 	bnezl	v1,9d003688 <MACGetHeader+0x30>
9d0037a8:	af8280b0 	sw	v0,-32592(gp)
			{	// we're up after being done. do renegotiate!
				linkCurr=_LinkReconfigure()?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;	// if negotiation not done yet we need to try it next time
9d0037ac:	0f400c3c 	jal	9d0030f0 <_LinkReconfigure>
9d0037b0:	00000000 	nop
9d0037b4:	0002102b 	sltu	v0,zero,v0
			}
			// else link went/still down; nothing to do yet
		}
		_linkPrev=linkCurr;
	
		break;
9d0037b8:	0b400da2 	j	9d003688 <MACGetHeader+0x30>
9d0037bc:	af8280b0 	sw	v0,-32592(gp)
			
			_stackMgrRxOkPkts++;
		}
	}

	if(_pRxCurrBuff==0 && pNewPkt)
9d0037c0:	1080ffc1 	beqz	a0,9d0036c8 <MACGetHeader+0x70>
9d0037c4:	8fbf0024 	lw	ra,36(sp)
	{	// failed packet, discard
		EthRxAcknowledgeBuffer(pNewPkt, 0, 0);
9d0037c8:	00002821 	move	a1,zero
9d0037cc:	0f403324 	jal	9d00cc90 <EthRxAcknowledgeBuffer>
9d0037d0:	00003021 	move	a2,zero
		_stackMgrRxBadPkts++;
9d0037d4:	8f838088 	lw	v1,-32632(gp)
9d0037d8:	8f828098 	lw	v0,-32616(gp)
	}
		
	
	return _pRxCurrBuff!=0;
}
9d0037dc:	8fbf0024 	lw	ra,36(sp)
	}

	if(_pRxCurrBuff==0 && pNewPkt)
	{	// failed packet, discard
		EthRxAcknowledgeBuffer(pNewPkt, 0, 0);
		_stackMgrRxBadPkts++;
9d0037e0:	24630001 	addiu	v1,v1,1
	}
		
	
	return _pRxCurrBuff!=0;
}
9d0037e4:	0002102b 	sltu	v0,zero,v0
9d0037e8:	8fb20020 	lw	s2,32(sp)
9d0037ec:	8fb1001c 	lw	s1,28(sp)
9d0037f0:	8fb00018 	lw	s0,24(sp)
	}

	if(_pRxCurrBuff==0 && pNewPkt)
	{	// failed packet, discard
		EthRxAcknowledgeBuffer(pNewPkt, 0, 0);
		_stackMgrRxBadPkts++;
9d0037f4:	af838088 	sw	v1,-32632(gp)
	}
		
	
	return _pRxCurrBuff!=0;
}
9d0037f8:	03e00008 	jr	ra
9d0037fc:	27bd0028 	addiu	sp,sp,40
			_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER);	// skip the packet header
			// set the packet type
			memcpy(remote, &((ETHER_HEADER*)pNewPkt)->SourceMACAddr, sizeof(*remote));
			*type=MAC_UNKNOWN;
			newType=((ETHER_HEADER*)pNewPkt)->Type;
			if( newType.v[0]==0x08 && (newType.v[1]==ETHER_IP || newType.v[1]==ETHER_ARP) )
9d003800:	5060ffd2 	beqzl	v1,9d00374c <MACGetHeader+0xf4>
9d003804:	a2230000 	sb	v1,0(s1)
9d003808:	24020006 	li	v0,6
9d00380c:	1462ffd0 	bne	v1,v0,9d003750 <MACGetHeader+0xf8>
9d003810:	8f828084 	lw	v0,-32636(gp)
			{
				*type=newType.v[1];
9d003814:	0b400dd3 	j	9d00374c <MACGetHeader+0xf4>
9d003818:	a2230000 	sb	v1,0(s1)

9d00381c <MACSetReadPtrInRx>:
 *
 * Note:            
 ******************************************************************************/
void MACSetReadPtrInRx(WORD offset)
{
	_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER)+offset;
9d00381c:	8f828098 	lw	v0,-32616(gp)
 *                  MACGet() and MACGetArray() will use these new values.
 *
 * Note:            
 ******************************************************************************/
void MACSetReadPtrInRx(WORD offset)
{
9d003820:	3084ffff 	andi	a0,a0,0xffff
	_CurrRdPtr=_pRxCurrBuff+sizeof(ETHER_HEADER)+offset;
9d003824:	2484000e 	addiu	a0,a0,14
9d003828:	00442021 	addu	a0,v0,a0
}
9d00382c:	03e00008 	jr	ra
9d003830:	af84809c 	sw	a0,-32612(gp)

9d003834 <MACSetReadPtr>:
 *****************************************************************************/
PTR_BASE MACSetReadPtr(PTR_BASE address)
{
	unsigned char* oldPtr;

	oldPtr=_CurrRdPtr;
9d003834:	8f82809c 	lw	v0,-32612(gp)
	_CurrRdPtr=(unsigned char*)address;
	return (PTR_BASE)oldPtr;
}
9d003838:	03e00008 	jr	ra
9d00383c:	af84809c 	sw	a0,-32612(gp)

9d003840 <MACGet>:
 *
 * Note:            None
 *****************************************************************************/
BYTE MACGet(void)
{
	return *_CurrRdPtr++;
9d003840:	8f83809c 	lw	v1,-32612(gp)
9d003844:	90620000 	lbu	v0,0(v1)
9d003848:	24630001 	addiu	v1,v1,1
}
9d00384c:	03e00008 	jr	ra
9d003850:	af83809c 	sw	v1,-32612(gp)

9d003854 <MACGetArray>:
 * Overview:        Copies data in the supplied buffer.
 *
 * Note:            The read pointer is updated
 *****************************************************************************/
WORD MACGetArray(BYTE *address, WORD len)
{
9d003854:	27bdffe8 	addiu	sp,sp,-24
9d003858:	afb00010 	sw	s0,16(sp)
9d00385c:	afbf0014 	sw	ra,20(sp)
	if(address)
9d003860:	10800004 	beqz	a0,9d003874 <MACGetArray+0x20>
9d003864:	30b0ffff 	andi	s0,a1,0xffff
	{
		memcpy(address, _CurrRdPtr, len);
9d003868:	8f85809c 	lw	a1,-32612(gp)
9d00386c:	0f402fce 	jal	9d00bf38 <memcpy>
9d003870:	02003021 	move	a2,s0
	}

	_CurrRdPtr+=len;
9d003874:	8f83809c 	lw	v1,-32612(gp)
	return len;
}
9d003878:	8fbf0014 	lw	ra,20(sp)
9d00387c:	02001021 	move	v0,s0
	if(address)
	{
		memcpy(address, _CurrRdPtr, len);
	}

	_CurrRdPtr+=len;
9d003880:	00708021 	addu	s0,v1,s0
9d003884:	af90809c 	sw	s0,-32612(gp)
	return len;
}
9d003888:	8fb00010 	lw	s0,16(sp)
9d00388c:	03e00008 	jr	ra
9d003890:	27bd0018 	addiu	sp,sp,24

9d003894 <MACGetFreeRxSize>:
int EthDescriptorsGetRxUnack ( void );

// DOM-IGNORE-BEGIN
extern __inline__ int __attribute__((always_inline)) EthDescriptorsGetRxUnack( void )
{
    return ETHSTATbits.BUFCNT;
9d003894:	3c02bf89 	lui	v0,0xbf89
9d003898:	904390e2 	lbu	v1,-28446(v0)
 *
 * Note:            None
 *****************************************************************************/
WORD MACGetFreeRxSize(void)
{
	int avlblRxBuffs=sizeof(_RxBuffers)/sizeof(*_RxBuffers)-EthDescriptorsGetRxUnack();	// avlbl=allBuffs-unAck
9d00389c:	24020008 	li	v0,8
9d0038a0:	306300ff 	andi	v1,v1,0xff
9d0038a4:	00431823 	subu	v1,v0,v1

	return avlblRxBuffs*(sizeof(_RxBuffers[0])/sizeof(*_RxBuffers[0]));	// avlbl* sizeof(buffer)
9d0038a8:	00031240 	sll	v0,v1,0x9
9d0038ac:	00031ac0 	sll	v1,v1,0xb
9d0038b0:	00621023 	subu	v0,v1,v0
}
9d0038b4:	03e00008 	jr	ra
9d0038b8:	3042fe00 	andi	v0,v0,0xfe00

9d0038bc <MACMemCopyAsync>:
 *                  is at a lower memory address than the source address.
 *
 * Note:            The addresses do not have to be aligned.
 *****************************************************************************/
void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len)
{
9d0038bc:	30c6ffff 	andi	a2,a2,0xffff
	if(len)
9d0038c0:	10c00008 	beqz	a2,9d0038e4 <MACMemCopyAsync+0x28>
9d0038c4:	00000000 	nop
	{
		unsigned char	*pDst, *pSrc;

		pDst=(destAddr==-1)?_CurrWrPtr:(unsigned char*)destAddr;
9d0038c8:	2402ffff 	li	v0,-1
9d0038cc:	10820009 	beq	a0,v0,9d0038f4 <MACMemCopyAsync+0x38>
9d0038d0:	00000000 	nop
		pSrc=(sourceAddr==-1)?_CurrRdPtr:(unsigned char*)sourceAddr;
9d0038d4:	10a20005 	beq	a1,v0,9d0038ec <MACMemCopyAsync+0x30>
9d0038d8:	00000000 	nop
		
		memcpy(pDst, pSrc, len);
9d0038dc:	0b402fce 	j	9d00bf38 <memcpy>
9d0038e0:	00000000 	nop
9d0038e4:	03e00008 	jr	ra
9d0038e8:	00000000 	nop
9d0038ec:	0b402fce 	j	9d00bf38 <memcpy>
9d0038f0:	8f85809c 	lw	a1,-32612(gp)
	if(len)
	{
		unsigned char	*pDst, *pSrc;

		pDst=(destAddr==-1)?_CurrWrPtr:(unsigned char*)destAddr;
		pSrc=(sourceAddr==-1)?_CurrRdPtr:(unsigned char*)sourceAddr;
9d0038f4:	14a2fff9 	bne	a1,v0,9d0038dc <MACMemCopyAsync+0x20>
9d0038f8:	8f8480a0 	lw	a0,-32608(gp)
9d0038fc:	0b400e3b 	j	9d0038ec <MACMemCopyAsync+0x30>
9d003900:	00000000 	nop

9d003904 <MACIsMemCopyDone>:
 * Note:            None
 *****************************************************************************/
BOOL MACIsMemCopyDone(void)
{
	return 1;
}
9d003904:	03e00008 	jr	ra
9d003908:	24020001 	li	v0,1

9d00390c <CalcIPBufferChecksum>:
 *                  pointed by the current value of the read pointer.
 *
 * Note:            None
 *****************************************************************************/
WORD CalcIPBufferChecksum(WORD len)
{
9d00390c:	3085ffff 	andi	a1,a0,0xffff
	return CalcIPChecksum(_CurrRdPtr, len);
9d003910:	0b40261b 	j	9d00986c <CalcIPChecksum>
9d003914:	8f84809c 	lw	a0,-32612(gp)

9d003918 <MACCalcRxChecksum>:
 *
 * Note:            None
 *****************************************************************************/
WORD MACCalcRxChecksum(WORD offset, WORD len)
{
	return CalcIPChecksum(_pRxCurrBuff+sizeof(ETHER_HEADER)+offset, len);
9d003918:	8f828098 	lw	v0,-32616(gp)
 * Overview:        This function performs a checksum calculation in the current receive buffer.
 *
 * Note:            None
 *****************************************************************************/
WORD MACCalcRxChecksum(WORD offset, WORD len)
{
9d00391c:	3084ffff 	andi	a0,a0,0xffff
	return CalcIPChecksum(_pRxCurrBuff+sizeof(ETHER_HEADER)+offset, len);
9d003920:	2484000e 	addiu	a0,a0,14
9d003924:	00442021 	addu	a0,v0,a0
9d003928:	0b40261b 	j	9d00986c <CalcIPChecksum>
9d00392c:	30a5ffff 	andi	a1,a1,0xffff

9d003930 <ARPInit>:
  	is only enabled when STACK_CLIENT_MODE is enabled.
  ***************************************************************************/
#ifdef STACK_CLIENT_MODE
void ARPInit(void)
{
    Cache.MACAddr.v[0] = 0xff;
9d003930:	3c04a000 	lui	a0,0xa000
9d003934:	248246dc 	addiu	v0,a0,18140
9d003938:	2403ffff 	li	v1,-1
9d00393c:	a0430004 	sb	v1,4(v0)
    Cache.MACAddr.v[1] = 0xff;
9d003940:	a0430005 	sb	v1,5(v0)
    Cache.MACAddr.v[2] = 0xff;
9d003944:	a0430006 	sb	v1,6(v0)
    Cache.MACAddr.v[3] = 0xff;
9d003948:	a0430007 	sb	v1,7(v0)
    Cache.MACAddr.v[4] = 0xff;
9d00394c:	a0430008 	sb	v1,8(v0)
    Cache.MACAddr.v[5] = 0xff;
9d003950:	a0430009 	sb	v1,9(v0)

	Cache.IPAddr.Val = 0x0;
}
9d003954:	03e00008 	jr	ra
9d003958:	ac8046dc 	sw	zero,18140(a0)

9d00395c <ARPIsResolved>:
  	is only enabled when STACK_CLIENT_MODE is enabled.
  ***************************************************************************/
#ifdef STACK_CLIENT_MODE
BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
{
    if((Cache.IPAddr.Val == IPAddr->Val) || 
9d00395c:	3c06a000 	lui	a2,0xa000
9d003960:	8cc346dc 	lw	v1,18140(a2)
9d003964:	8c840000 	lw	a0,0(a0)
9d003968:	10640010 	beq	v1,a0,9d0039ac <ARPIsResolved+0x50>
9d00396c:	3c09a001 	lui	t1,0xa001
	  ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val)))
9d003970:	25279a5c 	addiu	a3,t1,-26020
9d003974:	88e8000b 	lwl	t0,11(a3)
9d003978:	98e80008 	lwr	t0,8(a3)
  	is only enabled when STACK_CLIENT_MODE is enabled.
  ***************************************************************************/
#ifdef STACK_CLIENT_MODE
BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
{
    if((Cache.IPAddr.Val == IPAddr->Val) || 
9d00397c:	10680003 	beq	v1,t0,9d00398c <ARPIsResolved+0x30>
9d003980:	00001021 	move	v0,zero
    {
        *MACAddr = Cache.MACAddr;
        return TRUE;
    }
    return FALSE;
}
9d003984:	03e00008 	jr	ra
9d003988:	00000000 	nop
  ***************************************************************************/
#ifdef STACK_CLIENT_MODE
BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
{
    if((Cache.IPAddr.Val == IPAddr->Val) || 
	  ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val)))
9d00398c:	88e80003 	lwl	t0,3(a3)
9d003990:	88e30007 	lwl	v1,7(a3)
9d003994:	99289a5c 	lwr	t0,-26020(t1)
9d003998:	98e30004 	lwr	v1,4(a3)
9d00399c:	01042026 	xor	a0,t0,a0
9d0039a0:	00831824 	and	v1,a0,v1
9d0039a4:	1060fff7 	beqz	v1,9d003984 <ARPIsResolved+0x28>
9d0039a8:	00000000 	nop
    {
        *MACAddr = Cache.MACAddr;
9d0039ac:	24c646dc 	addiu	a2,a2,18140
9d0039b0:	8cc30004 	lw	v1,4(a2)
        return TRUE;
9d0039b4:	24020001 	li	v0,1
BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
{
    if((Cache.IPAddr.Val == IPAddr->Val) || 
	  ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val)))
    {
        *MACAddr = Cache.MACAddr;
9d0039b8:	a8a30003 	swl	v1,3(a1)
9d0039bc:	b8a30000 	swr	v1,0(a1)
9d0039c0:	90c30008 	lbu	v1,8(a2)
9d0039c4:	a0a30004 	sb	v1,4(a1)
9d0039c8:	90c30009 	lbu	v1,9(a2)
        return TRUE;
    }
    return FALSE;
}
9d0039cc:	03e00008 	jr	ra
9d0039d0:	a0a30005 	sb	v1,5(a1)

9d0039d4 <SwapARPPacket>:

  Returns:
  	None
  ***************************************************************************/
void SwapARPPacket(ARP_PACKET* p)
{
9d0039d4:	27bdffe8 	addiu	sp,sp,-24
9d0039d8:	afb00010 	sw	s0,16(sp)
9d0039dc:	00808021 	move	s0,a0
    p->HardwareType     = swaps(p->HardwareType);
9d0039e0:	94840000 	lhu	a0,0(a0)

  Returns:
  	None
  ***************************************************************************/
void SwapARPPacket(ARP_PACKET* p)
{
9d0039e4:	afbf0014 	sw	ra,20(sp)
    p->HardwareType     = swaps(p->HardwareType);
9d0039e8:	0f402604 	jal	9d009810 <swaps>
9d0039ec:	00000000 	nop
    p->Protocol         = swaps(p->Protocol);
9d0039f0:	96040002 	lhu	a0,2(s0)
9d0039f4:	0f402604 	jal	9d009810 <swaps>
9d0039f8:	a6020000 	sh	v0,0(s0)
    p->Operation        = swaps(p->Operation);
9d0039fc:	96040006 	lhu	a0,6(s0)
9d003a00:	0f402604 	jal	9d009810 <swaps>
9d003a04:	a6020002 	sh	v0,2(s0)
}
9d003a08:	8fbf0014 	lw	ra,20(sp)
  ***************************************************************************/
void SwapARPPacket(ARP_PACKET* p)
{
    p->HardwareType     = swaps(p->HardwareType);
    p->Protocol         = swaps(p->Protocol);
    p->Operation        = swaps(p->Operation);
9d003a0c:	a6020006 	sh	v0,6(s0)
}
9d003a10:	8fb00010 	lw	s0,16(sp)
9d003a14:	03e00008 	jr	ra
9d003a18:	27bd0018 	addiu	sp,sp,24

9d003a1c <ARPPut>:
  Return Values:
  	TRUE - The ARP packet was generated properly
  	FALSE - Not a possible return value
  ***************************************************************************/
static BOOL ARPPut(ARP_PACKET* packet)
{
9d003a1c:	27bdffe8 	addiu	sp,sp,-24
9d003a20:	afb00010 	sw	s0,16(sp)
9d003a24:	afbf0014 	sw	ra,20(sp)
9d003a28:	00808021 	move	s0,a0
	while(!MACIsTxReady());
9d003a2c:	0f400cf1 	jal	9d0033c4 <MACIsTxReady>
9d003a30:	00000000 	nop
9d003a34:	1040fffd 	beqz	v0,9d003a2c <ARPPut+0x10>
9d003a38:	00000000 	nop
	MACSetWritePtr(BASE_TX_ADDR);
9d003a3c:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d003a40:	00000000 	nop
9d003a44:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d003a48:	00402021 	move	a0,v0
	

    packet->HardwareType  = HW_ETHERNET;
9d003a4c:	24020001 	li	v0,1
9d003a50:	a6020000 	sh	v0,0(s0)
    packet->Protocol      = ARP_IP;
9d003a54:	24020800 	li	v0,2048
9d003a58:	a6020002 	sh	v0,2(s0)
    packet->MACAddrLen    = sizeof(MAC_ADDR);
9d003a5c:	24020006 	li	v0,6
9d003a60:	a2020004 	sb	v0,4(s0)
    packet->ProtocolLen   = sizeof(IP_ADDR);
//    packet->SenderMACAddr = AppConfig.MyMACAddr;	// HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround
	memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr));
9d003a64:	3c03a001 	lui	v1,0xa001
	

    packet->HardwareType  = HW_ETHERNET;
    packet->Protocol      = ARP_IP;
    packet->MACAddrLen    = sizeof(MAC_ADDR);
    packet->ProtocolLen   = sizeof(IP_ADDR);
9d003a68:	24020004 	li	v0,4
9d003a6c:	a2020005 	sb	v0,5(s0)
//    packet->SenderMACAddr = AppConfig.MyMACAddr;	// HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround
	memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr));
9d003a70:	24629a5c 	addiu	v0,v1,-26020
9d003a74:	88450030 	lwl	a1,48(v0)
    //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */
#else
    packet->SenderIPAddr  = AppConfig.MyIPAddr;
#endif

    SwapARPPacket(packet);
9d003a78:	02002021 	move	a0,s0
    packet->HardwareType  = HW_ETHERNET;
    packet->Protocol      = ARP_IP;
    packet->MACAddrLen    = sizeof(MAC_ADDR);
    packet->ProtocolLen   = sizeof(IP_ADDR);
//    packet->SenderMACAddr = AppConfig.MyMACAddr;	// HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround
	memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr));
9d003a7c:	9845002d 	lwr	a1,45(v0)
9d003a80:	aa05000b 	swl	a1,11(s0)
9d003a84:	ba050008 	swr	a1,8(s0)
9d003a88:	90450031 	lbu	a1,49(v0)
9d003a8c:	a205000c 	sb	a1,12(s0)
9d003a90:	90450032 	lbu	a1,50(v0)
9d003a94:	a205000d 	sb	a1,13(s0)
#ifdef STACK_USE_ZEROCONF_LINK_LOCAL
    //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */
#else
    packet->SenderIPAddr  = AppConfig.MyIPAddr;
9d003a98:	88420003 	lwl	v0,3(v0)
9d003a9c:	98629a5c 	lwr	v0,-26020(v1)
9d003aa0:	aa020011 	swl	v0,17(s0)
#endif

    SwapARPPacket(packet);
9d003aa4:	0f400e75 	jal	9d0039d4 <SwapARPPacket>
9d003aa8:	ba02000e 	swr	v0,14(s0)

    MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet));
9d003aac:	2406001c 	li	a2,28
9d003ab0:	26040012 	addiu	a0,s0,18
9d003ab4:	0f400d56 	jal	9d003558 <MACPutHeader>
9d003ab8:	24050006 	li	a1,6
    MACPutArray((BYTE*)packet, sizeof(*packet));
9d003abc:	02002021 	move	a0,s0
9d003ac0:	0f400d45 	jal	9d003514 <MACPutArray>
9d003ac4:	2405001c 	li	a1,28
    MACFlush();
9d003ac8:	0f400d77 	jal	9d0035dc <MACFlush>
9d003acc:	00000000 	nop
	
	return TRUE;
}
9d003ad0:	8fbf0014 	lw	ra,20(sp)
9d003ad4:	24020001 	li	v0,1
9d003ad8:	8fb00010 	lw	s0,16(sp)
9d003adc:	03e00008 	jr	ra
9d003ae0:	27bd0018 	addiu	sp,sp,24

9d003ae4 <ARPResolve>:

	To retrieve the ARP query result, call the ARPIsResolved() function.
  ***************************************************************************/
#ifdef STACK_CLIENT_MODE
void ARPResolve(IP_ADDR* IPAddr)
{
9d003ae4:	27bdffc8 	addiu	sp,sp,-56
	packet.TargetMACAddr.v[4]   = 0xff;
	packet.TargetMACAddr.v[5]   = 0xff;


    // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9d003ae8:	3c05a001 	lui	a1,0xa001

	To retrieve the ARP query result, call the ARPIsResolved() function.
  ***************************************************************************/
#ifdef STACK_CLIENT_MODE
void ARPResolve(IP_ADDR* IPAddr)
{
9d003aec:	afbf0034 	sw	ra,52(sp)
	packet.TargetMACAddr.v[4]   = 0xff;
	packet.TargetMACAddr.v[5]   = 0xff;


    // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9d003af0:	24a29a5c 	addiu	v0,a1,-26020
9d003af4:	88470003 	lwl	a3,3(v0)
9d003af8:	88460007 	lwl	a2,7(v0)
	}
#endif
#endif

	packet.Operation            = ARP_OPERATION_REQ;
	packet.TargetMACAddr.v[0]   = 0xff;
9d003afc:	2403ffff 	li	v1,-1
9d003b00:	a3a30022 	sb	v1,34(sp)
	packet.TargetMACAddr.v[1]   = 0xff;
9d003b04:	a3a30023 	sb	v1,35(sp)
	packet.TargetMACAddr.v[2]   = 0xff;
9d003b08:	a3a30024 	sb	v1,36(sp)
	packet.TargetMACAddr.v[3]   = 0xff;
9d003b0c:	a3a30025 	sb	v1,37(sp)
	packet.TargetMACAddr.v[4]   = 0xff;
9d003b10:	a3a30026 	sb	v1,38(sp)
	packet.TargetMACAddr.v[5]   = 0xff;
9d003b14:	a3a30027 	sb	v1,39(sp)


    // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9d003b18:	8c830000 	lw	v1,0(a0)
9d003b1c:	98a79a5c 	lwr	a3,-26020(a1)
9d003b20:	98460004 	lwr	a2,4(v0)
		return;
	}
#endif
#endif

	packet.Operation            = ARP_OPERATION_REQ;
9d003b24:	24040001 	li	a0,1
	packet.TargetMACAddr.v[4]   = 0xff;
	packet.TargetMACAddr.v[5]   = 0xff;


    // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9d003b28:	00e33826 	xor	a3,a3,v1
9d003b2c:	00e63024 	and	a2,a3,a2
9d003b30:	14c00007 	bnez	a2,9d003b50 <ARPResolve+0x6c>
9d003b34:	a7a40016 	sh	a0,22(sp)
#ifdef STACK_USE_ZEROCONF_LINK_LOCAL
	packet.SenderIPAddr			= AppConfig.MyIPAddr;
#endif

    ARPPut(&packet);
9d003b38:	27a40010 	addiu	a0,sp,16
9d003b3c:	0f400e87 	jal	9d003a1c <ARPPut>
9d003b40:	afa30028 	sw	v1,40(sp)
}
9d003b44:	8fbf0034 	lw	ra,52(sp)
9d003b48:	03e00008 	jr	ra
9d003b4c:	27bd0038 	addiu	sp,sp,56
	packet.TargetMACAddr.v[4]   = 0xff;
	packet.TargetMACAddr.v[5]   = 0xff;


    // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9d003b50:	8843000b 	lwl	v1,11(v0)
#ifdef STACK_USE_ZEROCONF_LINK_LOCAL
	packet.SenderIPAddr			= AppConfig.MyIPAddr;
#endif

    ARPPut(&packet);
9d003b54:	27a40010 	addiu	a0,sp,16
	packet.TargetMACAddr.v[4]   = 0xff;
	packet.TargetMACAddr.v[5]   = 0xff;


    // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9d003b58:	98430008 	lwr	v1,8(v0)
#ifdef STACK_USE_ZEROCONF_LINK_LOCAL
	packet.SenderIPAddr			= AppConfig.MyIPAddr;
#endif

    ARPPut(&packet);
9d003b5c:	0f400e87 	jal	9d003a1c <ARPPut>
9d003b60:	afa30028 	sw	v1,40(sp)
}
9d003b64:	8fbf0034 	lw	ra,52(sp)
9d003b68:	03e00008 	jr	ra
9d003b6c:	27bd0038 	addiu	sp,sp,56

9d003b70 <ARPProcess>:
	{
	    SM_ARP_IDLE = 0,
	    SM_ARP_REPLY
	} smARP = SM_ARP_IDLE;

    switch(smARP)
9d003b70:	8f8280c4 	lw	v0,-32572(gp)
  			again until a new ARP packet is waiting in the RX buffer.
  	FALSE - This function must be called again.  More time is needed to 
  			send an ARP response.
  ***************************************************************************/
BOOL ARPProcess(void)
{
9d003b74:	27bdffc8 	addiu	sp,sp,-56
9d003b78:	afbf0034 	sw	ra,52(sp)
	{
	    SM_ARP_IDLE = 0,
	    SM_ARP_REPLY
	} smARP = SM_ARP_IDLE;

    switch(smARP)
9d003b7c:	14400012 	bnez	v0,9d003bc8 <ARPProcess+0x58>
9d003b80:	afb00030 	sw	s0,48(sp)
    {
	    case SM_ARP_IDLE:
			// Obtain the incoming ARP packet
		    MACGetArray((BYTE*)&packet, sizeof(packet));		
9d003b84:	27b00010 	addiu	s0,sp,16
9d003b88:	2405001c 	li	a1,28
9d003b8c:	0f400e15 	jal	9d003854 <MACGetArray>
9d003b90:	02002021 	move	a0,s0
		    MACDiscardRx();
9d003b94:	0f400d87 	jal	9d00361c <MACDiscardRx>
9d003b98:	00000000 	nop
		    SwapARPPacket(&packet);
9d003b9c:	0f400e75 	jal	9d0039d4 <SwapARPPacket>
9d003ba0:	02002021 	move	a0,s0
		
			// Validate the ARP packet
		    if ( packet.HardwareType != HW_ETHERNET     ||
9d003ba4:	97a20010 	lhu	v0,16(sp)
		         packet.MACAddrLen != sizeof(MAC_ADDR)  ||
		         packet.ProtocolLen != sizeof(IP_ADDR) )
		    {
		         return TRUE;
9d003ba8:	24030001 	li	v1,1
		    MACGetArray((BYTE*)&packet, sizeof(packet));		
		    MACDiscardRx();
		    SwapARPPacket(&packet);
		
			// Validate the ARP packet
		    if ( packet.HardwareType != HW_ETHERNET     ||
9d003bac:	10430025 	beq	v0,v1,9d003c44 <ARPProcess+0xd4>
9d003bb0:	97a50014 	lhu	a1,20(sp)
			smARP = SM_ARP_IDLE;
	        break;
	}

    return TRUE;
}
9d003bb4:	8fbf0034 	lw	ra,52(sp)
9d003bb8:	00601021 	move	v0,v1
9d003bbc:	8fb00030 	lw	s0,48(sp)
9d003bc0:	03e00008 	jr	ra
9d003bc4:	27bd0038 	addiu	sp,sp,56
	{
	    SM_ARP_IDLE = 0,
	    SM_ARP_REPLY
	} smARP = SM_ARP_IDLE;

    switch(smARP)
9d003bc8:	24030001 	li	v1,1
9d003bcc:	10430006 	beq	v0,v1,9d003be8 <ARPProcess+0x78>
9d003bd0:	8fbf0034 	lw	ra,52(sp)
			// Begin listening for ARP requests again
			smARP = SM_ARP_IDLE;
	        break;
	}

    return TRUE;
9d003bd4:	24030001 	li	v1,1
}
9d003bd8:	00601021 	move	v0,v1
9d003bdc:	8fb00030 	lw	s0,48(sp)
9d003be0:	03e00008 	jr	ra
9d003be4:	27bd0038 	addiu	sp,sp,56
9d003be8:	3c06a000 	lui	a2,0xa000
9d003bec:	27b00010 	addiu	s0,sp,16
9d003bf0:	24c346e8 	addiu	v1,a2,18152
                packet.TargetMACAddr.v[4] = 0xFF;
                packet.TargetMACAddr.v[5] = 0xFF;
            }
            else
            #endif
        	    packet.TargetMACAddr	= Target.MACAddr;
9d003bf4:	8c620004 	lw	v0,4(v1)
9d003bf8:	94650008 	lhu	a1,8(v1)
    	    packet.TargetIPAddr		= Target.IPAddr;
9d003bfc:	8cc346e8 	lw	v1,18152(a2)
				smARP = SM_ARP_REPLY;
			}
			// Do not break.  If we get down here, we need to send a reply.	

	    case SM_ARP_REPLY:
	        packet.Operation		= ARP_OPERATION_RESP;
9d003c00:	24040002 	li	a0,2
9d003c04:	a7a40016 	sh	a0,22(sp)
                packet.TargetMACAddr.v[4] = 0xFF;
                packet.TargetMACAddr.v[5] = 0xFF;
            }
            else
            #endif
        	    packet.TargetMACAddr	= Target.MACAddr;
9d003c08:	aba20025 	swl	v0,37(sp)
#ifdef STACK_USE_ZEROCONF_LINK_LOCAL
            packet.SenderIPAddr		= AppConfig.MyIPAddr;
#endif

			// Send an ARP response to a previously received request
			if(!ARPPut(&packet))
9d003c0c:	02002021 	move	a0,s0
                packet.TargetMACAddr.v[4] = 0xFF;
                packet.TargetMACAddr.v[5] = 0xFF;
            }
            else
            #endif
        	    packet.TargetMACAddr	= Target.MACAddr;
9d003c10:	bba20022 	swr	v0,34(sp)
    	    packet.TargetIPAddr		= Target.IPAddr;
9d003c14:	afa30028 	sw	v1,40(sp)
#ifdef STACK_USE_ZEROCONF_LINK_LOCAL
            packet.SenderIPAddr		= AppConfig.MyIPAddr;
#endif

			// Send an ARP response to a previously received request
			if(!ARPPut(&packet))
9d003c18:	0f400e87 	jal	9d003a1c <ARPPut>
9d003c1c:	a7a50026 	sh	a1,38(sp)
9d003c20:	1040ffe4 	beqz	v0,9d003bb4 <ARPProcess+0x44>
9d003c24:	00001821 	move	v1,zero
			smARP = SM_ARP_IDLE;
	        break;
	}

    return TRUE;
}
9d003c28:	8fbf0034 	lw	ra,52(sp)
			// Begin listening for ARP requests again
			smARP = SM_ARP_IDLE;
	        break;
	}

    return TRUE;
9d003c2c:	24030001 	li	v1,1
}
9d003c30:	00601021 	move	v0,v1
9d003c34:	8fb00030 	lw	s0,48(sp)
			{
	           return FALSE;
			}

			// Begin listening for ARP requests again
			smARP = SM_ARP_IDLE;
9d003c38:	af8080c4 	sw	zero,-32572(gp)
	        break;
	}

    return TRUE;
}
9d003c3c:	03e00008 	jr	ra
9d003c40:	27bd0038 	addiu	sp,sp,56
		    MACDiscardRx();
		    SwapARPPacket(&packet);
		
			// Validate the ARP packet
		    if ( packet.HardwareType != HW_ETHERNET     ||
		         packet.MACAddrLen != sizeof(MAC_ADDR)  ||
9d003c44:	24040406 	li	a0,1030
9d003c48:	14a4ffdb 	bne	a1,a0,9d003bb8 <ARPProcess+0x48>
9d003c4c:	8fbf0034 	lw	ra,52(sp)
			ARPProcessRxPkt(&packet);
#endif

			// Handle incoming ARP responses
#ifdef STACK_CLIENT_MODE
			if(packet.Operation == ARP_OPERATION_RESP)
9d003c50:	97a40016 	lhu	a0,22(sp)
9d003c54:	24050002 	li	a1,2
9d003c58:	50850017 	beql	a0,a1,9d003cb8 <ARPProcess+0x148>
9d003c5c:	8ba20021 	lwl	v0,33(sp)
				return TRUE;
			}
#endif

			// Handle incoming ARP requests for our MAC address
			if(packet.Operation == ARP_OPERATION_REQ)
9d003c60:	10820003 	beq	a0,v0,9d003c70 <ARPProcess+0x100>
9d003c64:	3c06a000 	lui	a2,0xa000
9d003c68:	0b400efd 	j	9d003bf4 <ARPProcess+0x84>
9d003c6c:	24c346e8 	addiu	v1,a2,18152
			{
				if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val)
9d003c70:	3c02a001 	lui	v0,0xa001
9d003c74:	24439a5c 	addiu	v1,v0,-26020
9d003c78:	88650003 	lwl	a1,3(v1)
9d003c7c:	98459a5c 	lwr	a1,-26020(v0)
9d003c80:	8fa20028 	lw	v0,40(sp)
9d003c84:	1445ffcb 	bne	v0,a1,9d003bb4 <ARPProcess+0x44>
9d003c88:	00801821 	move	v1,a0
                    {
                        AutoIPConflict(i);
                        return TRUE;
                    }             
                #endif
				Target.IPAddr = packet.SenderIPAddr;
9d003c8c:	8ba20021 	lwl	v0,33(sp)
9d003c90:	3c06a000 	lui	a2,0xa000
				Target.MACAddr = packet.SenderMACAddr;
9d003c94:	24c346e8 	addiu	v1,a2,18152
                    {
                        AutoIPConflict(i);
                        return TRUE;
                    }             
                #endif
				Target.IPAddr = packet.SenderIPAddr;
9d003c98:	9ba2001e 	lwr	v0,30(sp)
				Target.MACAddr = packet.SenderMACAddr;

				smARP = SM_ARP_REPLY;
9d003c9c:	af8480c4 	sw	a0,-32572(gp)
                    {
                        AutoIPConflict(i);
                        return TRUE;
                    }             
                #endif
				Target.IPAddr = packet.SenderIPAddr;
9d003ca0:	acc246e8 	sw	v0,18152(a2)
				Target.MACAddr = packet.SenderMACAddr;
9d003ca4:	8fa20018 	lw	v0,24(sp)
9d003ca8:	ac620004 	sw	v0,4(v1)
9d003cac:	97a2001c 	lhu	v0,28(sp)
9d003cb0:	0b400efd 	j	9d003bf4 <ARPProcess+0x84>
9d003cb4:	a4620008 	sh	v0,8(v1)
                #if defined(STACK_USE_AUTO_IP)
                for (i = 0; i < NETWORK_INTERFACES; i++)
                    if (AutoIPConfigIsInProgress(i))
                        AutoIPConflict(i);
                #endif
				Cache.MACAddr = packet.SenderMACAddr;
9d003cb8:	8fa60018 	lw	a2,24(sp)
9d003cbc:	3c04a000 	lui	a0,0xa000
9d003cc0:	248546dc 	addiu	a1,a0,18140
				Cache.IPAddr = packet.SenderIPAddr;
9d003cc4:	9ba2001e 	lwr	v0,30(sp)
                #if defined(STACK_USE_AUTO_IP)
                for (i = 0; i < NETWORK_INTERFACES; i++)
                    if (AutoIPConfigIsInProgress(i))
                        AutoIPConflict(i);
                #endif
				Cache.MACAddr = packet.SenderMACAddr;
9d003cc8:	aca60004 	sw	a2,4(a1)
9d003ccc:	97a6001c 	lhu	a2,28(sp)
				Cache.IPAddr = packet.SenderIPAddr;
9d003cd0:	ac8246dc 	sw	v0,18140(a0)
				return TRUE;
9d003cd4:	0b400eed 	j	9d003bb4 <ARPProcess+0x44>
9d003cd8:	a4a60008 	sh	a2,8(a1)

9d003cdc <ICMPProcess>:
 * Overview:        None
 *
 * Note:            None
 ********************************************************************/
void ICMPProcess(NODE_INFO *remote, WORD len)
{
9d003cdc:	27bdffd8 	addiu	sp,sp,-40
9d003ce0:	afb10020 	sw	s1,32(sp)
9d003ce4:	afb0001c 	sw	s0,28(sp)
9d003ce8:	00808821 	move	s1,a0
9d003cec:	30b0ffff 	andi	s0,a1,0xffff
	DWORD_VAL dwVal;

    // Obtain the ICMP header Type, Code, and Checksum fields
    MACGetArray((BYTE*)&dwVal, sizeof(dwVal));
9d003cf0:	27a40010 	addiu	a0,sp,16
 * Overview:        None
 *
 * Note:            None
 ********************************************************************/
void ICMPProcess(NODE_INFO *remote, WORD len)
{
9d003cf4:	afbf0024 	sw	ra,36(sp)
	DWORD_VAL dwVal;

    // Obtain the ICMP header Type, Code, and Checksum fields
    MACGetArray((BYTE*)&dwVal, sizeof(dwVal));
9d003cf8:	0f400e15 	jal	9d003854 <MACGetArray>
9d003cfc:	24050004 	li	a1,4
	
	// See if this is an ICMP echo (ping) request
	if(dwVal.w[0] == 0x0008u)
9d003d00:	97a20010 	lhu	v0,16(sp)
9d003d04:	24030008 	li	v1,8
9d003d08:	10430021 	beq	v0,v1,9d003d90 <ICMPProcess+0xb4>
9d003d0c:	24040014 	li	a0,20
	
		// Transmit the echo reply packet
	    MACFlush();
	}
#if defined(STACK_USE_ICMP_CLIENT)
	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request
9d003d10:	10400006 	beqz	v0,9d003d2c <ICMPProcess+0x50>
9d003d14:	27a40010 	addiu	a0,sp,16
		// Flag that we received the response and stop the timer ticking
		ICMPFlags.bReplyValid = 1;
		ICMPTimer = TickGet() - ICMPTimer;
	}
#endif
}
9d003d18:	8fbf0024 	lw	ra,36(sp)
9d003d1c:	8fb10020 	lw	s1,32(sp)
9d003d20:	8fb0001c 	lw	s0,28(sp)
9d003d24:	03e00008 	jr	ra
9d003d28:	27bd0028 	addiu	sp,sp,40
	}
#if defined(STACK_USE_ICMP_CLIENT)
	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request
	{
		// Get the sequence number and identifier fields
		MACGetArray((BYTE*)&dwVal, sizeof(dwVal));
9d003d2c:	0f400e15 	jal	9d003854 <MACGetArray>
9d003d30:	24050004 	li	a1,4
		
		// See if the identifier matches the one we sent
		if(dwVal.w[0] != 0xEFBE)	
9d003d34:	97a30010 	lhu	v1,16(sp)
9d003d38:	3402efbe 	li	v0,0xefbe
9d003d3c:	1462fff7 	bne	v1,v0,9d003d1c <ICMPProcess+0x40>
9d003d40:	8fbf0024 	lw	ra,36(sp)
			return;
	
		if(dwVal.w[1] != wICMPSequenceNumber)
9d003d44:	97a30012 	lhu	v1,18(sp)
9d003d48:	978280cc 	lhu	v0,-32564(gp)
9d003d4c:	1462fff4 	bne	v1,v0,9d003d20 <ICMPProcess+0x44>
9d003d50:	8fb10020 	lw	s1,32(sp)
			return;

		// Validate the ICMP checksum field
	    IPSetRxBuffer(0);
9d003d54:	0f4024f1 	jal	9d0093c4 <IPSetRxBuffer>
9d003d58:	00002021 	move	a0,zero
		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request
9d003d5c:	0f400e43 	jal	9d00390c <CalcIPBufferChecksum>
9d003d60:	2404000a 	li	a0,10
9d003d64:	1440ffed 	bnez	v0,9d003d1c <ICMPProcess+0x40>
9d003d68:	8fbf0024 	lw	ra,36(sp)
			return;
		
		// Flag that we received the response and stop the timer ticking
		ICMPFlags.bReplyValid = 1;
9d003d6c:	938280c8 	lbu	v0,-32568(gp)
9d003d70:	24030001 	li	v1,1
9d003d74:	7c620844 	ins	v0,v1,0x1,0x1
		ICMPTimer = TickGet() - ICMPTimer;
9d003d78:	0f400b53 	jal	9d002d4c <TickGet>
9d003d7c:	a38280c8 	sb	v0,-32568(gp)
9d003d80:	8f8380d0 	lw	v1,-32560(gp)
9d003d84:	00431023 	subu	v0,v0,v1
9d003d88:	0b400f46 	j	9d003d18 <ICMPProcess+0x3c>
9d003d8c:	af8280d0 	sw	v0,-32560(gp)
	{
		// Validate the checksum using the Microchip MAC's DMA module
		// The checksum data includes the precomputed checksum in the 
		// header, so a valid packet will always have a checksum of 
		// 0x0000 if the packet is not disturbed.
		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len))
9d003d90:	0f400e46 	jal	9d003918 <MACCalcRxChecksum>
9d003d94:	02002821 	move	a1,s0
9d003d98:	1440ffdf 	bnez	v0,9d003d18 <ICMPProcess+0x3c>
9d003d9c:	93a20012 	lbu	v0,18(sp)
			return;
	
		// Calculate new Type, Code, and Checksum values
		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply)
9d003da0:	a3a00010 	sb	zero,16(sp)
		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum
9d003da4:	24420008 	addiu	v0,v0,8
9d003da8:	304200ff 	andi	v0,v0,0xff
		if(dwVal.v[2] < 8u)
9d003dac:	2c430008 	sltiu	v1,v0,8
9d003db0:	10600008 	beqz	v1,9d003dd4 <ICMPProcess+0xf8>
9d003db4:	a3a20012 	sb	v0,18(sp)
		{
			dwVal.v[3]++;
9d003db8:	93a30013 	lbu	v1,19(sp)
9d003dbc:	24630001 	addiu	v1,v1,1
9d003dc0:	306300ff 	andi	v1,v1,0xff
			if(dwVal.v[3] == 0u)
9d003dc4:	14600003 	bnez	v1,9d003dd4 <ICMPProcess+0xf8>
9d003dc8:	a3a30013 	sb	v1,19(sp)
				dwVal.v[2]++;
9d003dcc:	24420001 	addiu	v0,v0,1
9d003dd0:	a3a20012 	sb	v0,18(sp)
		}
	
	    // Wait for TX hardware to become available (finish transmitting 
	    // any previous packet)
	    while(!IPIsTxReady());
9d003dd4:	0f400cf1 	jal	9d0033c4 <MACIsTxReady>
9d003dd8:	00000000 	nop
9d003ddc:	1040fffd 	beqz	v0,9d003dd4 <ICMPProcess+0xf8>
9d003de0:	00000000 	nop

		// Position the write pointer for the next IPPutHeader operation
		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility
	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9d003de4:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d003de8:	00000000 	nop
9d003dec:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d003df0:	2444000e 	addiu	a0,v0,14
        	
		// Create IP header in TX memory
		IPPutHeader(remote, IP_PROT_ICMP, len);
9d003df4:	02003021 	move	a2,s0
9d003df8:	02202021 	move	a0,s1
9d003dfc:	0f4024b9 	jal	9d0092e4 <IPPutHeader>
9d003e00:	24050001 	li	a1,1
	
		// Copy ICMP response into the TX memory
		MACPutArray((BYTE*)&dwVal, sizeof(dwVal));
9d003e04:	27a40010 	addiu	a0,sp,16
9d003e08:	0f400d45 	jal	9d003514 <MACPutArray>
9d003e0c:	24050004 	li	a1,4
		MACMemCopyAsync(-1, -1, len-4);
9d003e10:	2606fffc 	addiu	a2,s0,-4
9d003e14:	2404ffff 	li	a0,-1
9d003e18:	2405ffff 	li	a1,-1
9d003e1c:	0f400e2f 	jal	9d0038bc <MACMemCopyAsync>
9d003e20:	30c6ffff 	andi	a2,a2,0xffff
		while(!MACIsMemCopyDone());
9d003e24:	0f400e41 	jal	9d003904 <MACIsMemCopyDone>
9d003e28:	00000000 	nop
9d003e2c:	1040fffd 	beqz	v0,9d003e24 <ICMPProcess+0x148>
9d003e30:	00000000 	nop
	
		// Transmit the echo reply packet
	    MACFlush();
9d003e34:	0f400d77 	jal	9d0035dc <MACFlush>
9d003e38:	00000000 	nop
		// Flag that we received the response and stop the timer ticking
		ICMPFlags.bReplyValid = 1;
		ICMPTimer = TickGet() - ICMPTimer;
	}
#endif
}
9d003e3c:	0b400f47 	j	9d003d1c <ICMPProcess+0x40>
9d003e40:	8fbf0024 	lw	ra,36(sp)

9d003e44 <DNSPutString>:

  Returns:
  	None
  ***************************************************************************/
static void DNSPutString(BYTE* String)
{
9d003e44:	27bdffc8 	addiu	sp,sp,-56
9d003e48:	afb50030 	sw	s5,48(sp)
9d003e4c:	afb4002c 	sw	s4,44(sp)
9d003e50:	afb30028 	sw	s3,40(sp)
9d003e54:	afb20024 	sw	s2,36(sp)
9d003e58:	afb10020 	sw	s1,32(sp)
9d003e5c:	afb0001c 	sw	s0,28(sp)
9d003e60:	afbf0034 	sw	ra,52(sp)
9d003e64:	00809021 	move	s2,a0
	BYTE *RightPtr;
	BYTE i;
	BYTE Len;

	RightPtr = String;
9d003e68:	00808821 	move	s1,a0
	while(1)
	{
		do
		{
			i = *RightPtr++;
		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
9d003e6c:	2413002e 	li	s3,46
9d003e70:	2414002f 	li	s4,47
9d003e74:	2415002c 	li	s5,44
9d003e78:	2410003e 	li	s0,62

	while(1)
	{
		do
		{
			i = *RightPtr++;
9d003e7c:	92220000 	lbu	v0,0(s1)
		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
9d003e80:	1040001c 	beqz	v0,9d003ef4 <DNSPutString+0xb0>
9d003e84:	26310001 	addiu	s1,s1,1
9d003e88:	1053001d 	beq	v0,s3,9d003f00 <DNSPutString+0xbc>
9d003e8c:	02322823 	subu	a1,s1,s2
9d003e90:	10540019 	beq	v0,s4,9d003ef8 <DNSPutString+0xb4>
9d003e94:	2625ffff 	addiu	a1,s1,-1
9d003e98:	10550004 	beq	v0,s5,9d003eac <DNSPutString+0x68>
9d003e9c:	02322823 	subu	a1,s1,s2
9d003ea0:	5450fff7 	bnel	v0,s0,9d003e80 <DNSPutString+0x3c>
9d003ea4:	92220000 	lbu	v0,0(s1)
	
		// Put the length and data
		// Also, skip over the '.' in the input string
		Len = (BYTE)(RightPtr-String-1);
9d003ea8:	02322823 	subu	a1,s1,s2
9d003eac:	24a5ffff 	addiu	a1,a1,-1
		UDPPut(Len);
9d003eb0:	30a500ff 	andi	a1,a1,0xff
9d003eb4:	00a02021 	move	a0,a1
9d003eb8:	0f40125d 	jal	9d004974 <UDPPut>
9d003ebc:	afa50010 	sw	a1,16(sp)
		String += UDPPutArray(String, Len) + 1;
9d003ec0:	8fa50010 	lw	a1,16(sp)
9d003ec4:	0f401275 	jal	9d0049d4 <UDPPutArray>
9d003ec8:	02402021 	move	a0,s2
			break;
	}
	
	// Put the string null terminator character (zero length label)
	UDPPut(0x00);
}
9d003ecc:	8fbf0034 	lw	ra,52(sp)
9d003ed0:	8fb50030 	lw	s5,48(sp)
9d003ed4:	8fb4002c 	lw	s4,44(sp)
9d003ed8:	8fb30028 	lw	s3,40(sp)
9d003edc:	8fb20024 	lw	s2,36(sp)
9d003ee0:	8fb10020 	lw	s1,32(sp)
9d003ee4:	8fb0001c 	lw	s0,28(sp)
		if(i == 0x00u || i == '/' || i == ',' || i == '>')
			break;
	}
	
	// Put the string null terminator character (zero length label)
	UDPPut(0x00);
9d003ee8:	00002021 	move	a0,zero
9d003eec:	0b40125d 	j	9d004974 <UDPPut>
9d003ef0:	27bd0038 	addiu	sp,sp,56
			i = *RightPtr++;
		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
	
		// Put the length and data
		// Also, skip over the '.' in the input string
		Len = (BYTE)(RightPtr-String-1);
9d003ef4:	2625ffff 	addiu	a1,s1,-1
9d003ef8:	0b400fac 	j	9d003eb0 <DNSPutString+0x6c>
9d003efc:	00b22823 	subu	a1,a1,s2
9d003f00:	24a5ffff 	addiu	a1,a1,-1
		UDPPut(Len);
9d003f04:	30a500ff 	andi	a1,a1,0xff
9d003f08:	00a02021 	move	a0,a1
9d003f0c:	0f40125d 	jal	9d004974 <UDPPut>
9d003f10:	afa50010 	sw	a1,16(sp)
		String += UDPPutArray(String, Len) + 1;
9d003f14:	8fa50010 	lw	a1,16(sp)
9d003f18:	0f401275 	jal	9d0049d4 <UDPPutArray>
9d003f1c:	02402021 	move	a0,s2
9d003f20:	24420001 	addiu	v0,v0,1
9d003f24:	0b400f9f 	j	9d003e7c <DNSPutString+0x38>
9d003f28:	02429021 	addu	s2,s2,v0

9d003f2c <DNSDiscardName>:

  Returns:
  	None
  ***************************************************************************/
static void DNSDiscardName(void)
{
9d003f2c:	27bdffe0 	addiu	sp,sp,-32
9d003f30:	afb00018 	sw	s0,24(sp)
9d003f34:	afbf001c 	sw	ra,28(sp)
		// length of the first of a series of labels
		if(!UDPGet(&i))
			return;
		
		// Check if this is a pointer, if so, get the reminaing 8 bits and return
		if((i & 0xC0u) == 0xC0u)
9d003f38:	0b400fd8 	j	9d003f60 <DNSDiscardName+0x34>
9d003f3c:	241000c0 	li	s0,192
9d003f40:	93a20010 	lbu	v0,16(sp)
9d003f44:	304300c0 	andi	v1,v0,0xc0
9d003f48:	1070000d 	beq	v1,s0,9d003f80 <DNSDiscardName+0x54>
9d003f4c:	00402821 	move	a1,v0
			UDPGet(&i);
			return;
		}

		// Exit once we reach a zero length label
		if(i == 0u)					
9d003f50:	10400008 	beqz	v0,9d003f74 <DNSDiscardName+0x48>
9d003f54:	8fbf001c 	lw	ra,28(sp)
			return;

		// Discard complete label
		UDPGetArray(NULL, i);		
9d003f58:	0f401313 	jal	9d004c4c <UDPGetArray>
9d003f5c:	00000000 	nop

	while(1)
	{
		// Get first byte which will tell us if this is a 16-bit pointer or the 
		// length of the first of a series of labels
		if(!UDPGet(&i))
9d003f60:	0f4012fa 	jal	9d004be8 <UDPGet>
9d003f64:	27a40010 	addiu	a0,sp,16
9d003f68:	1440fff5 	bnez	v0,9d003f40 <DNSDiscardName+0x14>
9d003f6c:	00002021 	move	a0,zero
			return;

		// Discard complete label
		UDPGetArray(NULL, i);		
	}
}
9d003f70:	8fbf001c 	lw	ra,28(sp)
9d003f74:	8fb00018 	lw	s0,24(sp)
9d003f78:	03e00008 	jr	ra
9d003f7c:	27bd0020 	addiu	sp,sp,32
			return;
		
		// Check if this is a pointer, if so, get the reminaing 8 bits and return
		if((i & 0xC0u) == 0xC0u)
		{
			UDPGet(&i);
9d003f80:	0f4012fa 	jal	9d004be8 <UDPGet>
9d003f84:	27a40010 	addiu	a0,sp,16
			return;

		// Discard complete label
		UDPGetArray(NULL, i);		
	}
}
9d003f88:	8fbf001c 	lw	ra,28(sp)
9d003f8c:	8fb00018 	lw	s0,24(sp)
9d003f90:	03e00008 	jr	ra
9d003f94:	27bd0020 	addiu	sp,sp,32

9d003f98 <DNSBeginUsage>:
	obtained control of the DNS module.  If this is not done, the stack
	will hang for all future applications requiring DNS access.
  ***************************************************************************/
BOOL DNSBeginUsage(void)
{
	if(Flags.bits.DNSInUse)
9d003f98:	938380e0 	lbu	v1,-32544(gp)
9d003f9c:	30640001 	andi	a0,v1,0x1
9d003fa0:	14800004 	bnez	a0,9d003fb4 <DNSBeginUsage+0x1c>
9d003fa4:	00001021 	move	v0,zero
		return FALSE;

	Flags.bits.DNSInUse = TRUE;
9d003fa8:	24020001 	li	v0,1
9d003fac:	7c430004 	ins	v1,v0,0x0,0x1
9d003fb0:	a38380e0 	sb	v1,-32544(gp)
	return TRUE;
}
9d003fb4:	03e00008 	jr	ra
9d003fb8:	00000000 	nop

9d003fbc <DNSEndUsage>:
	obtained control of the DNS module.  If this is not done, the stack
	will hang for all future applications requiring DNS access.
  ***************************************************************************/
BOOL DNSEndUsage(void)
{
	if(MySocket != INVALID_UDP_SOCKET)
9d003fbc:	93848020 	lbu	a0,-32736(gp)
	Ensure that DNSEndUsage is always called once your application has
	obtained control of the DNS module.  If this is not done, the stack
	will hang for all future applications requiring DNS access.
  ***************************************************************************/
BOOL DNSEndUsage(void)
{
9d003fc0:	27bdffe8 	addiu	sp,sp,-24
	if(MySocket != INVALID_UDP_SOCKET)
9d003fc4:	240200ff 	li	v0,255
9d003fc8:	10820005 	beq	a0,v0,9d003fe0 <DNSEndUsage+0x24>
9d003fcc:	afbf0014 	sw	ra,20(sp)
	{
		UDPClose(MySocket);
9d003fd0:	0f40121f 	jal	9d00487c <UDPClose>
9d003fd4:	00000000 	nop
		MySocket = INVALID_UDP_SOCKET;
9d003fd8:	2402ffff 	li	v0,-1
9d003fdc:	a3828020 	sb	v0,-32736(gp)
	}
	smDNS = DNS_DONE;
	Flags.bits.DNSInUse = FALSE;
9d003fe0:	938280e0 	lbu	v0,-32544(gp)

	return Flags.bits.AddressValid;
}
9d003fe4:	8fbf0014 	lw	ra,20(sp)
	if(MySocket != INVALID_UDP_SOCKET)
	{
		UDPClose(MySocket);
		MySocket = INVALID_UDP_SOCKET;
	}
	smDNS = DNS_DONE;
9d003fe8:	24030007 	li	v1,7
	Flags.bits.DNSInUse = FALSE;
9d003fec:	7c020004 	ins	v0,zero,0x0,0x1
9d003ff0:	a38280e0 	sb	v0,-32544(gp)
	if(MySocket != INVALID_UDP_SOCKET)
	{
		UDPClose(MySocket);
		MySocket = INVALID_UDP_SOCKET;
	}
	smDNS = DNS_DONE;
9d003ff4:	af83801c 	sw	v1,-32740(gp)
	Flags.bits.DNSInUse = FALSE;

	return Flags.bits.AddressValid;
}
9d003ff8:	7c420040 	ext	v0,v0,0x1,0x1
9d003ffc:	03e00008 	jr	ra
9d004000:	27bd0018 	addiu	sp,sp,24

9d004004 <DNSResolve>:
  Remarks:
	This function requires access to one UDP socket.  If none are available,
	MAX_UDP_SOCKETS may need to be increased.
  ***************************************************************************/
void DNSResolve(BYTE* Hostname, BYTE Type)
{
9d004004:	27bdffe0 	addiu	sp,sp,-32
9d004008:	afb00014 	sw	s0,20(sp)
9d00400c:	30b000ff 	andi	s0,a1,0xff
	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
9d004010:	3c05a000 	lui	a1,0xa000
9d004014:	24a546f4 	addiu	a1,a1,18164
  Remarks:
	This function requires access to one UDP socket.  If none are available,
	MAX_UDP_SOCKETS may need to be increased.
  ***************************************************************************/
void DNSResolve(BYTE* Hostname, BYTE Type)
{
9d004018:	afb10018 	sw	s1,24(sp)
9d00401c:	afbf001c 	sw	ra,28(sp)
	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
9d004020:	0f4025a5 	jal	9d009694 <StringToIPAddress>
9d004024:	00808821 	move	s1,a0
9d004028:	1440000c 	bnez	v0,9d00405c <DNSResolve+0x58>
9d00402c:	938280e0 	lbu	v0,-32544(gp)
		DNSHostNameROM = NULL;
		smDNS = DNS_START;
		RecordType = Type;
		Flags.bits.AddressValid = FALSE;
	}
}
9d004030:	8fbf001c 	lw	ra,28(sp)
		Flags.bits.AddressValid = TRUE;
		smDNS = DNS_DONE;
	}
	else
	{	
		DNSHostName = Hostname;
9d004034:	af9180d4 	sw	s1,-32556(gp)
		DNSHostNameROM = NULL;
		smDNS = DNS_START;
		RecordType = Type;
		Flags.bits.AddressValid = FALSE;
9d004038:	7c020844 	ins	v0,zero,0x1,0x1
	else
	{	
		DNSHostName = Hostname;
		DNSHostNameROM = NULL;
		smDNS = DNS_START;
		RecordType = Type;
9d00403c:	a39080dc 	sb	s0,-32548(gp)
		Flags.bits.AddressValid = FALSE;
	}
}
9d004040:	8fb10018 	lw	s1,24(sp)
9d004044:	8fb00014 	lw	s0,20(sp)
		smDNS = DNS_DONE;
	}
	else
	{	
		DNSHostName = Hostname;
		DNSHostNameROM = NULL;
9d004048:	af8080d8 	sw	zero,-32552(gp)
		smDNS = DNS_START;
9d00404c:	af80801c 	sw	zero,-32740(gp)
		RecordType = Type;
		Flags.bits.AddressValid = FALSE;
9d004050:	a38280e0 	sb	v0,-32544(gp)
	}
}
9d004054:	03e00008 	jr	ra
9d004058:	27bd0020 	addiu	sp,sp,32
  ***************************************************************************/
void DNSResolve(BYTE* Hostname, BYTE Type)
{
	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
	{
		Flags.bits.AddressValid = TRUE;
9d00405c:	24030001 	li	v1,1
		DNSHostNameROM = NULL;
		smDNS = DNS_START;
		RecordType = Type;
		Flags.bits.AddressValid = FALSE;
	}
}
9d004060:	8fbf001c 	lw	ra,28(sp)
  ***************************************************************************/
void DNSResolve(BYTE* Hostname, BYTE Type)
{
	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
	{
		Flags.bits.AddressValid = TRUE;
9d004064:	7c620844 	ins	v0,v1,0x1,0x1
9d004068:	a38280e0 	sb	v0,-32544(gp)
		smDNS = DNS_DONE;
9d00406c:	24020007 	li	v0,7
		DNSHostNameROM = NULL;
		smDNS = DNS_START;
		RecordType = Type;
		Flags.bits.AddressValid = FALSE;
	}
}
9d004070:	8fb10018 	lw	s1,24(sp)
9d004074:	8fb00014 	lw	s0,20(sp)
void DNSResolve(BYTE* Hostname, BYTE Type)
{
	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
	{
		Flags.bits.AddressValid = TRUE;
		smDNS = DNS_DONE;
9d004078:	af82801c 	sw	v0,-32740(gp)
		DNSHostNameROM = NULL;
		smDNS = DNS_START;
		RecordType = Type;
		Flags.bits.AddressValid = FALSE;
	}
}
9d00407c:	03e00008 	jr	ra
9d004080:	27bd0020 	addiu	sp,sp,32

9d004084 <DNSIsResolved>:
	BYTE 				i;
	WORD_VAL			w;
	DNS_HEADER			DNSHeader;
	DNS_ANSWER_HEADER	DNSAnswerHeader;

	switch(smDNS)
9d004084:	8f82801c 	lw	v0,-32740(gp)
  		errors include server timeout (i.e. DNS server not available), hostname 
  		not in the DNS, or DNS server errors.
  	FALSE - The resolution process is still in progress.
  ***************************************************************************/
BOOL DNSIsResolved(IP_ADDR* HostIP)
{
9d004088:	27bdffc0 	addiu	sp,sp,-64
9d00408c:	afb00030 	sw	s0,48(sp)
9d004090:	00808021 	move	s0,a0
	BYTE 				i;
	WORD_VAL			w;
	DNS_HEADER			DNSHeader;
	DNS_ANSWER_HEADER	DNSAnswerHeader;

	switch(smDNS)
9d004094:	2c440008 	sltiu	a0,v0,8
  		errors include server timeout (i.e. DNS server not available), hostname 
  		not in the DNS, or DNS server errors.
  	FALSE - The resolution process is still in progress.
  ***************************************************************************/
BOOL DNSIsResolved(IP_ADDR* HostIP)
{
9d004098:	afbf003c 	sw	ra,60(sp)
9d00409c:	afb20038 	sw	s2,56(sp)
9d0040a0:	afb10034 	sw	s1,52(sp)
	BYTE 				i;
	WORD_VAL			w;
	DNS_HEADER			DNSHeader;
	DNS_ANSWER_HEADER	DNSAnswerHeader;

	switch(smDNS)
9d0040a4:	10800055 	beqz	a0,9d0041fc <DNSIsResolved+0x178>
9d0040a8:	00001821 	move	v1,zero
9d0040ac:	3c039d01 	lui	v1,0x9d01
9d0040b0:	00021080 	sll	v0,v0,0x2
9d0040b4:	2463dc34 	addiu	v1,v1,-9164
9d0040b8:	00621021 	addu	v0,v1,v0
9d0040bc:	8c420000 	lw	v0,0(v0)
9d0040c0:	00400008 	jr	v0
9d0040c4:	00000000 	nop
			StartTime = TickGet();
			smDNS = DNS_ARP_RESOLVE;
			break;

		case DNS_ARP_RESOLVE:
			if(!ARPIsResolved(&AppConfig.PrimaryDNSServer, &ResolvedInfo.MACAddr))
9d0040c8:	3c04a001 	lui	a0,0xa001
9d0040cc:	3c05a000 	lui	a1,0xa000
9d0040d0:	24849a68 	addiu	a0,a0,-26008
9d0040d4:	0f400e57 	jal	9d00395c <ARPIsResolved>
9d0040d8:	24a546f8 	addiu	a1,a1,18168
9d0040dc:	10400125 	beqz	v0,9d004574 <DNSIsResolved+0x4f0>
9d0040e0:	3c02a001 	lui	v0,0xa001
			{
				if(TickGet() - StartTime > DNS_TIMEOUT)
					smDNS = (vARPAttemptCount >= 3u) ? DNS_FAIL : DNS_ARP_START_RESOLVE;
				break;
			}
			ResolvedInfo.IPAddr.Val = AppConfig.PrimaryDNSServer.Val;
9d0040e4:	24429a5c 	addiu	v0,v0,-26020
9d0040e8:	8843000f 	lwl	v1,15(v0)
9d0040ec:	3c11a000 	lui	s1,0xa000
9d0040f0:	9843000c 	lwr	v1,12(v0)
			smDNS = DNS_OPEN_SOCKET;
9d0040f4:	24020003 	li	v0,3
9d0040f8:	af82801c 	sw	v0,-32740(gp)
			{
				if(TickGet() - StartTime > DNS_TIMEOUT)
					smDNS = (vARPAttemptCount >= 3u) ? DNS_FAIL : DNS_ARP_START_RESOLVE;
				break;
			}
			ResolvedInfo.IPAddr.Val = AppConfig.PrimaryDNSServer.Val;
9d0040fc:	ae2346f4 	sw	v1,18164(s1)
			smDNS = DNS_OPEN_SOCKET;
			// No break: DNS_OPEN_SOCKET is the correct next state
		
		case DNS_OPEN_SOCKET:
			MySocket = UDPOpen(0, &ResolvedInfo, DNS_PORT);
9d004100:	00002021 	move	a0,zero
9d004104:	262546f4 	addiu	a1,s1,18164
9d004108:	0f4011e9 	jal	9d0047a4 <UDPOpen>
9d00410c:	24060035 	li	a2,53
9d004110:	00402021 	move	a0,v0
9d004114:	a3828020 	sb	v0,-32736(gp)
			if(MySocket == INVALID_UDP_SOCKET)
9d004118:	240200ff 	li	v0,255
9d00411c:	10820037 	beq	a0,v0,9d0041fc <DNSIsResolved+0x178>
9d004120:	00001821 	move	v1,zero
				break;

			smDNS = DNS_QUERY;
9d004124:	24020004 	li	v0,4
9d004128:	af82801c 	sw	v0,-32740(gp)
			// No need to break, we can immediately start resolution
			
		case DNS_QUERY:
			if(!UDPIsPutReady(MySocket))
9d00412c:	0f401246 	jal	9d004918 <UDPIsPutReady>
9d004130:	00000000 	nop
9d004134:	10400031 	beqz	v0,9d0041fc <DNSIsResolved+0x178>
9d004138:	00001821 	move	v1,zero
				break;
			
			// Put DNS query here
			SentTransactionID.Val++;
9d00413c:	978280e8 	lhu	v0,-32536(gp)
9d004140:	24420001 	addiu	v0,v0,1
			UDPPut(SentTransactionID.v[1]);// User chosen transaction ID
9d004144:	7c443a00 	ext	a0,v0,0x8,0x8
9d004148:	0f40125d 	jal	9d004974 <UDPPut>
9d00414c:	a78280e8 	sh	v0,-32536(gp)
			UDPPut(SentTransactionID.v[0]);
9d004150:	0f40125d 	jal	9d004974 <UDPPut>
9d004154:	938480e8 	lbu	a0,-32536(gp)
			UDPPut(0x01);		// Standard query with recursion
9d004158:	0f40125d 	jal	9d004974 <UDPPut>
9d00415c:	24040001 	li	a0,1
			UDPPut(0x00);	
9d004160:	0f40125d 	jal	9d004974 <UDPPut>
9d004164:	00002021 	move	a0,zero
			UDPPut(0x00);		// 0x0001 questions
9d004168:	0f40125d 	jal	9d004974 <UDPPut>
9d00416c:	00002021 	move	a0,zero
			UDPPut(0x01);
9d004170:	0f40125d 	jal	9d004974 <UDPPut>
9d004174:	24040001 	li	a0,1
			UDPPut(0x00);		// 0x0000 answers
9d004178:	0f40125d 	jal	9d004974 <UDPPut>
9d00417c:	00002021 	move	a0,zero
			UDPPut(0x00);
9d004180:	0f40125d 	jal	9d004974 <UDPPut>
9d004184:	00002021 	move	a0,zero
			UDPPut(0x00);		// 0x0000 name server resource records
9d004188:	0f40125d 	jal	9d004974 <UDPPut>
9d00418c:	00002021 	move	a0,zero
			UDPPut(0x00);
9d004190:	0f40125d 	jal	9d004974 <UDPPut>
9d004194:	00002021 	move	a0,zero
			UDPPut(0x00);		// 0x0000 additional records
9d004198:	0f40125d 	jal	9d004974 <UDPPut>
9d00419c:	00002021 	move	a0,zero
			UDPPut(0x00);
9d0041a0:	0f40125d 	jal	9d004974 <UDPPut>
9d0041a4:	00002021 	move	a0,zero

			// Put hostname string to resolve
			if(DNSHostName)
9d0041a8:	8f8480d4 	lw	a0,-32556(gp)
9d0041ac:	50800001 	beqzl	a0,9d0041b4 <DNSIsResolved+0x130>
9d0041b0:	8f8480d8 	lw	a0,-32552(gp)
				DNSPutString(DNSHostName);
			else
				DNSPutROMString(DNSHostNameROM);
9d0041b4:	0f400f91 	jal	9d003e44 <DNSPutString>
9d0041b8:	00000000 	nop

			UDPPut(0x00);		// Type: DNS_TYPE_A A (host address) or DNS_TYPE_MX for mail exchange
9d0041bc:	0f40125d 	jal	9d004974 <UDPPut>
9d0041c0:	00002021 	move	a0,zero
			UDPPut(RecordType);
9d0041c4:	0f40125d 	jal	9d004974 <UDPPut>
9d0041c8:	938480dc 	lbu	a0,-32548(gp)
			UDPPut(0x00);		// Class: IN (Internet)
9d0041cc:	0f40125d 	jal	9d004974 <UDPPut>
9d0041d0:	00002021 	move	a0,zero
			UDPPut(0x01);
9d0041d4:	0f40125d 	jal	9d004974 <UDPPut>
9d0041d8:	24040001 	li	a0,1

			UDPFlush();
9d0041dc:	0f40128c 	jal	9d004a30 <UDPFlush>
9d0041e0:	00000000 	nop
			StartTime = TickGet();
9d0041e4:	0f400b53 	jal	9d002d4c <TickGet>
9d0041e8:	00000000 	nop
9d0041ec:	af8280ec 	sw	v0,-32532(gp)
			smDNS = DNS_GET_RESULT;
9d0041f0:	24020005 	li	v0,5
9d0041f4:	af82801c 	sw	v0,-32740(gp)

			break;

	}
	
	return FALSE;
9d0041f8:	00001821 	move	v1,zero
}
9d0041fc:	8fbf003c 	lw	ra,60(sp)
9d004200:	00601021 	move	v0,v1
9d004204:	8fb20038 	lw	s2,56(sp)
9d004208:	8fb10034 	lw	s1,52(sp)
9d00420c:	8fb00030 	lw	s0,48(sp)
9d004210:	03e00008 	jr	ra
9d004214:	27bd0040 	addiu	sp,sp,64
	DNS_ANSWER_HEADER	DNSAnswerHeader;

	switch(smDNS)
	{
		case DNS_START:
			vARPAttemptCount = 0;
9d004218:	a38080e5 	sb	zero,-32539(gp)
			vDNSAttemptCount = 0;
9d00421c:	a38080e4 	sb	zero,-32540(gp)
			// No break;

		case DNS_ARP_START_RESOLVE:
			ARPResolve(&AppConfig.PrimaryDNSServer);
9d004220:	3c04a001 	lui	a0,0xa001
9d004224:	0f400eb9 	jal	9d003ae4 <ARPResolve>
9d004228:	24849a68 	addiu	a0,a0,-26008
			vARPAttemptCount++;
9d00422c:	938280e5 	lbu	v0,-32539(gp)
9d004230:	24420001 	addiu	v0,v0,1
			StartTime = TickGet();
9d004234:	0f400b53 	jal	9d002d4c <TickGet>
9d004238:	a38280e5 	sb	v0,-32539(gp)
			break;

	}
	
	return FALSE;
}
9d00423c:	8fbf003c 	lw	ra,60(sp)
			// No break;

		case DNS_ARP_START_RESOLVE:
			ARPResolve(&AppConfig.PrimaryDNSServer);
			vARPAttemptCount++;
			StartTime = TickGet();
9d004240:	af8280ec 	sw	v0,-32532(gp)

			break;

	}
	
	return FALSE;
9d004244:	00001821 	move	v1,zero

		case DNS_ARP_START_RESOLVE:
			ARPResolve(&AppConfig.PrimaryDNSServer);
			vARPAttemptCount++;
			StartTime = TickGet();
			smDNS = DNS_ARP_RESOLVE;
9d004248:	24020002 	li	v0,2
9d00424c:	af82801c 	sw	v0,-32740(gp)
			break;

	}
	
	return FALSE;
}
9d004250:	8fb20038 	lw	s2,56(sp)
9d004254:	00601021 	move	v0,v1
9d004258:	8fb10034 	lw	s1,52(sp)
9d00425c:	8fb00030 	lw	s0,48(sp)
9d004260:	03e00008 	jr	ra
9d004264:	27bd0040 	addiu	sp,sp,64
	BYTE 				i;
	WORD_VAL			w;
	DNS_HEADER			DNSHeader;
	DNS_ANSWER_HEADER	DNSAnswerHeader;

	switch(smDNS)
9d004268:	0b40104b 	j	9d00412c <DNSIsResolved+0xa8>
9d00426c:	93848020 	lbu	a0,-32736(gp)
			StartTime = TickGet();
			smDNS = DNS_GET_RESULT;
			break;

		case DNS_GET_RESULT:
			if(!UDPIsGetReady(MySocket))
9d004270:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d004274:	93848020 	lbu	a0,-32736(gp)
9d004278:	14400026 	bnez	v0,9d004314 <DNSIsResolved+0x290>
9d00427c:	00000000 	nop
			{
				if(TickGet() - StartTime > DNS_TIMEOUT)
9d004280:	0f400b53 	jal	9d002d4c <TickGet>
9d004284:	00000000 	nop
9d004288:	8f8380ec 	lw	v1,-32532(gp)
9d00428c:	3c040004 	lui	a0,0x4
9d004290:	3484c4b5 	ori	a0,a0,0xc4b5
9d004294:	00431023 	subu	v0,v0,v1
9d004298:	0044102b 	sltu	v0,v0,a0
9d00429c:	1440ffd7 	bnez	v0,9d0041fc <DNSIsResolved+0x178>
9d0042a0:	00001821 	move	v1,zero
					smDNS = DNS_FAIL;
9d0042a4:	24020006 	li	v0,6
9d0042a8:	0b40107f 	j	9d0041fc <DNSIsResolved+0x178>
9d0042ac:	af82801c 	sw	v0,-32740(gp)
			HostIP->Val = ResolvedInfo.IPAddr.Val;
			return TRUE;

		case DNS_FAIL:
			// If 3 attempts or more, quit
			if(vDNSAttemptCount >= 2u)
9d0042b0:	938380e4 	lbu	v1,-32540(gp)
9d0042b4:	2c620002 	sltiu	v0,v1,2
9d0042b8:	14400091 	bnez	v0,9d004500 <DNSIsResolved+0x47c>
9d0042bc:	3c02a001 	lui	v0,0xa001
			{
				// Return an invalid IP address 0.0.0.0 if we can't finish ARP or DNS query step
				HostIP->Val = 0x00000000;
9d0042c0:	ae000000 	sw	zero,0(s0)
				return TRUE;
9d0042c4:	0b40107f 	j	9d0041fc <DNSIsResolved+0x178>
9d0042c8:	24030001 	li	v1,1
9d0042cc:	0b401040 	j	9d004100 <DNSIsResolved+0x7c>
9d0042d0:	3c11a000 	lui	s1,0xa000
9d0042d4:	3c11a000 	lui	s1,0xa000
			// No break, DNS_DONE is the correct step

		case DNS_DONE:
			// Return 0.0.0.0 if DNS resolution failed, otherwise return the 
			// resolved IP address
			if(!Flags.bits.AddressValid)
9d0042d8:	938280e0 	lbu	v0,-32544(gp)
9d0042dc:	30420002 	andi	v0,v0,0x2
9d0042e0:	304200ff 	andi	v0,v0,0xff
9d0042e4:	14400017 	bnez	v0,9d004344 <DNSIsResolved+0x2c0>
9d0042e8:	00001021 	move	v0,zero
				ResolvedInfo.IPAddr.Val = 0;
9d0042ec:	ae2046f4 	sw	zero,18164(s1)
			HostIP->Val = ResolvedInfo.IPAddr.Val;
			return TRUE;
9d0042f0:	24030001 	li	v1,1
		case DNS_DONE:
			// Return 0.0.0.0 if DNS resolution failed, otherwise return the 
			// resolved IP address
			if(!Flags.bits.AddressValid)
				ResolvedInfo.IPAddr.Val = 0;
			HostIP->Val = ResolvedInfo.IPAddr.Val;
9d0042f4:	ae020000 	sw	v0,0(s0)
			break;

	}
	
	return FALSE;
}
9d0042f8:	8fbf003c 	lw	ra,60(sp)
9d0042fc:	00601021 	move	v0,v1
9d004300:	8fb20038 	lw	s2,56(sp)
9d004304:	8fb10034 	lw	s1,52(sp)
9d004308:	8fb00030 	lw	s0,48(sp)
9d00430c:	03e00008 	jr	ra
9d004310:	27bd0040 	addiu	sp,sp,64
					smDNS = DNS_FAIL;
				break;
			}

			// Retrieve the DNS header and de-big-endian it
			UDPGet(&DNSHeader.TransactionID.v[1]);
9d004314:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004318:	27a40019 	addiu	a0,sp,25
			UDPGet(&DNSHeader.TransactionID.v[0]);
9d00431c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004320:	27a40018 	addiu	a0,sp,24

			// Throw this packet away if it isn't in response to our last query
			if(DNSHeader.TransactionID.Val != SentTransactionID.Val)
9d004324:	97a30018 	lhu	v1,24(sp)
9d004328:	978280e8 	lhu	v0,-32536(gp)
9d00432c:	10620009 	beq	v1,v0,9d004354 <DNSIsResolved+0x2d0>
9d004330:	00000000 	nop
			{
				UDPDiscard();
9d004334:	0f40132c 	jal	9d004cb0 <UDPDiscard>
9d004338:	00000000 	nop
				break;
9d00433c:	0b40107f 	j	9d0041fc <DNSIsResolved+0x178>
9d004340:	00001821 	move	v1,zero
			// No break, DNS_DONE is the correct step

		case DNS_DONE:
			// Return 0.0.0.0 if DNS resolution failed, otherwise return the 
			// resolved IP address
			if(!Flags.bits.AddressValid)
9d004344:	8e2246f4 	lw	v0,18164(s1)
				ResolvedInfo.IPAddr.Val = 0;
			HostIP->Val = ResolvedInfo.IPAddr.Val;
			return TRUE;
9d004348:	24030001 	li	v1,1
		case DNS_DONE:
			// Return 0.0.0.0 if DNS resolution failed, otherwise return the 
			// resolved IP address
			if(!Flags.bits.AddressValid)
				ResolvedInfo.IPAddr.Val = 0;
			HostIP->Val = ResolvedInfo.IPAddr.Val;
9d00434c:	0b4010be 	j	9d0042f8 <DNSIsResolved+0x274>
9d004350:	ae020000 	sw	v0,0(s0)
			{
				UDPDiscard();
				break;
			}

			UDPGet(&DNSHeader.Flags.v[1]);
9d004354:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004358:	27a4001b 	addiu	a0,sp,27
			UDPGet(&DNSHeader.Flags.v[0]);
9d00435c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004360:	27a4001a 	addiu	a0,sp,26
			UDPGet(&DNSHeader.Questions.v[1]);
9d004364:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004368:	27a4001d 	addiu	a0,sp,29
			UDPGet(&DNSHeader.Questions.v[0]);
9d00436c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004370:	27a4001c 	addiu	a0,sp,28
			UDPGet(&DNSHeader.Answers.v[1]);
9d004374:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004378:	27a4001f 	addiu	a0,sp,31
			UDPGet(&DNSHeader.Answers.v[0]);
9d00437c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004380:	27a4001e 	addiu	a0,sp,30
			UDPGet(&DNSHeader.AuthoritativeRecords.v[1]);
9d004384:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004388:	27a40021 	addiu	a0,sp,33
			UDPGet(&DNSHeader.AuthoritativeRecords.v[0]);
9d00438c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004390:	27a40020 	addiu	a0,sp,32
			UDPGet(&DNSHeader.AdditionalRecords.v[1]);
9d004394:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004398:	27a40023 	addiu	a0,sp,35
			UDPGet(&DNSHeader.AdditionalRecords.v[0]);
9d00439c:	0b4010f2 	j	9d0043c8 <DNSIsResolved+0x344>
9d0043a0:	27a40022 	addiu	a0,sp,34

			// Remove all questions (queries)
			while(DNSHeader.Questions.Val--)
			{
				DNSDiscardName();
9d0043a4:	0f400fcb 	jal	9d003f2c <DNSDiscardName>
9d0043a8:	00000000 	nop
				UDPGet(&w.v[1]);		// Question type
9d0043ac:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0043b0:	27a40015 	addiu	a0,sp,21
				UDPGet(&w.v[0]);
9d0043b4:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0043b8:	27a40014 	addiu	a0,sp,20
				UDPGet(&w.v[1]);		// Question class
9d0043bc:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0043c0:	27a40015 	addiu	a0,sp,21
				UDPGet(&w.v[0]);
9d0043c4:	27a40014 	addiu	a0,sp,20
			UDPGet(&DNSHeader.Answers.v[1]);
			UDPGet(&DNSHeader.Answers.v[0]);
			UDPGet(&DNSHeader.AuthoritativeRecords.v[1]);
			UDPGet(&DNSHeader.AuthoritativeRecords.v[0]);
			UDPGet(&DNSHeader.AdditionalRecords.v[1]);
			UDPGet(&DNSHeader.AdditionalRecords.v[0]);
9d0043c8:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0043cc:	00000000 	nop

			// Remove all questions (queries)
			while(DNSHeader.Questions.Val--)
9d0043d0:	97a2001c 	lhu	v0,28(sp)
9d0043d4:	2443ffff 	addiu	v1,v0,-1
9d0043d8:	1440fff2 	bnez	v0,9d0043a4 <DNSIsResolved+0x320>
9d0043dc:	a7a3001c 	sh	v1,28(sp)
				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);

				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
				// Check if this is Type A or MX
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9d0043e0:	3c110001 	lui	s1,0x1
9d0043e4:	0b4010ff 	j	9d0043fc <DNSIsResolved+0x378>
9d0043e8:	26310001 	addiu	s1,s1,1
					UDPGet(&ResolvedInfo.IPAddr.v[3]);
					goto DoneSearchingRecords;
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
9d0043ec:	2443ffff 	addiu	v1,v0,-1
9d0043f0:	a7a3002c 	sh	v1,44(sp)
9d0043f4:	1440003a 	bnez	v0,9d0044e0 <DNSIsResolved+0x45c>
9d0043f8:	27b20010 	addiu	s2,sp,16
				UDPGet(&w.v[1]);		// Question class
				UDPGet(&w.v[0]);
			}
			
			// Scan through answers
			while(DNSHeader.Answers.Val--)
9d0043fc:	97a2001e 	lhu	v0,30(sp)
9d004400:	2443ffff 	addiu	v1,v0,-1
9d004404:	1040006b 	beqz	v0,9d0045b4 <DNSIsResolved+0x530>
9d004408:	a7a3001e 	sh	v1,30(sp)
			{				
				DNSDiscardName();					// Throw away response name
9d00440c:	0f400fcb 	jal	9d003f2c <DNSDiscardName>
9d004410:	00000000 	nop
				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9d004414:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004418:	27a40025 	addiu	a0,sp,37
				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9d00441c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004420:	27a40024 	addiu	a0,sp,36
				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9d004424:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004428:	27a40027 	addiu	a0,sp,39
				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9d00442c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004430:	27a40026 	addiu	a0,sp,38
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9d004434:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004438:	27a4002b 	addiu	a0,sp,43
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9d00443c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004440:	27a4002a 	addiu	a0,sp,42
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9d004444:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004448:	27a40029 	addiu	a0,sp,41
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9d00444c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004450:	27a40028 	addiu	a0,sp,40
				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9d004454:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004458:	27a4002d 	addiu	a0,sp,45
				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9d00445c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004460:	27a4002c 	addiu	a0,sp,44

				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
				// Check if this is Type A or MX
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9d004464:	8fa20024 	lw	v0,36(sp)
9d004468:	1451ffe0 	bne	v0,s1,9d0043ec <DNSIsResolved+0x368>
9d00446c:	97a2002c 	lhu	v0,44(sp)
					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9d004470:	24030004 	li	v1,4
9d004474:	1443ffde 	bne	v0,v1,9d0043f0 <DNSIsResolved+0x36c>
9d004478:	2443ffff 	addiu	v1,v0,-1
				// Check if this is Type A
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
				{
					Flags.bits.AddressValid = TRUE;
9d00447c:	938280e0 	lbu	v0,-32544(gp)
9d004480:	24030001 	li	v1,1
					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9d004484:	3c11a000 	lui	s1,0xa000
				// Check if this is Type A
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
				{
					Flags.bits.AddressValid = TRUE;
9d004488:	7c620844 	ins	v0,v1,0x1,0x1
					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9d00448c:	262446f4 	addiu	a0,s1,18164
9d004490:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004494:	a38280e0 	sb	v0,-32544(gp)
					UDPGet(&ResolvedInfo.IPAddr.v[1]);
9d004498:	3c04a000 	lui	a0,0xa000
9d00449c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0044a0:	248446f5 	addiu	a0,a0,18165
					UDPGet(&ResolvedInfo.IPAddr.v[2]);
9d0044a4:	3c04a000 	lui	a0,0xa000
9d0044a8:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0044ac:	248446f6 	addiu	a0,a0,18166
					UDPGet(&ResolvedInfo.IPAddr.v[3]);
9d0044b0:	3c04a000 	lui	a0,0xa000
9d0044b4:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0044b8:	248446f7 	addiu	a0,a0,18167
				}
			}

DoneSearchingRecords:

			UDPDiscard();
9d0044bc:	0f40132c 	jal	9d004cb0 <UDPDiscard>
9d0044c0:	00000000 	nop
			UDPClose(MySocket);
9d0044c4:	0f40121f 	jal	9d00487c <UDPClose>
9d0044c8:	93848020 	lbu	a0,-32736(gp)
			MySocket = INVALID_UDP_SOCKET;
9d0044cc:	2402ffff 	li	v0,-1
9d0044d0:	a3828020 	sb	v0,-32736(gp)
			smDNS = DNS_DONE;
9d0044d4:	24020007 	li	v0,7
9d0044d8:	0b4010b6 	j	9d0042d8 <DNSIsResolved+0x254>
9d0044dc:	af82801c 	sw	v0,-32740(gp)
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
					{
						UDPGet(&i);
9d0044e0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0044e4:	02402021 	move	a0,s2
					UDPGet(&ResolvedInfo.IPAddr.v[3]);
					goto DoneSearchingRecords;
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
9d0044e8:	97a2002c 	lhu	v0,44(sp)
9d0044ec:	2443ffff 	addiu	v1,v0,-1
9d0044f0:	1040ffc2 	beqz	v0,9d0043fc <DNSIsResolved+0x378>
9d0044f4:	a7a3002c 	sh	v1,44(sp)
9d0044f8:	0b401138 	j	9d0044e0 <DNSIsResolved+0x45c>
9d0044fc:	00000000 	nop
				return TRUE;
			}
			vDNSAttemptCount++;

			// Swap primary and secondary DNS servers if there is a secondary DNS server programmed
			if(AppConfig.SecondaryDNSServer.Val)
9d004500:	24429a5c 	addiu	v0,v0,-26020
9d004504:	88450013 	lwl	a1,19(v0)
			{
				// Return an invalid IP address 0.0.0.0 if we can't finish ARP or DNS query step
				HostIP->Val = 0x00000000;
				return TRUE;
			}
			vDNSAttemptCount++;
9d004508:	24630001 	addiu	v1,v1,1
9d00450c:	a38380e4 	sb	v1,-32540(gp)

			// Swap primary and secondary DNS servers if there is a secondary DNS server programmed
			if(AppConfig.SecondaryDNSServer.Val)
9d004510:	98450010 	lwr	a1,16(v0)
9d004514:	10a0ff39 	beqz	a1,9d0041fc <DNSIsResolved+0x178>
9d004518:	00001821 	move	v1,zero
			{
				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9d00451c:	8843000f 	lwl	v1,15(v0)
				AppConfig.SecondaryDNSServer.Val ^= AppConfig.PrimaryDNSServer.Val;
				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;

				// Start another ARP resolution for the secondary server (now primary)
				vARPAttemptCount = 0;
				if(MySocket != INVALID_UDP_SOCKET)
9d004520:	93848020 	lbu	a0,-32736(gp)
			vDNSAttemptCount++;

			// Swap primary and secondary DNS servers if there is a secondary DNS server programmed
			if(AppConfig.SecondaryDNSServer.Val)
			{
				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9d004524:	9843000c 	lwr	v1,12(v0)
				AppConfig.SecondaryDNSServer.Val ^= AppConfig.PrimaryDNSServer.Val;
				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;

				// Start another ARP resolution for the secondary server (now primary)
				vARPAttemptCount = 0;
9d004528:	a38080e5 	sb	zero,-32539(gp)
			vDNSAttemptCount++;

			// Swap primary and secondary DNS servers if there is a secondary DNS server programmed
			if(AppConfig.SecondaryDNSServer.Val)
			{
				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9d00452c:	00651826 	xor	v1,v1,a1
				AppConfig.SecondaryDNSServer.Val ^= AppConfig.PrimaryDNSServer.Val;
9d004530:	00652826 	xor	a1,v1,a1
9d004534:	a8450013 	swl	a1,19(v0)
9d004538:	b8450010 	swr	a1,16(v0)
				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9d00453c:	00a32826 	xor	a1,a1,v1
9d004540:	a845000f 	swl	a1,15(v0)
9d004544:	b845000c 	swr	a1,12(v0)

				// Start another ARP resolution for the secondary server (now primary)
				vARPAttemptCount = 0;
				if(MySocket != INVALID_UDP_SOCKET)
9d004548:	240200ff 	li	v0,255
9d00454c:	10820006 	beq	a0,v0,9d004568 <DNSIsResolved+0x4e4>
9d004550:	24020001 	li	v0,1
				{
					UDPClose(MySocket);
9d004554:	0f40121f 	jal	9d00487c <UDPClose>
9d004558:	00000000 	nop
					MySocket = INVALID_UDP_SOCKET;
9d00455c:	2402ffff 	li	v0,-1
9d004560:	a3828020 	sb	v0,-32736(gp)
				}
				smDNS = DNS_ARP_START_RESOLVE;
9d004564:	24020001 	li	v0,1
9d004568:	af82801c 	sw	v0,-32740(gp)

			break;

	}
	
	return FALSE;
9d00456c:	0b40107f 	j	9d0041fc <DNSIsResolved+0x178>
9d004570:	00001821 	move	v1,zero
			break;

		case DNS_ARP_RESOLVE:
			if(!ARPIsResolved(&AppConfig.PrimaryDNSServer, &ResolvedInfo.MACAddr))
			{
				if(TickGet() - StartTime > DNS_TIMEOUT)
9d004574:	0f400b53 	jal	9d002d4c <TickGet>
9d004578:	00000000 	nop
9d00457c:	8f8380ec 	lw	v1,-32532(gp)
9d004580:	3c040004 	lui	a0,0x4
9d004584:	3484c4b5 	ori	a0,a0,0xc4b5
9d004588:	00431023 	subu	v0,v0,v1
9d00458c:	0044102b 	sltu	v0,v0,a0
9d004590:	1440ff1a 	bnez	v0,9d0041fc <DNSIsResolved+0x178>
9d004594:	00001821 	move	v1,zero
					smDNS = (vARPAttemptCount >= 3u) ? DNS_FAIL : DNS_ARP_START_RESOLVE;
9d004598:	938580e5 	lbu	a1,-32539(gp)
9d00459c:	24020006 	li	v0,6
9d0045a0:	24040001 	li	a0,1
9d0045a4:	2ca50003 	sltiu	a1,a1,3
9d0045a8:	0085100b 	movn	v0,a0,a1
9d0045ac:	0b40107f 	j	9d0041fc <DNSIsResolved+0x178>
9d0045b0:	af82801c 	sw	v0,-32740(gp)
				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);

				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
				// Check if this is Type A
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9d0045b4:	3c110001 	lui	s1,0x1
9d0045b8:	0b401174 	j	9d0045d0 <DNSIsResolved+0x54c>
9d0045bc:	26310001 	addiu	s1,s1,1
					UDPGet(&ResolvedInfo.IPAddr.v[3]);
					goto DoneSearchingRecords;
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
9d0045c0:	2443ffff 	addiu	v1,v0,-1
9d0045c4:	a7a3002c 	sh	v1,44(sp)
9d0045c8:	14400023 	bnez	v0,9d004658 <DNSIsResolved+0x5d4>
9d0045cc:	27b20010 	addiu	s2,sp,16
					}
				}
			}

			// Remove all Authoritative Records
			while(DNSHeader.AuthoritativeRecords.Val--)
9d0045d0:	97a20020 	lhu	v0,32(sp)
9d0045d4:	2443ffff 	addiu	v1,v0,-1
9d0045d8:	10400027 	beqz	v0,9d004678 <DNSIsResolved+0x5f4>
9d0045dc:	a7a30020 	sh	v1,32(sp)
			{
				DNSDiscardName();					// Throw away response name
9d0045e0:	0f400fcb 	jal	9d003f2c <DNSDiscardName>
9d0045e4:	00000000 	nop
				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9d0045e8:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0045ec:	27a40025 	addiu	a0,sp,37
				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9d0045f0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0045f4:	27a40024 	addiu	a0,sp,36
				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9d0045f8:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0045fc:	27a40027 	addiu	a0,sp,39
				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9d004600:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004604:	27a40026 	addiu	a0,sp,38
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9d004608:	0f4012fa 	jal	9d004be8 <UDPGet>
9d00460c:	27a4002b 	addiu	a0,sp,43
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9d004610:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004614:	27a4002a 	addiu	a0,sp,42
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9d004618:	0f4012fa 	jal	9d004be8 <UDPGet>
9d00461c:	27a40029 	addiu	a0,sp,41
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9d004620:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004624:	27a40028 	addiu	a0,sp,40
				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9d004628:	0f4012fa 	jal	9d004be8 <UDPGet>
9d00462c:	27a4002d 	addiu	a0,sp,45
				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9d004630:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004634:	27a4002c 	addiu	a0,sp,44

				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
				// Check if this is Type A
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9d004638:	8fa20024 	lw	v0,36(sp)
9d00463c:	1451ffe0 	bne	v0,s1,9d0045c0 <DNSIsResolved+0x53c>
9d004640:	97a2002c 	lhu	v0,44(sp)
					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9d004644:	24030004 	li	v1,4
9d004648:	1443ffde 	bne	v0,v1,9d0045c4 <DNSIsResolved+0x540>
9d00464c:	2443ffff 	addiu	v1,v0,-1
				// Check if this is Type A
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
				{
					Flags.bits.AddressValid = TRUE;
9d004650:	0b401120 	j	9d004480 <DNSIsResolved+0x3fc>
9d004654:	938280e0 	lbu	v0,-32544(gp)
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
					{
						UDPGet(&i);
9d004658:	0f4012fa 	jal	9d004be8 <UDPGet>
9d00465c:	02402021 	move	a0,s2
					UDPGet(&ResolvedInfo.IPAddr.v[3]);
					goto DoneSearchingRecords;
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
9d004660:	97a2002c 	lhu	v0,44(sp)
9d004664:	2443ffff 	addiu	v1,v0,-1
9d004668:	1040ffd9 	beqz	v0,9d0045d0 <DNSIsResolved+0x54c>
9d00466c:	a7a3002c 	sh	v1,44(sp)
9d004670:	0b401196 	j	9d004658 <DNSIsResolved+0x5d4>
9d004674:	00000000 	nop
				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);

				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
				// Check if this is Type A
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9d004678:	3c110001 	lui	s1,0x1
9d00467c:	0b4011a5 	j	9d004694 <DNSIsResolved+0x610>
9d004680:	26310001 	addiu	s1,s1,1
					UDPGet(&ResolvedInfo.IPAddr.v[3]);
					goto DoneSearchingRecords;
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
9d004684:	2443ffff 	addiu	v1,v0,-1
9d004688:	a7a3002c 	sh	v1,44(sp)
9d00468c:	14400023 	bnez	v0,9d00471c <DNSIsResolved+0x698>
9d004690:	27b20010 	addiu	s2,sp,16
					}
				}
			}

			// Remove all Additional Records
			while(DNSHeader.AdditionalRecords.Val--)
9d004694:	97a20022 	lhu	v0,34(sp)
9d004698:	2443ffff 	addiu	v1,v0,-1
9d00469c:	10400027 	beqz	v0,9d00473c <DNSIsResolved+0x6b8>
9d0046a0:	a7a30022 	sh	v1,34(sp)
			{
				DNSDiscardName();					// Throw away response name
9d0046a4:	0f400fcb 	jal	9d003f2c <DNSDiscardName>
9d0046a8:	00000000 	nop
				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9d0046ac:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046b0:	27a40025 	addiu	a0,sp,37
				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9d0046b4:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046b8:	27a40024 	addiu	a0,sp,36
				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9d0046bc:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046c0:	27a40027 	addiu	a0,sp,39
				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9d0046c4:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046c8:	27a40026 	addiu	a0,sp,38
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9d0046cc:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046d0:	27a4002b 	addiu	a0,sp,43
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9d0046d4:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046d8:	27a4002a 	addiu	a0,sp,42
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9d0046dc:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046e0:	27a40029 	addiu	a0,sp,41
				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9d0046e4:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046e8:	27a40028 	addiu	a0,sp,40
				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9d0046ec:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046f0:	27a4002d 	addiu	a0,sp,45
				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9d0046f4:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0046f8:	27a4002c 	addiu	a0,sp,44

				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
				// Check if this is Type A
				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9d0046fc:	8fa20024 	lw	v0,36(sp)
9d004700:	1451ffe0 	bne	v0,s1,9d004684 <DNSIsResolved+0x600>
9d004704:	97a2002c 	lhu	v0,44(sp)
					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9d004708:	24030004 	li	v1,4
9d00470c:	1443ffde 	bne	v0,v1,9d004688 <DNSIsResolved+0x604>
9d004710:	2443ffff 	addiu	v1,v0,-1
					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
				{
					Flags.bits.AddressValid = TRUE;
9d004714:	0b401120 	j	9d004480 <DNSIsResolved+0x3fc>
9d004718:	938280e0 	lbu	v0,-32544(gp)
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
					{
						UDPGet(&i);
9d00471c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d004720:	02402021 	move	a0,s2
					UDPGet(&ResolvedInfo.IPAddr.v[3]);
					goto DoneSearchingRecords;
				}
				else
				{
					while(DNSAnswerHeader.ResponseLen.Val--)
9d004724:	97a2002c 	lhu	v0,44(sp)
9d004728:	2443ffff 	addiu	v1,v0,-1
9d00472c:	1040ffd9 	beqz	v0,9d004694 <DNSIsResolved+0x610>
9d004730:	a7a3002c 	sh	v1,44(sp)
9d004734:	0b4011c7 	j	9d00471c <DNSIsResolved+0x698>
9d004738:	00000000 	nop
9d00473c:	0b40112f 	j	9d0044bc <DNSIsResolved+0x438>
9d004740:	3c11a000 	lui	s1,0xa000

9d004744 <UDPInit>:
  	
  Remarks:
	This function is called only one during lifetime of the application.
  ***************************************************************************/
void UDPInit(void)
{
9d004744:	3c04a001 	lui	a0,0xa001
9d004748:	3c07a001 	lui	a3,0xa001
9d00474c:	24849aa8 	addiu	a0,a0,-25944
9d004750:	00001821 	move	v1,zero
9d004754:	24e79a9c 	addiu	a3,a3,-25956
    UDP_SOCKET s;

    for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9d004758:	2406000a 	li	a2,10
{
	if(s >= MAX_UDP_SOCKETS)
		return;

	UDPSocketInfo[s].localPort = INVALID_UDP_PORT;
	UDPSocketInfo[s].remoteNode.IPAddr.Val = 0x00000000;
9d00475c:	00031040 	sll	v0,v1,0x1
9d004760:	00032900 	sll	a1,v1,0x4
9d004764:	00a21023 	subu	v0,a1,v0
void UDPClose(UDP_SOCKET s)
{
	if(s >= MAX_UDP_SOCKETS)
		return;

	UDPSocketInfo[s].localPort = INVALID_UDP_PORT;
9d004768:	a4800000 	sh	zero,0(a0)
	UDPSocketInfo[s].remoteNode.IPAddr.Val = 0x00000000;
9d00476c:	00e21021 	addu	v0,a3,v0
9d004770:	a8400003 	swl	zero,3(v0)
9d004774:	24630001 	addiu	v1,v1,1
9d004778:	b8400000 	swr	zero,0(v0)
  ***************************************************************************/
void UDPInit(void)
{
    UDP_SOCKET s;

    for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9d00477c:	1466fff7 	bne	v1,a2,9d00475c <UDPInit+0x18>
9d004780:	2484000e 	addiu	a0,a0,14
    {
		UDPClose(s);
    }
	Flags.bWasDiscarded = 1;
9d004784:	938280f0 	lbu	v0,-32528(gp)
9d004788:	24030001 	li	v1,1
9d00478c:	7c620844 	ins	v0,v1,0x1,0x1
}
9d004790:	03e00008 	jr	ra
9d004794:	a38280f0 	sb	v0,-32528(gp)

9d004798 <UDPTask>:
	to UDPIsPutReady() always update the Ethernet Write pointer location 
	between StackTask() iterations.
  ***************************************************************************/
void UDPTask(void)
{
	LastPutSocket = INVALID_UDP_SOCKET;
9d004798:	2402ffff 	li	v0,-1
}
9d00479c:	03e00008 	jr	ra
9d0047a0:	a3828022 	sb	v0,-32734(gp)

9d0047a4 <UDPOpen>:

	// Local temp port numbers.
	static WORD NextPort __attribute__((persistent));


    p = UDPSocketInfo;
9d0047a4:	3c03a001 	lui	v1,0xa001
	to free the socket and delete the handle.
  ***************************************************************************/
UDP_SOCKET UDPOpen(UDP_PORT localPort,
                   NODE_INFO *remoteNode,
                   UDP_PORT remotePort)
{
9d0047a8:	3084ffff 	andi	a0,a0,0xffff
9d0047ac:	30c6ffff 	andi	a2,a2,0xffff

	// Local temp port numbers.
	static WORD NextPort __attribute__((persistent));


    p = UDPSocketInfo;
9d0047b0:	24639a9c 	addiu	v1,v1,-25956
    for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9d0047b4:	00001021 	move	v0,zero
9d0047b8:	2409000a 	li	t1,10
    {
        if(p->localPort == INVALID_UDP_PORT)
9d0047bc:	9467000c 	lhu	a3,12(v1)
9d0047c0:	10e00006 	beqz	a3,9d0047dc <UDPOpen+0x38>
9d0047c4:	24480001 	addiu	t0,v0,1
	// Local temp port numbers.
	static WORD NextPort __attribute__((persistent));


    p = UDPSocketInfo;
    for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9d0047c8:	310200ff 	andi	v0,t0,0xff
9d0047cc:	1449fffb 	bne	v0,t1,9d0047bc <UDPOpen+0x18>
9d0047d0:	2463000e 	addiu	v1,v1,14
        }
        p++;
    }

    return (UDP_SOCKET)INVALID_UDP_SOCKET;
}
9d0047d4:	03e00008 	jr	ra
9d0047d8:	240200ff 	li	v0,255
    {
        if(p->localPort == INVALID_UDP_PORT)
        {
			p->localPort = localPort;	

			if(localPort == 0x0000u)
9d0047dc:	10800012 	beqz	a0,9d004828 <UDPOpen+0x84>
9d0047e0:	a464000c 	sh	a0,12(v1)
	
	            p->localPort    = NextPort++;
			}

            // If remoteNode is supplied, remember it.
            if(remoteNode)
9d0047e4:	10a0001f 	beqz	a1,9d004864 <UDPOpen+0xc0>
9d0047e8:	2404ffff 	li	a0,-1
            {
                memcpy((void*)&p->remoteNode,
9d0047ec:	88a70003 	lwl	a3,3(a1)
9d0047f0:	88a40007 	lwl	a0,7(a1)
9d0047f4:	98a70000 	lwr	a3,0(a1)
9d0047f8:	98a40004 	lwr	a0,4(a1)
9d0047fc:	a8670003 	swl	a3,3(v1)
9d004800:	b8670000 	swr	a3,0(v1)
9d004804:	a8640007 	swl	a0,7(v1)
9d004808:	b8640004 	swr	a0,4(v1)
9d00480c:	90a40008 	lbu	a0,8(a1)
9d004810:	a0640008 	sb	a0,8(v1)
9d004814:	90a40009 	lbu	a0,9(a1)
9d004818:	a0640009 	sb	a0,9(v1)
			{
				// else Set broadcast address
				memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode));
			}

            p->remotePort   = remotePort;
9d00481c:	a466000a 	sh	a2,10(v1)

            // Mark this socket as active.
            // Once an active socket is set, subsequent operation can be
            // done without explicitely supply socket identifier.
            activeUDPSocket = s;
            return s;
9d004820:	03e00008 	jr	ra
9d004824:	a3828164 	sb	v0,-32412(gp)
        {
			p->localPort = localPort;	

			if(localPort == 0x0000u)
			{
				if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
9d004828:	978480f8 	lhu	a0,-32520(gp)
9d00482c:	2487f000 	addiu	a3,a0,-4096
9d004830:	30e7ffff 	andi	a3,a3,0xffff
9d004834:	2ce71001 	sltiu	a3,a3,4097
9d004838:	10e00006 	beqz	a3,9d004854 <UDPOpen+0xb0>
9d00483c:	24071001 	li	a3,4097
9d004840:	24870001 	addiu	a3,a0,1
9d004844:	30e7ffff 	andi	a3,a3,0xffff
					NextPort = LOCAL_UDP_PORT_START_NUMBER;
	
	            p->localPort    = NextPort++;
9d004848:	a464000c 	sh	a0,12(v1)
9d00484c:	0b4011f9 	j	9d0047e4 <UDPOpen+0x40>
9d004850:	a78780f8 	sh	a3,-32520(gp)
        {
			p->localPort = localPort;	

			if(localPort == 0x0000u)
			{
				if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
9d004854:	24041000 	li	a0,4096
					NextPort = LOCAL_UDP_PORT_START_NUMBER;
	
	            p->localPort    = NextPort++;
9d004858:	a464000c 	sh	a0,12(v1)
9d00485c:	0b4011f9 	j	9d0047e4 <UDPOpen+0x40>
9d004860:	a78780f8 	sh	a3,-32520(gp)
                        sizeof(p->remoteNode));
            }
            else
			{
				// else Set broadcast address
				memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode));
9d004864:	a4640000 	sh	a0,0(v1)
9d004868:	a4640002 	sh	a0,2(v1)
9d00486c:	a4640004 	sh	a0,4(v1)
9d004870:	a4640006 	sh	a0,6(v1)
9d004874:	0b401207 	j	9d00481c <UDPOpen+0x78>
9d004878:	a4640008 	sh	a0,8(v1)

9d00487c <UDPClose>:
  	
  Remarks:
	This function does not affect the previously designated active socket.
  ***************************************************************************/
void UDPClose(UDP_SOCKET s)
{
9d00487c:	308400ff 	andi	a0,a0,0xff
	if(s >= MAX_UDP_SOCKETS)
9d004880:	2c82000a 	sltiu	v0,a0,10
9d004884:	10400009 	beqz	v0,9d0048ac <UDPClose+0x30>
9d004888:	00041840 	sll	v1,a0,0x1
		return;

	UDPSocketInfo[s].localPort = INVALID_UDP_PORT;
9d00488c:	00041100 	sll	v0,a0,0x4
9d004890:	00431023 	subu	v0,v0,v1
9d004894:	3c03a001 	lui	v1,0xa001
9d004898:	24639a9c 	addiu	v1,v1,-25956
9d00489c:	00431021 	addu	v0,v0,v1
9d0048a0:	a440000c 	sh	zero,12(v0)
	UDPSocketInfo[s].remoteNode.IPAddr.Val = 0x00000000;
9d0048a4:	a8400003 	swl	zero,3(v0)
9d0048a8:	b8400000 	swr	zero,0(v0)
9d0048ac:	03e00008 	jr	ra
9d0048b0:	00000000 	nop

9d0048b4 <UDPSetTxBuffer>:

  Returns:
  	None
  ***************************************************************************/
void UDPSetTxBuffer(WORD wOffset)
{
9d0048b4:	27bdffe8 	addiu	sp,sp,-24
9d0048b8:	afb00010 	sw	s0,16(sp)
9d0048bc:	afbf0014 	sw	ra,20(sp)
	IPSetTxBuffer(wOffset+sizeof(UDP_HEADER));
9d0048c0:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d0048c4:	3090ffff 	andi	s0,a0,0xffff
9d0048c8:	2604002a 	addiu	a0,s0,42
9d0048cc:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d0048d0:	00822021 	addu	a0,a0,v0
	wPutOffset = wOffset;
}
9d0048d4:	8fbf0014 	lw	ra,20(sp)
  	None
  ***************************************************************************/
void UDPSetTxBuffer(WORD wOffset)
{
	IPSetTxBuffer(wOffset+sizeof(UDP_HEADER));
	wPutOffset = wOffset;
9d0048d8:	a79080f6 	sh	s0,-32522(gp)
}
9d0048dc:	8fb00010 	lw	s0,16(sp)
9d0048e0:	03e00008 	jr	ra
9d0048e4:	27bd0018 	addiu	sp,sp,24

9d0048e8 <UDPSetRxBuffer>:

  Returns:
  	None
  ***************************************************************************/
void UDPSetRxBuffer(WORD wOffset)
{
9d0048e8:	27bdffe8 	addiu	sp,sp,-24
9d0048ec:	afb00010 	sw	s0,16(sp)
9d0048f0:	3090ffff 	andi	s0,a0,0xffff
	IPSetRxBuffer(wOffset+sizeof(UDP_HEADER));
9d0048f4:	26040008 	addiu	a0,s0,8

  Returns:
  	None
  ***************************************************************************/
void UDPSetRxBuffer(WORD wOffset)
{
9d0048f8:	afbf0014 	sw	ra,20(sp)
	IPSetRxBuffer(wOffset+sizeof(UDP_HEADER));
9d0048fc:	0f4024f1 	jal	9d0093c4 <IPSetRxBuffer>
9d004900:	3084ffff 	andi	a0,a0,0xffff
	wGetOffset = wOffset;
}
9d004904:	8fbf0014 	lw	ra,20(sp)
  	None
  ***************************************************************************/
void UDPSetRxBuffer(WORD wOffset)
{
	IPSetRxBuffer(wOffset+sizeof(UDP_HEADER));
	wGetOffset = wOffset;
9d004908:	a79080f4 	sh	s0,-32524(gp)
}
9d00490c:	8fb00010 	lw	s0,16(sp)
9d004910:	03e00008 	jr	ra
9d004914:	27bd0018 	addiu	sp,sp,24

9d004918 <UDPIsPutReady>:

  Returns:
  	The number of bytes that can be written to this socket.
  ***************************************************************************/
WORD UDPIsPutReady(UDP_SOCKET s)
{
9d004918:	27bdffe8 	addiu	sp,sp,-24
9d00491c:	afb00010 	sw	s0,16(sp)
9d004920:	afbf0014 	sw	ra,20(sp)
	if(!MACIsTxReady())
9d004924:	0f400cf1 	jal	9d0033c4 <MACIsTxReady>
9d004928:	309000ff 	andi	s0,a0,0xff
9d00492c:	1040000c 	beqz	v0,9d004960 <UDPIsPutReady+0x48>
9d004930:	00001821 	move	v1,zero
		return 0;

	if(LastPutSocket != s)
9d004934:	93828022 	lbu	v0,-32734(gp)
9d004938:	10500004 	beq	v0,s0,9d00494c <UDPIsPutReady+0x34>
9d00493c:	00002021 	move	a0,zero
	{
		LastPutSocket = s;
9d004940:	a3908022 	sb	s0,-32734(gp)
		UDPTxCount = 0;
		UDPSetTxBuffer(0);
9d004944:	0f40122d 	jal	9d0048b4 <UDPSetTxBuffer>
9d004948:	a7808166 	sh	zero,-32410(gp)
	}

	activeUDPSocket = s;

	return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount;
9d00494c:	97828166 	lhu	v0,-32410(gp)
9d004950:	240305c0 	li	v1,1472
		LastPutSocket = s;
		UDPTxCount = 0;
		UDPSetTxBuffer(0);
	}

	activeUDPSocket = s;
9d004954:	a3908164 	sb	s0,-32412(gp)

	return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount;
9d004958:	00621823 	subu	v1,v1,v0
9d00495c:	3063ffff 	andi	v1,v1,0xffff
}
9d004960:	8fbf0014 	lw	ra,20(sp)
9d004964:	00601021 	move	v0,v1
9d004968:	8fb00010 	lw	s0,16(sp)
9d00496c:	03e00008 	jr	ra
9d004970:	27bd0018 	addiu	sp,sp,24

9d004974 <UDPPut>:
  	FALSE - The transmit buffer is already full and so the write failed.
  ***************************************************************************/
BOOL UDPPut(BYTE v)
{
	// See if we are out of transmit space.
	if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)))
9d004974:	978380f6 	lhu	v1,-32522(gp)
  Return Values:
  	TRUE - The byte was successfully written to the socket.
  	FALSE - The transmit buffer is already full and so the write failed.
  ***************************************************************************/
BOOL UDPPut(BYTE v)
{
9d004978:	27bdffe8 	addiu	sp,sp,-24
9d00497c:	afbf0014 	sw	ra,20(sp)
	// See if we are out of transmit space.
	if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)))
9d004980:	2c6305c0 	sltiu	v1,v1,1472
  Return Values:
  	TRUE - The byte was successfully written to the socket.
  	FALSE - The transmit buffer is already full and so the write failed.
  ***************************************************************************/
BOOL UDPPut(BYTE v)
{
9d004984:	308400ff 	andi	a0,a0,0xff
	// See if we are out of transmit space.
	if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)))
9d004988:	14600004 	bnez	v1,9d00499c <UDPPut+0x28>
9d00498c:	00001021 	move	v0,zero
	wPutOffset++;
	if(wPutOffset > UDPTxCount)
		UDPTxCount = wPutOffset;

    return TRUE;
}
9d004990:	8fbf0014 	lw	ra,20(sp)
9d004994:	03e00008 	jr	ra
9d004998:	27bd0018 	addiu	sp,sp,24
	{
		return FALSE;
	}

    // Load application data byte
    MACPut(v);
9d00499c:	0f400d40 	jal	9d003500 <MACPut>
9d0049a0:	00000000 	nop
	wPutOffset++;
9d0049a4:	978380f6 	lhu	v1,-32522(gp)
	if(wPutOffset > UDPTxCount)
9d0049a8:	97848166 	lhu	a0,-32410(gp)
		UDPTxCount = wPutOffset;

    return TRUE;
9d0049ac:	24020001 	li	v0,1
		return FALSE;
	}

    // Load application data byte
    MACPut(v);
	wPutOffset++;
9d0049b0:	24630001 	addiu	v1,v1,1
9d0049b4:	3063ffff 	andi	v1,v1,0xffff
	if(wPutOffset > UDPTxCount)
9d0049b8:	0083202b 	sltu	a0,a0,v1
9d0049bc:	1080fff4 	beqz	a0,9d004990 <UDPPut+0x1c>
9d0049c0:	a78380f6 	sh	v1,-32522(gp)
		UDPTxCount = wPutOffset;

    return TRUE;
}
9d0049c4:	8fbf0014 	lw	ra,20(sp)

    // Load application data byte
    MACPut(v);
	wPutOffset++;
	if(wPutOffset > UDPTxCount)
		UDPTxCount = wPutOffset;
9d0049c8:	a7838166 	sh	v1,-32410(gp)

    return TRUE;
}
9d0049cc:	03e00008 	jr	ra
9d0049d0:	27bd0018 	addiu	sp,sp,24

9d0049d4 <UDPPutArray>:
  ***************************************************************************/
WORD UDPPutArray(BYTE *cData, WORD wDataLen)
{
	WORD wTemp;

	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
9d0049d4:	978380f6 	lhu	v1,-32522(gp)
9d0049d8:	30a2ffff 	andi	v0,a1,0xffff
9d0049dc:	240505c0 	li	a1,1472
9d0049e0:	00a32823 	subu	a1,a1,v1
9d0049e4:	30a5ffff 	andi	a1,a1,0xffff
9d0049e8:	00a2302b 	sltu	a2,a1,v0
9d0049ec:	00a6100b 	movn	v0,a1,a2
	if(wTemp < wDataLen)
		wDataLen = wTemp;

	wPutOffset += wDataLen;
	if(wPutOffset > UDPTxCount)
9d0049f0:	97858166 	lhu	a1,-32410(gp)

	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
	if(wTemp < wDataLen)
		wDataLen = wTemp;

	wPutOffset += wDataLen;
9d0049f4:	00431821 	addu	v1,v0,v1
9d0049f8:	3063ffff 	andi	v1,v1,0xffff
  	The number of bytes successfully placed in the UDP transmit buffer.  If
  	this value is less than wDataLen, then the buffer became full and the
  	input was truncated.
  ***************************************************************************/
WORD UDPPutArray(BYTE *cData, WORD wDataLen)
{
9d0049fc:	27bdffe0 	addiu	sp,sp,-32
	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
	if(wTemp < wDataLen)
		wDataLen = wTemp;

	wPutOffset += wDataLen;
	if(wPutOffset > UDPTxCount)
9d004a00:	00a3282b 	sltu	a1,a1,v1
  	The number of bytes successfully placed in the UDP transmit buffer.  If
  	this value is less than wDataLen, then the buffer became full and the
  	input was truncated.
  ***************************************************************************/
WORD UDPPutArray(BYTE *cData, WORD wDataLen)
{
9d004a04:	afbf001c 	sw	ra,28(sp)
	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
	if(wTemp < wDataLen)
		wDataLen = wTemp;

	wPutOffset += wDataLen;
	if(wPutOffset > UDPTxCount)
9d004a08:	10a00002 	beqz	a1,9d004a14 <UDPPutArray+0x40>
9d004a0c:	a78380f6 	sh	v1,-32522(gp)
		UDPTxCount = wPutOffset;
9d004a10:	a7838166 	sh	v1,-32410(gp)

    // Load application data bytes
    MACPutArray(cData, wDataLen);
9d004a14:	00402821 	move	a1,v0
9d004a18:	0f400d45 	jal	9d003514 <MACPutArray>
9d004a1c:	afa20010 	sw	v0,16(sp)

    return wDataLen;
}
9d004a20:	8fbf001c 	lw	ra,28(sp)
9d004a24:	8fa20010 	lw	v0,16(sp)
9d004a28:	03e00008 	jr	ra
9d004a2c:	27bd0020 	addiu	sp,sp,32

9d004a30 <UDPFlush>:
{
    UDP_HEADER      h;
    UDP_SOCKET_INFO *p;
    WORD			wUDPLength;

    p = &UDPSocketInfo[activeUDPSocket];
9d004a30:	93828164 	lbu	v0,-32412(gp)
  Remarks:
	Note that unlike TCPFlush, UDPFlush must be called before returning to 
	the main stack loop.  There is no auto transmit for UDP segments.
  ***************************************************************************/
void UDPFlush(void)
{
9d004a34:	27bdffc8 	addiu	sp,sp,-56
9d004a38:	afb10030 	sw	s1,48(sp)
    p = &UDPSocketInfo[activeUDPSocket];

	wUDPLength = UDPTxCount + sizeof(UDP_HEADER);

	// Generate the correct UDP header
    h.SourcePort        = swaps(p->localPort);
9d004a3c:	00021840 	sll	v1,v0,0x1
9d004a40:	00028900 	sll	s1,v0,0x4
9d004a44:	02238823 	subu	s1,s1,v1
9d004a48:	3c03a001 	lui	v1,0xa001
9d004a4c:	24639a9c 	addiu	v1,v1,-25956
9d004a50:	02238821 	addu	s1,s1,v1
9d004a54:	9624000c 	lhu	a0,12(s1)
  Remarks:
	Note that unlike TCPFlush, UDPFlush must be called before returning to 
	the main stack loop.  There is no auto transmit for UDP segments.
  ***************************************************************************/
void UDPFlush(void)
{
9d004a58:	afb0002c 	sw	s0,44(sp)
    UDP_SOCKET_INFO *p;
    WORD			wUDPLength;

    p = &UDPSocketInfo[activeUDPSocket];

	wUDPLength = UDPTxCount + sizeof(UDP_HEADER);
9d004a5c:	97908166 	lhu	s0,-32410(gp)
  Remarks:
	Note that unlike TCPFlush, UDPFlush must be called before returning to 
	the main stack loop.  There is no auto transmit for UDP segments.
  ***************************************************************************/
void UDPFlush(void)
{
9d004a60:	afbf0034 	sw	ra,52(sp)
    p = &UDPSocketInfo[activeUDPSocket];

	wUDPLength = UDPTxCount + sizeof(UDP_HEADER);

	// Generate the correct UDP header
    h.SourcePort        = swaps(p->localPort);
9d004a64:	0f402604 	jal	9d009810 <swaps>
9d004a68:	26100008 	addiu	s0,s0,8
    h.DestinationPort   = swaps(p->remotePort);
9d004a6c:	9624000a 	lhu	a0,10(s1)
    UDP_SOCKET_INFO *p;
    WORD			wUDPLength;

    p = &UDPSocketInfo[activeUDPSocket];

	wUDPLength = UDPTxCount + sizeof(UDP_HEADER);
9d004a70:	3210ffff 	andi	s0,s0,0xffff

	// Generate the correct UDP header
    h.SourcePort        = swaps(p->localPort);
    h.DestinationPort   = swaps(p->remotePort);
9d004a74:	0f402604 	jal	9d009810 <swaps>
9d004a78:	a7a20014 	sh	v0,20(sp)
    h.Length            = swaps(wUDPLength);
9d004a7c:	02002021 	move	a0,s0
9d004a80:	0f402604 	jal	9d009810 <swaps>
9d004a84:	a7a20016 	sh	v0,22(sp)
	// the checksum field
	#if defined(UDP_USE_TX_CHECKSUM)
	{
		PSEUDO_HEADER   pseudoHeader;
		
		pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9d004a88:	3c03a001 	lui	v1,0xa001
9d004a8c:	24649a5c 	addiu	a0,v1,-26020
9d004a90:	88860003 	lwl	a2,3(a0)
		pseudoHeader.DestAddress    = p->remoteNode.IPAddr;
9d004a94:	8a250003 	lwl	a1,3(s1)
		pseudoHeader.Zero           = 0x0;
		pseudoHeader.Protocol       = IP_PROT_UDP;
		pseudoHeader.Length			= wUDPLength;
		SwapPseudoHeader(pseudoHeader);
9d004a98:	02002021 	move	a0,s0
	// the checksum field
	#if defined(UDP_USE_TX_CHECKSUM)
	{
		PSEUDO_HEADER   pseudoHeader;
		
		pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9d004a9c:	98669a5c 	lwr	a2,-26020(v1)
		pseudoHeader.DestAddress    = p->remoteNode.IPAddr;
9d004aa0:	9a250000 	lwr	a1,0(s1)
	wUDPLength = UDPTxCount + sizeof(UDP_HEADER);

	// Generate the correct UDP header
    h.SourcePort        = swaps(p->localPort);
    h.DestinationPort   = swaps(p->remotePort);
    h.Length            = swaps(wUDPLength);
9d004aa4:	a7a20018 	sh	v0,24(sp)
		PSEUDO_HEADER   pseudoHeader;
		
		pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
		pseudoHeader.DestAddress    = p->remoteNode.IPAddr;
		pseudoHeader.Zero           = 0x0;
		pseudoHeader.Protocol       = IP_PROT_UDP;
9d004aa8:	24020011 	li	v0,17
	// the checksum field
	#if defined(UDP_USE_TX_CHECKSUM)
	{
		PSEUDO_HEADER   pseudoHeader;
		
		pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9d004aac:	afa6001c 	sw	a2,28(sp)
		pseudoHeader.DestAddress    = p->remoteNode.IPAddr;
9d004ab0:	afa50020 	sw	a1,32(sp)

	// Generate the correct UDP header
    h.SourcePort        = swaps(p->localPort);
    h.DestinationPort   = swaps(p->remotePort);
    h.Length            = swaps(wUDPLength);
	h.Checksum 			= 0x0000;
9d004ab4:	a7a0001a 	sh	zero,26(sp)
	{
		PSEUDO_HEADER   pseudoHeader;
		
		pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
		pseudoHeader.DestAddress    = p->remoteNode.IPAddr;
		pseudoHeader.Zero           = 0x0;
9d004ab8:	a3a00024 	sb	zero,36(sp)
		pseudoHeader.Protocol       = IP_PROT_UDP;
9d004abc:	a3a20025 	sb	v0,37(sp)
		pseudoHeader.Length			= wUDPLength;
		SwapPseudoHeader(pseudoHeader);
9d004ac0:	0f402604 	jal	9d009810 <swaps>
9d004ac4:	a7b00026 	sh	s0,38(sp)
		h.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader));
9d004ac8:	2405000c 	li	a1,12
9d004acc:	27a4001c 	addiu	a0,sp,28
9d004ad0:	0f40261b 	jal	9d00986c <CalcIPChecksum>
9d004ad4:	a7a20026 	sh	v0,38(sp)
9d004ad8:	00021027 	nor	v0,zero,v0
	}
	#endif

	// Position the hardware write pointer where we will need to 
	// begin writing the IP header
	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9d004adc:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d004ae0:	a7a2001a 	sh	v0,26(sp)
9d004ae4:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d004ae8:	2444000e 	addiu	a0,v0,14
	
	// Write IP header to packet
	IPPutHeader(&p->remoteNode, IP_PROT_UDP, wUDPLength);
9d004aec:	02003021 	move	a2,s0
9d004af0:	02202021 	move	a0,s1
9d004af4:	0f4024b9 	jal	9d0092e4 <IPPutHeader>
9d004af8:	24050011 	li	a1,17

    // Write UDP header to packet
    MACPutArray((BYTE*)&h, sizeof(h));
9d004afc:	24050008 	li	a1,8
9d004b00:	0f400d45 	jal	9d003514 <MACPutArray>
9d004b04:	27a40014 	addiu	a0,sp,20
	#if defined(UDP_USE_TX_CHECKSUM)
	{
        PTR_BASE	wReadPtrSave;
        WORD		wChecksum;

		wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9d004b08:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d004b0c:	00000000 	nop
9d004b10:	0f400e0d 	jal	9d003834 <MACSetReadPtr>
9d004b14:	24440022 	addiu	a0,v0,34
		wChecksum = CalcIPBufferChecksum(wUDPLength);
9d004b18:	02002021 	move	a0,s0
9d004b1c:	0f400e43 	jal	9d00390c <CalcIPBufferChecksum>
9d004b20:	00408821 	move	s1,v0
		if(wChecksum == 0x0000u)
9d004b24:	14400003 	bnez	v0,9d004b34 <UDPFlush+0x104>
9d004b28:	a7a20010 	sh	v0,16(sp)
			wChecksum = 0xFFFF;
9d004b2c:	2402ffff 	li	v0,-1
9d004b30:	a7a20010 	sh	v0,16(sp)
		MACSetReadPtr(wReadPtrSave);
9d004b34:	0f400e0d 	jal	9d003834 <MACSetReadPtr>
9d004b38:	02202021 	move	a0,s1
		MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);	// 6 is the offset to the Checksum field in UDP_HEADER
9d004b3c:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d004b40:	00000000 	nop
9d004b44:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d004b48:	24440028 	addiu	a0,v0,40
		MACPutArray((BYTE*)&wChecksum, sizeof(wChecksum));
9d004b4c:	27a40010 	addiu	a0,sp,16
9d004b50:	0f400d45 	jal	9d003514 <MACPutArray>
9d004b54:	24050002 	li	a1,2
	}
	#endif
    
	// Transmit the packet
    MACFlush();
9d004b58:	0f400d77 	jal	9d0035dc <MACFlush>
9d004b5c:	00000000 	nop

	// Reset packet size counter for the next TX operation
    UDPTxCount = 0;
	LastPutSocket = INVALID_UDP_SOCKET;
}
9d004b60:	8fbf0034 	lw	ra,52(sp)
	// Transmit the packet
    MACFlush();

	// Reset packet size counter for the next TX operation
    UDPTxCount = 0;
	LastPutSocket = INVALID_UDP_SOCKET;
9d004b64:	2402ffff 	li	v0,-1
}
9d004b68:	8fb10030 	lw	s1,48(sp)
9d004b6c:	8fb0002c 	lw	s0,44(sp)
    
	// Transmit the packet
    MACFlush();

	// Reset packet size counter for the next TX operation
    UDPTxCount = 0;
9d004b70:	a7808166 	sh	zero,-32410(gp)
	LastPutSocket = INVALID_UDP_SOCKET;
9d004b74:	a3828022 	sb	v0,-32734(gp)
}
9d004b78:	03e00008 	jr	ra
9d004b7c:	27bd0038 	addiu	sp,sp,56

9d004b80 <UDPIsGetReady>:
  	The number of bytes that can be read from this socket.
  ***************************************************************************/
WORD UDPIsGetReady(UDP_SOCKET s)
{
    activeUDPSocket = s;
	if(SocketWithRxData != s)
9d004b80:	93838021 	lbu	v1,-32735(gp)

  Returns:
  	The number of bytes that can be read from this socket.
  ***************************************************************************/
WORD UDPIsGetReady(UDP_SOCKET s)
{
9d004b84:	27bdffe8 	addiu	sp,sp,-24
9d004b88:	308400ff 	andi	a0,a0,0xff
9d004b8c:	afbf0014 	sw	ra,20(sp)
    activeUDPSocket = s;
9d004b90:	a3848164 	sb	a0,-32412(gp)
	if(SocketWithRxData != s)
9d004b94:	10640004 	beq	v1,a0,9d004ba8 <UDPIsGetReady+0x28>
9d004b98:	00001021 	move	v0,zero
        Flags.bFirstRead = 0;
        UDPSetRxBuffer(0);
    }

    return UDPRxCount - wGetOffset;
}
9d004b9c:	8fbf0014 	lw	ra,20(sp)
9d004ba0:	03e00008 	jr	ra
9d004ba4:	27bd0018 	addiu	sp,sp,24
	if(SocketWithRxData != s)
		return 0;

    // If this is the very first time we are accessing this packet, 
    // move the read point to the begining of the packet.
    if(Flags.bFirstRead)
9d004ba8:	938280f0 	lbu	v0,-32528(gp)
9d004bac:	30430001 	andi	v1,v0,0x1
9d004bb0:	54600008 	bnezl	v1,9d004bd4 <UDPIsGetReady+0x54>
9d004bb4:	7c020004 	ins	v0,zero,0x0,0x1
    {
        Flags.bFirstRead = 0;
        UDPSetRxBuffer(0);
    }

    return UDPRxCount - wGetOffset;
9d004bb8:	978280f4 	lhu	v0,-32524(gp)
9d004bbc:	97838168 	lhu	v1,-32408(gp)
}
9d004bc0:	8fbf0014 	lw	ra,20(sp)
9d004bc4:	27bd0018 	addiu	sp,sp,24
    {
        Flags.bFirstRead = 0;
        UDPSetRxBuffer(0);
    }

    return UDPRxCount - wGetOffset;
9d004bc8:	00621023 	subu	v0,v1,v0
}
9d004bcc:	03e00008 	jr	ra
9d004bd0:	3042ffff 	andi	v0,v0,0xffff
    // If this is the very first time we are accessing this packet, 
    // move the read point to the begining of the packet.
    if(Flags.bFirstRead)
    {
        Flags.bFirstRead = 0;
        UDPSetRxBuffer(0);
9d004bd4:	00002021 	move	a0,zero
9d004bd8:	0f40123a 	jal	9d0048e8 <UDPSetRxBuffer>
9d004bdc:	a38280f0 	sb	v0,-32528(gp)
    }

    return UDPRxCount - wGetOffset;
9d004be0:	0b4012ef 	j	9d004bbc <UDPIsGetReady+0x3c>
9d004be4:	978280f4 	lhu	v0,-32524(gp)

9d004be8 <UDPGet>:
  	FALSE - No data remained in the read buffer
  ***************************************************************************/
BOOL UDPGet(BYTE *v)
{
	// Make sure that there is data to return
    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9d004be8:	978580f4 	lhu	a1,-32524(gp)
9d004bec:	97838168 	lhu	v1,-32408(gp)
  Return Values:
  	TRUE - A byte was successfully read
  	FALSE - No data remained in the read buffer
  ***************************************************************************/
BOOL UDPGet(BYTE *v)
{
9d004bf0:	27bdffe0 	addiu	sp,sp,-32
9d004bf4:	afbf001c 	sw	ra,28(sp)
	// Make sure that there is data to return
    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9d004bf8:	00a3182b 	sltu	v1,a1,v1
9d004bfc:	10600005 	beqz	v1,9d004c14 <UDPGet+0x2c>
9d004c00:	00001021 	move	v0,zero
9d004c04:	93858021 	lbu	a1,-32735(gp)
9d004c08:	93838164 	lbu	v1,-32412(gp)
9d004c0c:	10a30004 	beq	a1,v1,9d004c20 <UDPGet+0x38>
9d004c10:	00000000 	nop

    *v = MACGet();
    wGetOffset++;

    return TRUE;
}
9d004c14:	8fbf001c 	lw	ra,28(sp)
9d004c18:	03e00008 	jr	ra
9d004c1c:	27bd0020 	addiu	sp,sp,32
{
	// Make sure that there is data to return
    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
        return FALSE;

    *v = MACGet();
9d004c20:	0f400e10 	jal	9d003840 <MACGet>
9d004c24:	afa40010 	sw	a0,16(sp)
9d004c28:	8fa40010 	lw	a0,16(sp)
9d004c2c:	a0820000 	sb	v0,0(a0)
    wGetOffset++;
9d004c30:	978380f4 	lhu	v1,-32524(gp)

    return TRUE;
}
9d004c34:	8fbf001c 	lw	ra,28(sp)
        return FALSE;

    *v = MACGet();
    wGetOffset++;

    return TRUE;
9d004c38:	24020001 	li	v0,1
	// Make sure that there is data to return
    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
        return FALSE;

    *v = MACGet();
    wGetOffset++;
9d004c3c:	24630001 	addiu	v1,v1,1
9d004c40:	a78380f4 	sh	v1,-32524(gp)

    return TRUE;
}
9d004c44:	03e00008 	jr	ra
9d004c48:	27bd0020 	addiu	sp,sp,32

9d004c4c <UDPGetArray>:
WORD UDPGetArray(BYTE *cData, WORD wDataLen)
{
	WORD wBytesAvailable;
	
	// Make sure that there is data to return
    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9d004c4c:	978380f4 	lhu	v1,-32524(gp)
9d004c50:	97868168 	lhu	a2,-32408(gp)
  	The number of bytes successfully read from the UDP buffer.  If this
  	value is less than wDataLen, then the buffer was emptied and no more 
  	data is available.
  ***************************************************************************/
WORD UDPGetArray(BYTE *cData, WORD wDataLen)
{
9d004c54:	27bdffe8 	addiu	sp,sp,-24
9d004c58:	afbf0014 	sw	ra,20(sp)
	WORD wBytesAvailable;
	
	// Make sure that there is data to return
    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9d004c5c:	0066382b 	sltu	a3,v1,a2
  	The number of bytes successfully read from the UDP buffer.  If this
  	value is less than wDataLen, then the buffer was emptied and no more 
  	data is available.
  ***************************************************************************/
WORD UDPGetArray(BYTE *cData, WORD wDataLen)
{
9d004c60:	30a5ffff 	andi	a1,a1,0xffff
	WORD wBytesAvailable;
	
	// Make sure that there is data to return
    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9d004c64:	10e00005 	beqz	a3,9d004c7c <UDPGetArray+0x30>
9d004c68:	00001021 	move	v0,zero
9d004c6c:	93888021 	lbu	t0,-32735(gp)
9d004c70:	93878164 	lbu	a3,-32412(gp)
9d004c74:	51070004 	beql	t0,a3,9d004c88 <UDPGetArray+0x3c>
9d004c78:	00c31823 	subu	v1,a2,v1

	wDataLen = MACGetArray(cData, wDataLen);
    wGetOffset += wDataLen;

    return wDataLen;
}
9d004c7c:	8fbf0014 	lw	ra,20(sp)
9d004c80:	03e00008 	jr	ra
9d004c84:	27bd0018 	addiu	sp,sp,24
	// Make sure we don't try to read more data than exists
	wBytesAvailable = UDPRxCount - wGetOffset;
	if(wBytesAvailable < wDataLen)
		wDataLen = wBytesAvailable;

	wDataLen = MACGetArray(cData, wDataLen);
9d004c88:	3063ffff 	andi	v1,v1,0xffff
9d004c8c:	0065102b 	sltu	v0,v1,a1
9d004c90:	0f400e15 	jal	9d003854 <MACGetArray>
9d004c94:	0062280b 	movn	a1,v1,v0
    wGetOffset += wDataLen;
9d004c98:	978380f4 	lhu	v1,-32524(gp)

    return wDataLen;
}
9d004c9c:	8fbf0014 	lw	ra,20(sp)
9d004ca0:	27bd0018 	addiu	sp,sp,24
	wBytesAvailable = UDPRxCount - wGetOffset;
	if(wBytesAvailable < wDataLen)
		wDataLen = wBytesAvailable;

	wDataLen = MACGetArray(cData, wDataLen);
    wGetOffset += wDataLen;
9d004ca4:	00431821 	addu	v1,v0,v1

    return wDataLen;
}
9d004ca8:	03e00008 	jr	ra
9d004cac:	a78380f4 	sh	v1,-32524(gp)

9d004cb0 <UDPDiscard>:
	It is safe to call this function more than is necessary.  If no data is
	available, this function does nothing.
  ***************************************************************************/
void UDPDiscard(void)
{
	if(!Flags.bWasDiscarded)
9d004cb0:	938280f0 	lbu	v0,-32528(gp)
  Remarks:
	It is safe to call this function more than is necessary.  If no data is
	available, this function does nothing.
  ***************************************************************************/
void UDPDiscard(void)
{
9d004cb4:	27bdffe8 	addiu	sp,sp,-24
	if(!Flags.bWasDiscarded)
9d004cb8:	30420002 	andi	v0,v0,0x2
9d004cbc:	304200ff 	andi	v0,v0,0xff
9d004cc0:	1440000a 	bnez	v0,9d004cec <UDPDiscard+0x3c>
9d004cc4:	afbf0014 	sw	ra,20(sp)
	{
		MACDiscardRx();
9d004cc8:	0f400d87 	jal	9d00361c <MACDiscardRx>
9d004ccc:	00000000 	nop
		UDPRxCount = 0;
		SocketWithRxData = INVALID_UDP_SOCKET;
		Flags.bWasDiscarded = 1;
9d004cd0:	938280f0 	lbu	v0,-32528(gp)
9d004cd4:	24030001 	li	v1,1
void UDPDiscard(void)
{
	if(!Flags.bWasDiscarded)
	{
		MACDiscardRx();
		UDPRxCount = 0;
9d004cd8:	a7808168 	sh	zero,-32408(gp)
		SocketWithRxData = INVALID_UDP_SOCKET;
		Flags.bWasDiscarded = 1;
9d004cdc:	7c620844 	ins	v0,v1,0x1,0x1
{
	if(!Flags.bWasDiscarded)
	{
		MACDiscardRx();
		UDPRxCount = 0;
		SocketWithRxData = INVALID_UDP_SOCKET;
9d004ce0:	2403ffff 	li	v1,-1
9d004ce4:	a3838021 	sb	v1,-32735(gp)
		Flags.bWasDiscarded = 1;
9d004ce8:	a38280f0 	sb	v0,-32528(gp)
	}
}
9d004cec:	8fbf0014 	lw	ra,20(sp)
9d004cf0:	03e00008 	jr	ra
9d004cf4:	27bd0018 	addiu	sp,sp,24

9d004cf8 <UDPProcess>:
  	TRUE - A valid packet is waiting and the stack applications should be
  		called to handle it.
  	FALSE - The packet was discarded.
  ***************************************************************************/
BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len)
{
9d004cf8:	27bdffc8 	addiu	sp,sp,-56
9d004cfc:	afb20030 	sw	s2,48(sp)
9d004d00:	afb1002c 	sw	s1,44(sp)
9d004d04:	00809021 	move	s2,a0
9d004d08:	00a08821 	move	s1,a1
    DWORD_VAL		checksums;

	UDPRxCount = 0;

    // Retrieve UDP header.
    MACGetArray((BYTE*)&h, sizeof(h));
9d004d0c:	27a40010 	addiu	a0,sp,16
9d004d10:	24050008 	li	a1,8
  	TRUE - A valid packet is waiting and the stack applications should be
  		called to handle it.
  	FALSE - The packet was discarded.
  ***************************************************************************/
BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len)
{
9d004d14:	afbf0034 	sw	ra,52(sp)
9d004d18:	afb00028 	sw	s0,40(sp)
    UDP_HEADER		h;
    UDP_SOCKET		s;
    PSEUDO_HEADER	pseudoHeader;
    DWORD_VAL		checksums;

	UDPRxCount = 0;
9d004d1c:	a7808168 	sh	zero,-32408(gp)

    // Retrieve UDP header.
    MACGetArray((BYTE*)&h, sizeof(h));
9d004d20:	0f400e15 	jal	9d003854 <MACGetArray>
9d004d24:	30d0ffff 	andi	s0,a2,0xffff

    h.SourcePort        = swaps(h.SourcePort);
9d004d28:	0f402604 	jal	9d009810 <swaps>
9d004d2c:	97a40010 	lhu	a0,16(sp)
    h.DestinationPort   = swaps(h.DestinationPort);
9d004d30:	97a40012 	lhu	a0,18(sp)
9d004d34:	0f402604 	jal	9d009810 <swaps>
9d004d38:	a7a20010 	sh	v0,16(sp)
    h.Length            = swaps(h.Length) - sizeof(UDP_HEADER);
9d004d3c:	97a40014 	lhu	a0,20(sp)
9d004d40:	0f402604 	jal	9d009810 <swaps>
9d004d44:	a7a20012 	sh	v0,18(sp)

	// See if we need to validate the checksum field (0x0000 is disabled)
	if(h.Checksum)
9d004d48:	97a30016 	lhu	v1,22(sp)
    // Retrieve UDP header.
    MACGetArray((BYTE*)&h, sizeof(h));

    h.SourcePort        = swaps(h.SourcePort);
    h.DestinationPort   = swaps(h.DestinationPort);
    h.Length            = swaps(h.Length) - sizeof(UDP_HEADER);
9d004d4c:	2442fff8 	addiu	v0,v0,-8

	// See if we need to validate the checksum field (0x0000 is disabled)
	if(h.Checksum)
9d004d50:	14600044 	bnez	v1,9d004e64 <UDPProcess+0x16c>
9d004d54:	a7a20014 	sh	v0,20(sp)

	// Discard any packets received that were generated by ourself.  In 
	// structured Wi-Fi networks, the Access Point rebroadcasts our broadcast 
	// and multicast packets, causing self-reception to occur unless filtered 
	// out.
	if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val)
9d004d58:	3c02a001 	lui	v0,0xa001
9d004d5c:	24439a5c 	addiu	v1,v0,-26020
9d004d60:	8a490003 	lwl	t1,3(s2)
9d004d64:	88630003 	lwl	v1,3(v1)
9d004d68:	9a490000 	lwr	t1,0(s2)
9d004d6c:	98439a5c 	lwr	v1,-26020(v0)
9d004d70:	11230054 	beq	t1,v1,9d004ec4 <UDPProcess+0x1cc>
9d004d74:	3c0ba001 	lui	t3,0xa001
		// 1. If its destination port matches with our local port and
		// 2. Packet source IP address matches with previously saved socket remote IP address and
		// 3. Packet source port number matches with previously saved socket remote port number
		if(p->localPort == h->DestinationPort)
		{
			if(p->remotePort == h->SourcePort)
9d004d78:	256b9a9c 	addiu	t3,t3,-25956

	// Discard any packets received that were generated by ourself.  In 
	// structured Wi-Fi networks, the Access Point rebroadcasts our broadcast 
	// and multicast packets, causing self-reception to occur unless filtered 
	// out.
	if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val)
9d004d7c:	97a60012 	lhu	a2,18(sp)
		// 1. If its destination port matches with our local port and
		// 2. Packet source IP address matches with previously saved socket remote IP address and
		// 3. Packet source port number matches with previously saved socket remote port number
		if(p->localPort == h->DestinationPort)
		{
			if(p->remotePort == h->SourcePort)
9d004d80:	97aa0010 	lhu	t2,16(sp)
9d004d84:	240800ff 	li	t0,255
9d004d88:	00001821 	move	v1,zero
9d004d8c:	01601021 	move	v0,t3
		return INVALID_UDP_SOCKET;

	partialMatch = INVALID_UDP_SOCKET;

	p = UDPSocketInfo;
    for(s = 0; s < MAX_UDP_SOCKETS; s++)
9d004d90:	0b40136a 	j	9d004da8 <UDPProcess+0xb0>
9d004d94:	2407000a 	li	a3,10
9d004d98:	30a300ff 	andi	v1,a1,0xff
9d004d9c:	5067000f 	beql	v1,a3,9d004ddc <UDPProcess+0xe4>
9d004da0:	240200ff 	li	v0,255
				}
			}

			partialMatch = s;
		}
		p++;
9d004da4:	2442000e 	addiu	v0,v0,14
	{
		// This packet is said to be matching with current socket:
		// 1. If its destination port matches with our local port and
		// 2. Packet source IP address matches with previously saved socket remote IP address and
		// 3. Packet source port number matches with previously saved socket remote port number
		if(p->localPort == h->DestinationPort)
9d004da8:	9444000c 	lhu	a0,12(v0)
9d004dac:	1486fffa 	bne	a0,a2,9d004d98 <UDPProcess+0xa0>
9d004db0:	24650001 	addiu	a1,v1,1
		{
			if(p->remotePort == h->SourcePort)
9d004db4:	9444000a 	lhu	a0,10(v0)
9d004db8:	148afff7 	bne	a0,t2,9d004d98 <UDPProcess+0xa0>
9d004dbc:	00604021 	move	t0,v1
			{
				if(p->remoteNode.IPAddr.Val == remoteNode->IPAddr.Val)
9d004dc0:	88440003 	lwl	a0,3(v0)
9d004dc4:	98440000 	lwr	a0,0(v0)
9d004dc8:	11240017 	beq	t1,a0,9d004e28 <UDPProcess+0x130>
9d004dcc:	30a300ff 	andi	v1,a1,0xff
		return INVALID_UDP_SOCKET;

	partialMatch = INVALID_UDP_SOCKET;

	p = UDPSocketInfo;
    for(s = 0; s < MAX_UDP_SOCKETS; s++)
9d004dd0:	1467fff5 	bne	v1,a3,9d004da8 <UDPProcess+0xb0>
9d004dd4:	2442000e 	addiu	v0,v0,14
			partialMatch = s;
		}
		p++;
	}

	if(partialMatch != INVALID_UDP_SOCKET)
9d004dd8:	240200ff 	li	v0,255
9d004ddc:	11020039 	beq	t0,v0,9d004ec4 <UDPProcess+0x1cc>
9d004de0:	00081040 	sll	v0,t0,0x1
	{
		p = &UDPSocketInfo[partialMatch];

		memcpy((void*)&p->remoteNode,
9d004de4:	8a440003 	lwl	a0,3(s2)
9d004de8:	8a430007 	lwl	v1,7(s2)
9d004dec:	9a440000 	lwr	a0,0(s2)
9d004df0:	00082900 	sll	a1,t0,0x4
9d004df4:	00a21023 	subu	v0,a1,v0
9d004df8:	9a430004 	lwr	v1,4(s2)
9d004dfc:	01621021 	addu	v0,t3,v0
9d004e00:	a8440003 	swl	a0,3(v0)
9d004e04:	b8440000 	swr	a0,0(v0)
9d004e08:	a8430007 	swl	v1,7(v0)
9d004e0c:	b8430004 	swr	v1,4(v0)
9d004e10:	92430008 	lbu	v1,8(s2)
9d004e14:	a0430008 	sb	v1,8(v0)
9d004e18:	92430009 	lbu	v1,9(s2)
				(const void*)remoteNode, sizeof(p->remoteNode) );

		p->remotePort = h->SourcePort;
9d004e1c:	97a40010 	lhu	a0,16(sp)

	if(partialMatch != INVALID_UDP_SOCKET)
	{
		p = &UDPSocketInfo[partialMatch];

		memcpy((void*)&p->remoteNode,
9d004e20:	a0430009 	sb	v1,9(v0)
				(const void*)remoteNode, sizeof(p->remoteNode) );

		p->remotePort = h->SourcePort;
9d004e24:	a444000a 	sh	a0,10(v0)
    }
    else
    {
		SocketWithRxData = s;
        UDPRxCount = h.Length;
        Flags.bFirstRead = 1;
9d004e28:	938280f0 	lbu	v0,-32528(gp)
9d004e2c:	24030001 	li	v1,1
		Flags.bWasDiscarded = 0;
    }


    return TRUE;
}
9d004e30:	8fbf0034 	lw	ra,52(sp)
    }
    else
    {
		SocketWithRxData = s;
        UDPRxCount = h.Length;
        Flags.bFirstRead = 1;
9d004e34:	7c620004 	ins	v0,v1,0x0,0x1
		return FALSE;
    }
    else
    {
		SocketWithRxData = s;
        UDPRxCount = h.Length;
9d004e38:	97a30014 	lhu	v1,20(sp)
        Flags.bFirstRead = 1;
		Flags.bWasDiscarded = 0;
9d004e3c:	7c020844 	ins	v0,zero,0x1,0x1
9d004e40:	a38280f0 	sb	v0,-32528(gp)
    }


    return TRUE;
}
9d004e44:	8fb20030 	lw	s2,48(sp)
        Flags.bFirstRead = 1;
		Flags.bWasDiscarded = 0;
    }


    return TRUE;
9d004e48:	24020001 	li	v0,1
}
9d004e4c:	8fb1002c 	lw	s1,44(sp)
9d004e50:	8fb00028 	lw	s0,40(sp)
        MACDiscardRx();
		return FALSE;
    }
    else
    {
		SocketWithRxData = s;
9d004e54:	a3888021 	sb	t0,-32735(gp)
        UDPRxCount = h.Length;
9d004e58:	a7838168 	sh	v1,-32408(gp)
		Flags.bWasDiscarded = 0;
    }


    return TRUE;
}
9d004e5c:	03e00008 	jr	ra
9d004e60:	27bd0038 	addiu	sp,sp,56

	// See if we need to validate the checksum field (0x0000 is disabled)
	if(h.Checksum)
	{
	    // Calculate IP pseudoheader checksum.
	    pseudoHeader.SourceAddress		= remoteNode->IPAddr;
9d004e64:	8a420003 	lwl	v0,3(s2)
	    pseudoHeader.DestAddress.Val	= localIP->Val;
9d004e68:	8e230000 	lw	v1,0(s1)
	    pseudoHeader.Zero				= 0x0;
	    pseudoHeader.Protocol			= IP_PROT_UDP;
	    pseudoHeader.Length				= len;

	    SwapPseudoHeader(pseudoHeader);
9d004e6c:	02002021 	move	a0,s0

	// See if we need to validate the checksum field (0x0000 is disabled)
	if(h.Checksum)
	{
	    // Calculate IP pseudoheader checksum.
	    pseudoHeader.SourceAddress		= remoteNode->IPAddr;
9d004e70:	9a420000 	lwr	v0,0(s2)
	    pseudoHeader.DestAddress.Val	= localIP->Val;
9d004e74:	afa3001c 	sw	v1,28(sp)
	    pseudoHeader.Zero				= 0x0;
9d004e78:	a3a00020 	sb	zero,32(sp)

	// See if we need to validate the checksum field (0x0000 is disabled)
	if(h.Checksum)
	{
	    // Calculate IP pseudoheader checksum.
	    pseudoHeader.SourceAddress		= remoteNode->IPAddr;
9d004e7c:	afa20018 	sw	v0,24(sp)
	    pseudoHeader.DestAddress.Val	= localIP->Val;
	    pseudoHeader.Zero				= 0x0;
	    pseudoHeader.Protocol			= IP_PROT_UDP;
9d004e80:	24020011 	li	v0,17
9d004e84:	a3a20021 	sb	v0,33(sp)
	    pseudoHeader.Length				= len;

	    SwapPseudoHeader(pseudoHeader);
9d004e88:	0f402604 	jal	9d009810 <swaps>
9d004e8c:	a7b00022 	sh	s0,34(sp)
	
	    checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader,
9d004e90:	2405000c 	li	a1,12
9d004e94:	27a40018 	addiu	a0,sp,24
9d004e98:	0f40261b 	jal	9d00986c <CalcIPChecksum>
9d004e9c:	a7a20022 	sh	v0,34(sp)
9d004ea0:	00408821 	move	s1,v0
	                                    sizeof(pseudoHeader));
	
	
	    // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader
	    IPSetRxBuffer(0);
9d004ea4:	0f4024f1 	jal	9d0093c4 <IPSetRxBuffer>
9d004ea8:	00002021 	move	a0,zero
	    pseudoHeader.Protocol			= IP_PROT_UDP;
	    pseudoHeader.Length				= len;

	    SwapPseudoHeader(pseudoHeader);
	
	    checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader,
9d004eac:	00118827 	nor	s1,zero,s1
	                                    sizeof(pseudoHeader));
	
	
	    // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader
	    IPSetRxBuffer(0);
	    checksums.w[1] = CalcIPBufferChecksum(len);
9d004eb0:	0f400e43 	jal	9d00390c <CalcIPBufferChecksum>
9d004eb4:	02002021 	move	a0,s0
	
	    if(checksums.w[0] != checksums.w[1])
9d004eb8:	3231ffff 	andi	s1,s1,0xffff
9d004ebc:	1222ffa7 	beq	s1,v0,9d004d5c <UDPProcess+0x64>
9d004ec0:	3c02a001 	lui	v0,0xa001
    s = FindMatchingSocket(&h, remoteNode, localIP);
    if(s == INVALID_UDP_SOCKET)
    {
        // If there is no matching socket, There is no one to handle
        // this data.  Discard it.
        MACDiscardRx();
9d004ec4:	0f400d87 	jal	9d00361c <MACDiscardRx>
9d004ec8:	00000000 	nop
		Flags.bWasDiscarded = 0;
    }


    return TRUE;
}
9d004ecc:	8fbf0034 	lw	ra,52(sp)
    if(s == INVALID_UDP_SOCKET)
    {
        // If there is no matching socket, There is no one to handle
        // this data.  Discard it.
        MACDiscardRx();
		return FALSE;
9d004ed0:	00001021 	move	v0,zero
		Flags.bWasDiscarded = 0;
    }


    return TRUE;
}
9d004ed4:	8fb20030 	lw	s2,48(sp)
9d004ed8:	8fb1002c 	lw	s1,44(sp)
9d004edc:	8fb00028 	lw	s0,40(sp)
9d004ee0:	03e00008 	jr	ra
9d004ee4:	27bd0038 	addiu	sp,sp,56

9d004ee8 <TCPRAMCopy>:
	address (closer to 0x0000) than the source pointer.  However, if they do 
	overlap there must be at least 4 bytes of non-overlap to ensure correct 
	results due to hardware DMA requirements.
  ***************************************************************************/
static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength)
{
9d004ee8:	27bdffd8 	addiu	sp,sp,-40
9d004eec:	afb10020 	sw	s1,32(sp)
9d004ef0:	afb0001c 	sw	s0,28(sp)
9d004ef4:	afbf0024 	sw	ra,36(sp)
9d004ef8:	00808021 	move	s0,a0
	#if defined(SPIRAM_CS_TRIS)
	BYTE vBuffer[16];
	WORD w;
	#endif
		
	switch(vSourceType)
9d004efc:	14e0000e 	bnez	a3,9d004f38 <TCPRAMCopy+0x50>
9d004f00:	97b10038 	lhu	s1,56(sp)
				#endif
			}
			break;
	
		case TCP_ETH_RAM:
			switch(vDestType)
9d004f04:	14a00025 	bnez	a1,9d004f9c <TCPRAMCopy+0xb4>
9d004f08:	24020001 	li	v0,1
						MACSetReadPtr(ptrSource);
					MACGetArray((BYTE*)ptrDest, wLength);
					break;
	
				case TCP_ETH_RAM:
					MACMemCopyAsync(ptrDest, ptrSource, wLength);
9d004f0c:	00c02821 	move	a1,a2
9d004f10:	0f400e2f 	jal	9d0038bc <MACMemCopyAsync>
9d004f14:	02203021 	move	a2,s1
					while(!MACIsMemCopyDone());
9d004f18:	0f400e41 	jal	9d003904 <MACIsMemCopyDone>
9d004f1c:	00000000 	nop
9d004f20:	1040fffd 	beqz	v0,9d004f18 <TCPRAMCopy+0x30>
9d004f24:	8fbf0024 	lw	ra,36(sp)
					break;
			}
			break;
		#endif			
	}
}
9d004f28:	8fb10020 	lw	s1,32(sp)
9d004f2c:	8fb0001c 	lw	s0,28(sp)
9d004f30:	03e00008 	jr	ra
9d004f34:	27bd0028 	addiu	sp,sp,40
	#if defined(SPIRAM_CS_TRIS)
	BYTE vBuffer[16];
	WORD w;
	#endif
		
	switch(vSourceType)
9d004f38:	24020001 	li	v0,1
9d004f3c:	14e2fffa 	bne	a3,v0,9d004f28 <TCPRAMCopy+0x40>
9d004f40:	8fbf0024 	lw	ra,36(sp)
	{
		case TCP_PIC_RAM:
			switch(vDestType)
9d004f44:	14a0000d 	bnez	a1,9d004f7c <TCPRAMCopy+0x94>
9d004f48:	2402ffff 	li	v0,-1
				case TCP_PIC_RAM:
					memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength);
					break;
	
				case TCP_ETH_RAM:
					if(ptrDest!=(PTR_BASE)-1)
9d004f4c:	10820006 	beq	a0,v0,9d004f68 <TCPRAMCopy+0x80>
9d004f50:	02202821 	move	a1,s1
						MACSetWritePtr(ptrDest);
9d004f54:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d004f58:	afa60010 	sw	a2,16(sp)
9d004f5c:	8fa60010 	lw	a2,16(sp)
					MACPutArray((BYTE*)ptrSource, wLength);
9d004f60:	02202821 	move	a1,s1
					break;
			}
			break;
		#endif			
	}
}
9d004f64:	8fbf0024 	lw	ra,36(sp)
9d004f68:	8fb10020 	lw	s1,32(sp)
9d004f6c:	8fb0001c 	lw	s0,28(sp)
					break;
	
				case TCP_ETH_RAM:
					if(ptrDest!=(PTR_BASE)-1)
						MACSetWritePtr(ptrDest);
					MACPutArray((BYTE*)ptrSource, wLength);
9d004f70:	00c02021 	move	a0,a2
9d004f74:	0b400d45 	j	9d003514 <MACPutArray>
9d004f78:	27bd0028 	addiu	sp,sp,40
	#endif
		
	switch(vSourceType)
	{
		case TCP_PIC_RAM:
			switch(vDestType)
9d004f7c:	14a7ffea 	bne	a1,a3,9d004f28 <TCPRAMCopy+0x40>
9d004f80:	8fbf0024 	lw	ra,36(sp)
			{
				case TCP_PIC_RAM:
					memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength);
9d004f84:	00c02821 	move	a1,a2
9d004f88:	02203021 	move	a2,s1
					break;
			}
			break;
		#endif			
	}
}
9d004f8c:	8fb0001c 	lw	s0,28(sp)
9d004f90:	8fb10020 	lw	s1,32(sp)
	{
		case TCP_PIC_RAM:
			switch(vDestType)
			{
				case TCP_PIC_RAM:
					memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength);
9d004f94:	0b402fce 	j	9d00bf38 <memcpy>
9d004f98:	27bd0028 	addiu	sp,sp,40
				#endif
			}
			break;
	
		case TCP_ETH_RAM:
			switch(vDestType)
9d004f9c:	14a2ffe2 	bne	a1,v0,9d004f28 <TCPRAMCopy+0x40>
9d004fa0:	8fbf0024 	lw	ra,36(sp)
			{
				case TCP_PIC_RAM:
					if(ptrSource!=(PTR_BASE)-1)
9d004fa4:	2402ffff 	li	v0,-1
9d004fa8:	10c20004 	beq	a2,v0,9d004fbc <TCPRAMCopy+0xd4>
9d004fac:	02002021 	move	a0,s0
						MACSetReadPtr(ptrSource);
9d004fb0:	0f400e0d 	jal	9d003834 <MACSetReadPtr>
9d004fb4:	00c02021 	move	a0,a2
					MACGetArray((BYTE*)ptrDest, wLength);
9d004fb8:	02002021 	move	a0,s0
9d004fbc:	02202821 	move	a1,s1
					break;
			}
			break;
		#endif			
	}
}
9d004fc0:	8fbf0024 	lw	ra,36(sp)
9d004fc4:	8fb10020 	lw	s1,32(sp)
9d004fc8:	8fb0001c 	lw	s0,28(sp)
			switch(vDestType)
			{
				case TCP_PIC_RAM:
					if(ptrSource!=(PTR_BASE)-1)
						MACSetReadPtr(ptrSource);
					MACGetArray((BYTE*)ptrDest, wLength);
9d004fcc:	0b400e15 	j	9d003854 <MACGetArray>
9d004fd0:	27bd0028 	addiu	sp,sp,40

9d004fd4 <SyncTCB>:
// Does nothing on cache hit.
static void SyncTCB(void)
{
	static TCP_SOCKET hLastTCB = INVALID_SOCKET;
	
	if(hLastTCB == hCurrentTCP)
9d004fd4:	93838024 	lbu	v1,-32732(gp)
9d004fd8:	93828023 	lbu	v0,-32733(gp)


// Flushes MyTCB cache and loads up the specified TCB.
// Does nothing on cache hit.
static void SyncTCB(void)
{
9d004fdc:	27bdffd8 	addiu	sp,sp,-40
9d004fe0:	afbf0024 	sw	ra,36(sp)
9d004fe4:	afb10020 	sw	s1,32(sp)
	static TCP_SOCKET hLastTCB = INVALID_SOCKET;
	
	if(hLastTCB == hCurrentTCP)
9d004fe8:	10620021 	beq	v1,v0,9d005070 <SyncTCB+0x9c>
9d004fec:	afb0001c 	sw	s0,28(sp)
		return;

	if(hLastTCB != INVALID_SOCKET)
9d004ff0:	240400fe 	li	a0,254
9d004ff4:	10640023 	beq	v1,a0,9d005084 <SyncTCB+0xb0>
9d004ff8:	24070001 	li	a3,1
	{
		// Save the current TCB
		TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB));
9d004ffc:	00031100 	sll	v0,v1,0x4
9d005000:	3c11a000 	lui	s1,0xa000
9d005004:	00031980 	sll	v1,v1,0x6
9d005008:	00621823 	subu	v1,v1,v0
9d00500c:	26314700 	addiu	s1,s1,18176
9d005010:	02231821 	addu	v1,s1,v1
9d005014:	8c640000 	lw	a0,0(v1)
9d005018:	9065002c 	lbu	a1,44(v1)
9d00501c:	3c10a000 	lui	s0,0xa000
9d005020:	261048e0 	addiu	s0,s0,18656
9d005024:	2402002c 	li	v0,44
9d005028:	2484ffd4 	addiu	a0,a0,-44
9d00502c:	02003021 	move	a2,s0
9d005030:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d005034:	afa20010 	sw	v0,16(sp)
9d005038:	93828023 	lbu	v0,-32733(gp)
	}

	// Load up the new TCB
	hLastTCB = hCurrentTCP;
	TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB));
9d00503c:	00022180 	sll	a0,v0,0x6
9d005040:	00021900 	sll	v1,v0,0x4
9d005044:	00831823 	subu	v1,a0,v1
9d005048:	02238821 	addu	s1,s1,v1
9d00504c:	8e260000 	lw	a2,0(s1)
9d005050:	9227002c 	lbu	a3,44(s1)
		// Save the current TCB
		TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB));
	}

	// Load up the new TCB
	hLastTCB = hCurrentTCP;
9d005054:	a3828024 	sb	v0,-32732(gp)
	TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB));
9d005058:	02002021 	move	a0,s0
9d00505c:	2402002c 	li	v0,44
9d005060:	24050001 	li	a1,1
9d005064:	24c6ffd4 	addiu	a2,a2,-44
9d005068:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d00506c:	afa20010 	sw	v0,16(sp)
}
9d005070:	8fbf0024 	lw	ra,36(sp)
9d005074:	8fb10020 	lw	s1,32(sp)
9d005078:	8fb0001c 	lw	s0,28(sp)
9d00507c:	03e00008 	jr	ra
9d005080:	27bd0028 	addiu	sp,sp,40
	static TCP_SOCKET hLastTCB = INVALID_SOCKET;
	
	if(hLastTCB == hCurrentTCP)
		return;

	if(hLastTCB != INVALID_SOCKET)
9d005084:	3c10a000 	lui	s0,0xa000
9d005088:	3c11a000 	lui	s1,0xa000
9d00508c:	261048e0 	addiu	s0,s0,18656
9d005090:	0b40140f 	j	9d00503c <SyncTCB+0x68>
9d005094:	26314700 	addiu	s1,s1,18176

9d005098 <SwapTCPHeader>:

  Returns:
	None
  ***************************************************************************/
static void SwapTCPHeader(TCP_HEADER* header)
{
9d005098:	27bdffe8 	addiu	sp,sp,-24
9d00509c:	afb00010 	sw	s0,16(sp)
9d0050a0:	00808021 	move	s0,a0
	header->SourcePort      = swaps(header->SourcePort);
9d0050a4:	94840000 	lhu	a0,0(a0)

  Returns:
	None
  ***************************************************************************/
static void SwapTCPHeader(TCP_HEADER* header)
{
9d0050a8:	afbf0014 	sw	ra,20(sp)
	header->SourcePort      = swaps(header->SourcePort);
9d0050ac:	0f402604 	jal	9d009810 <swaps>
9d0050b0:	00000000 	nop
	header->DestPort        = swaps(header->DestPort);
9d0050b4:	96040002 	lhu	a0,2(s0)
9d0050b8:	0f402604 	jal	9d009810 <swaps>
9d0050bc:	a6020000 	sh	v0,0(s0)
	header->SeqNumber       = swapl(header->SeqNumber);
9d0050c0:	8e040004 	lw	a0,4(s0)
9d0050c4:	0f40260b 	jal	9d00982c <swapl>
9d0050c8:	a6020002 	sh	v0,2(s0)
	header->AckNumber       = swapl(header->AckNumber);
9d0050cc:	8e040008 	lw	a0,8(s0)
9d0050d0:	0f40260b 	jal	9d00982c <swapl>
9d0050d4:	ae020004 	sw	v0,4(s0)
	header->Window          = swaps(header->Window);
9d0050d8:	9604000e 	lhu	a0,14(s0)
9d0050dc:	0f402604 	jal	9d009810 <swaps>
9d0050e0:	ae020008 	sw	v0,8(s0)
	header->Checksum        = swaps(header->Checksum);
9d0050e4:	96040010 	lhu	a0,16(s0)
9d0050e8:	0f402604 	jal	9d009810 <swaps>
9d0050ec:	a602000e 	sh	v0,14(s0)
	header->UrgentPointer   = swaps(header->UrgentPointer);
9d0050f0:	96040012 	lhu	a0,18(s0)
9d0050f4:	0f402604 	jal	9d009810 <swaps>
9d0050f8:	a6020010 	sh	v0,16(s0)
}
9d0050fc:	8fbf0014 	lw	ra,20(sp)
	header->DestPort        = swaps(header->DestPort);
	header->SeqNumber       = swapl(header->SeqNumber);
	header->AckNumber       = swapl(header->AckNumber);
	header->Window          = swaps(header->Window);
	header->Checksum        = swaps(header->Checksum);
	header->UrgentPointer   = swaps(header->UrgentPointer);
9d005100:	a6020012 	sh	v0,18(s0)
}
9d005104:	8fb00010 	lw	s0,16(sp)
9d005108:	03e00008 	jr	ra
9d00510c:	27bd0018 	addiu	sp,sp,24

9d005110 <SendTCP>:

  Returns:
	None
  ***************************************************************************/
static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags)
{
9d005110:	27bdff98 	addiu	sp,sp,-104
9d005114:	afb00044 	sw	s0,68(sp)
9d005118:	00808021 	move	s0,a0
9d00511c:	afb2004c 	sw	s2,76(sp)
9d005120:	afbf0064 	sw	ra,100(sp)
9d005124:	afb70060 	sw	s7,96(sp)
9d005128:	afb6005c 	sw	s6,92(sp)
9d00512c:	afb50058 	sw	s5,88(sp)
9d005130:	afb40054 	sw	s4,84(sp)
9d005134:	afb30050 	sw	s3,80(sp)
9d005138:	afb10048 	sw	s1,72(sp)
	TCP_HEADER      header;
	TCP_OPTIONS     options;
	PSEUDO_HEADER   pseudoHeader;
	WORD 			len;
	
	SyncTCB();
9d00513c:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d005140:	00a09021 	move	s2,a1

	// FINs must be handled specially
	if(vTCPFlags & FIN)
9d005144:	32020001 	andi	v0,s0,0x1
9d005148:	1440011c 	bnez	v0,9d0055bc <SendTCP+0x4ac>
9d00514c:	93838023 	lbu	v1,-32733(gp)
9d005150:	3c11a000 	lui	s1,0xa000
9d005154:	26314700 	addiu	s1,s1,18176
9d005158:	00031100 	sll	v0,v1,0x4
9d00515c:	00031980 	sll	v1,v1,0x6
		vTCPFlags &= ~FIN;
	}

	// Status will now be synched, disable automatic future 
	// status transmissions
	MyTCBStub.Flags.bTimer2Enabled = 0;
9d005160:	00621023 	subu	v0,v1,v0
9d005164:	02221021 	addu	v0,s1,v0
9d005168:	8c440028 	lw	a0,40(v0)
	MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9d00516c:	2403ff9f 	li	v1,-97
	MyTCBStub.Flags.bOneSegmentReceived = 0;
9d005170:	00831824 	and	v1,a0,v1
	MyTCBStub.Flags.bTXASAP = 0;
	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9d005174:	2404fd7f 	li	a0,-641
9d005178:	00641824 	and	v1,v1,a0
9d00517c:	7c035284 	ins	v1,zero,0xa,0x1
	MyTCBStub.Flags.bHalfFullFlush = 0;
9d005180:	7c034204 	ins	v1,zero,0x8,0x1
9d005184:	ac430028 	sw	v1,40(v0)

	//  Make sure that we can write to the MAC transmit area
	while(!IPIsTxReady());
9d005188:	0f400cf1 	jal	9d0033c4 <MACIsTxReady>
9d00518c:	00000000 	nop
9d005190:	1040fffd 	beqz	v0,9d005188 <SendTCP+0x78>
9d005194:	32020006 	andi	v0,s0,0x6

	// Put all socket application data in the TX space
	if(vTCPFlags & (SYN | RST))
9d005198:	104000b3 	beqz	v0,9d005468 <SendTCP+0x358>
9d00519c:	93968023 	lbu	s6,-32733(gp)
9d0051a0:	3c15a000 	lui	s5,0xa000
9d0051a4:	26b448e0 	addiu	s4,s5,18656
	}

	// Ensure that all packets with data of some kind are 
	// retransmitted by TCPTick() until acknowledged
	// Pure ACK packets with no data are not ACKed back in TCP
	if(len || (vTCPFlags & (SYN | FIN)))
9d0051a8:	32020003 	andi	v0,s0,0x3
9d0051ac:	10400113 	beqz	v0,9d0055fc <SendTCP+0x4ec>
9d0051b0:	00009821 	move	s3,zero
		// Push (PSH) all data for enhanced responsiveness on 
		// the remote end, especially with GUIs
		if(len)
			vTCPFlags |= PSH;

		if(vSendFlags & SENDTCP_RESET_TIMERS)
9d0051b4:	32520001 	andi	s2,s2,0x1
9d0051b8:	1640010c 	bnez	s2,9d0055ec <SendTCP+0x4dc>
9d0051bc:	3c020004 	lui	v0,0x4
		{
			MyTCB.retryCount = 0;
			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
		}	

		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9d0051c0:	0f400b53 	jal	9d002d4c <TickGet>
9d0051c4:	26720014 	addiu	s2,s3,20
9d0051c8:	00162180 	sll	a0,s6,0x6
9d0051cc:	00161900 	sll	v1,s6,0x4
		MyTCBStub.Flags.bTimerEnabled = 1;
9d0051d0:	93968023 	lbu	s6,-32733(gp)
		{
			MyTCB.retryCount = 0;
			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
		}	

		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9d0051d4:	8ea648e0 	lw	a2,18656(s5)
9d0051d8:	00831823 	subu	v1,a0,v1
		MyTCBStub.Flags.bTimerEnabled = 1;
9d0051dc:	00162980 	sll	a1,s6,0x6
9d0051e0:	00162100 	sll	a0,s6,0x4
		{
			MyTCB.retryCount = 0;
			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
		}	

		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9d0051e4:	02231821 	addu	v1,s1,v1
9d0051e8:	00461021 	addu	v0,v0,a2
		MyTCBStub.Flags.bTimerEnabled = 1;
9d0051ec:	00a42023 	subu	a0,a1,a0
		{
			MyTCB.retryCount = 0;
			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
		}	

		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9d0051f0:	ac62001c 	sw	v0,28(v1)
		MyTCBStub.Flags.bTimerEnabled = 1;
9d0051f4:	02242021 	addu	a0,s1,a0
9d0051f8:	8c820028 	lw	v0,40(a0)
9d0051fc:	24030001 	li	v1,1
9d005200:	7c622104 	ins	v0,v1,0x4,0x1
9d005204:	ac820028 	sw	v0,40(a0)
9d005208:	8e830004 	lw	v1,4(s4)
9d00520c:	3252ffff 	andi	s2,s2,0xffff

	header.SourcePort			= MyTCB.localPort.Val;
	header.DestPort				= MyTCB.remotePort.Val;
	header.SeqNumber			= MyTCB.MySEQ;
	header.AckNumber			= MyTCB.RemoteSEQ;
	header.Flags.bits.Reserved2	= 0;
9d005210:	8fa20038 	lw	v0,56(sp)
	
		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
	}
	

	header.SourcePort			= MyTCB.localPort.Val;
9d005214:	96870012 	lhu	a3,18(s4)
	header.DestPort				= MyTCB.remotePort.Val;
9d005218:	96860010 	lhu	a2,16(s4)
	header.SeqNumber			= MyTCB.MySEQ;
	header.AckNumber			= MyTCB.RemoteSEQ;
9d00521c:	8e850008 	lw	a1,8(s4)
	header.Flags.bits.Reserved2	= 0;
9d005220:	7c027b84 	ins	v0,zero,0xe,0x2
	header.Flags.byte			= vTCPFlags;
	header.UrgentPointer        = 0;

	// Update our send sequence number and ensure retransmissions 
	// of SYNs and FINs use the right sequence number
	MyTCB.MySEQ += (DWORD)len;
9d005224:	02632021 	addu	a0,s3,v1
	header.SourcePort			= MyTCB.localPort.Val;
	header.DestPort				= MyTCB.remotePort.Val;
	header.SeqNumber			= MyTCB.MySEQ;
	header.AckNumber			= MyTCB.RemoteSEQ;
	header.Flags.bits.Reserved2	= 0;
	header.DataOffset.Reserved3	= 0;
9d005228:	7c021804 	ins	v0,zero,0x0,0x4
	header.UrgentPointer        = 0;

	// Update our send sequence number and ensure retransmissions 
	// of SYNs and FINs use the right sequence number
	MyTCB.MySEQ += (DWORD)len;
	if(vTCPFlags & SYN)
9d00522c:	32130002 	andi	s3,s0,0x2
	header.SourcePort			= MyTCB.localPort.Val;
	header.DestPort				= MyTCB.remotePort.Val;
	header.SeqNumber			= MyTCB.MySEQ;
	header.AckNumber			= MyTCB.RemoteSEQ;
	header.Flags.bits.Reserved2	= 0;
	header.DataOffset.Reserved3	= 0;
9d005230:	afa20038 	sw	v0,56(sp)
	
		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
	}
	

	header.SourcePort			= MyTCB.localPort.Val;
9d005234:	a7a7002c 	sh	a3,44(sp)
	header.DestPort				= MyTCB.remotePort.Val;
9d005238:	a7a6002e 	sh	a2,46(sp)
	header.SeqNumber			= MyTCB.MySEQ;
9d00523c:	afa30030 	sw	v1,48(sp)
	header.AckNumber			= MyTCB.RemoteSEQ;
9d005240:	afa50034 	sw	a1,52(sp)
	header.Flags.bits.Reserved2	= 0;
	header.DataOffset.Reserved3	= 0;
	header.Flags.byte			= vTCPFlags;
9d005244:	a3b00039 	sb	s0,57(sp)
	header.UrgentPointer        = 0;
9d005248:	a7a0003e 	sh	zero,62(sp)

	// Update our send sequence number and ensure retransmissions 
	// of SYNs and FINs use the right sequence number
	MyTCB.MySEQ += (DWORD)len;
	if(vTCPFlags & SYN)
9d00524c:	1260000a 	beqz	s3,9d005278 <SendTCP+0x168>
9d005250:	ae840004 	sw	a0,4(s4)
	{
		// SEG.ACK needs to be zero for the first SYN packet for compatibility 
		// with certain paranoid TCP/IP stacks, even though the ACK flag isn't 
		// set (indicating that the AckNumber field is unused).
		if(!(vTCPFlags & ACK))
9d005254:	32020010 	andi	v0,s0,0x10
9d005258:	50400001 	beqzl	v0,9d005260 <SendTCP+0x150>
9d00525c:	afa00034 	sw	zero,52(sp)
			header.AckNumber = 0x00000000;

		if(MyTCB.flags.bSYNSent)
9d005260:	8e820024 	lw	v0,36(s4)
9d005264:	7c450440 	ext	a1,v0,0x11,0x1
9d005268:	50a000ff 	beqzl	a1,9d005668 <SendTCP+0x558>
9d00526c:	24030001 	li	v1,1
			header.SeqNumber--;
9d005270:	2463ffff 	addiu	v1,v1,-1
9d005274:	afa30030 	sw	v1,48(sp)
		{
			MyTCB.MySEQ++;
			MyTCB.flags.bSYNSent = 1;
		}
	}
	if(vTCPFlags & FIN)
9d005278:	32100001 	andi	s0,s0,0x1
9d00527c:	12000009 	beqz	s0,9d0052a4 <SendTCP+0x194>
9d005280:	00161100 	sll	v0,s6,0x4
	{
		if(MyTCB.flags.bFINSent)
9d005284:	8e820024 	lw	v0,36(s4)
9d005288:	7c430400 	ext	v1,v0,0x10,0x1
9d00528c:	506000f0 	beqzl	v1,9d005650 <SendTCP+0x540>
9d005290:	8e830004 	lw	v1,4(s4)
			header.SeqNumber--;
9d005294:	8fa20030 	lw	v0,48(sp)
9d005298:	2442ffff 	addiu	v0,v0,-1
9d00529c:	afa20030 	sw	v0,48(sp)
			MyTCB.flags.bFINSent = 1;
		}
	}

	// Calculate the amount of free space in the RX buffer area of this socket
	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9d0052a0:	00161100 	sll	v0,s6,0x4
9d0052a4:	0016b180 	sll	s6,s6,0x6
9d0052a8:	02c2b023 	subu	s6,s6,v0
9d0052ac:	02368821 	addu	s1,s1,s6
9d0052b0:	8e220014 	lw	v0,20(s1)
9d0052b4:	8e230018 	lw	v1,24(s1)
9d0052b8:	0043202b 	sltu	a0,v0,v1
9d0052bc:	5480005f 	bnezl	a0,9d00543c <SendTCP+0x32c>
9d0052c0:	2463ffff 	addiu	v1,v1,-1
		header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9d0052c4:	8e250008 	lw	a1,8(s1)
9d0052c8:	8e240004 	lw	a0,4(s1)
9d0052cc:	00651821 	addu	v1,v1,a1
9d0052d0:	00621023 	subu	v0,v1,v0
9d0052d4:	00441023 	subu	v0,v0,a0
	else
		header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;

	// Calculate the amount of free space in the MAC RX buffer area and adjust window if needed
	wVal.Val = MACGetFreeRxSize()-64;
9d0052d8:	0f400e25 	jal	9d003894 <MACGetFreeRxSize>
9d0052dc:	a7a2003a 	sh	v0,58(sp)
9d0052e0:	2442ffc0 	addiu	v0,v0,-64
9d0052e4:	3042ffff 	andi	v0,v0,0xffff
	if((SHORT)wVal.Val < (SHORT)0)
9d0052e8:	7c021e20 	seh	v1,v0
9d0052ec:	0460005b 	bltz	v1,9d00545c <SendTCP+0x34c>
9d0052f0:	a7a20018 	sh	v0,24(sp)
		wVal.Val = 0;
	// Force the remote node to throttle back if we are running low on general RX buffer space
	if(header.Window > wVal.Val)
9d0052f4:	97a3003a 	lhu	v1,58(sp)
9d0052f8:	0043182b 	sltu	v1,v0,v1
9d0052fc:	54600001 	bnezl	v1,9d005304 <SendTCP+0x1f4>
9d005300:	a7a2003a 	sh	v0,58(sp)
		header.Window = wVal.Val;

	SwapTCPHeader(&header);
9d005304:	0f401426 	jal	9d005098 <SwapTCPHeader>
9d005308:	27a4002c 	addiu	a0,sp,44


	len += sizeof(header);
	header.DataOffset.Val   = sizeof(header) >> 2;
9d00530c:	8fa20038 	lw	v0,56(sp)
9d005310:	24030005 	li	v1,5
9d005314:	7c623904 	ins	v0,v1,0x4,0x4

	// Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
	if(vTCPFlags & SYN)
9d005318:	1260000c 	beqz	s3,9d00534c <SendTCP+0x23c>
9d00531c:	afa20038 	sw	v0,56(sp)
		options.Length = 0x04;

		// Load MSS and swap to big endian
		options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8);

		header.DataOffset.Val   += sizeof(options) >> 2;
9d005320:	24030006 	li	v1,6
9d005324:	7c623904 	ins	v0,v1,0x4,0x4

	// Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
	if(vTCPFlags & SYN)
	{
		len += sizeof(options);
		options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
9d005328:	24030002 	li	v1,2
9d00532c:	a3a3001c 	sb	v1,28(sp)
		options.Length = 0x04;
9d005330:	24030004 	li	v1,4
	header.DataOffset.Val   = sizeof(header) >> 2;

	// Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
	if(vTCPFlags & SYN)
	{
		len += sizeof(options);
9d005334:	26520004 	addiu	s2,s2,4
		options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
		options.Length = 0x04;
9d005338:	a3a3001d 	sb	v1,29(sp)

		// Load MSS and swap to big endian
		options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8);
9d00533c:	24031802 	li	v1,6146
	header.DataOffset.Val   = sizeof(header) >> 2;

	// Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
	if(vTCPFlags & SYN)
	{
		len += sizeof(options);
9d005340:	3252ffff 	andi	s2,s2,0xffff
		options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
		options.Length = 0x04;

		// Load MSS and swap to big endian
		options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8);
9d005344:	a7a3001e 	sh	v1,30(sp)

		header.DataOffset.Val   += sizeof(options) >> 2;
9d005348:	afa20038 	sw	v0,56(sp)
	}

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9d00534c:	3c02a001 	lui	v0,0xa001
9d005350:	24439a5c 	addiu	v1,v0,-26020
9d005354:	88630003 	lwl	v1,3(v1)
	pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
9d005358:	8e850018 	lw	a1,24(s4)
	pseudoHeader.Zero           = 0x0;
	pseudoHeader.Protocol       = IP_PROT_TCP;
	pseudoHeader.Length			= len;
	SwapPseudoHeader(pseudoHeader);
9d00535c:	02402021 	move	a0,s2

		header.DataOffset.Val   += sizeof(options) >> 2;
	}

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9d005360:	98439a5c 	lwr	v1,-26020(v0)
	pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
	pseudoHeader.Zero           = 0x0;
	pseudoHeader.Protocol       = IP_PROT_TCP;
9d005364:	24020006 	li	v0,6
		header.DataOffset.Val   += sizeof(options) >> 2;
	}

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
	pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
9d005368:	afa50024 	sw	a1,36(sp)

		header.DataOffset.Val   += sizeof(options) >> 2;
	}

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9d00536c:	afa30020 	sw	v1,32(sp)
	pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
	pseudoHeader.Zero           = 0x0;
9d005370:	a3a00028 	sb	zero,40(sp)
	pseudoHeader.Protocol       = IP_PROT_TCP;
9d005374:	a3a20029 	sb	v0,41(sp)
	pseudoHeader.Length			= len;
	SwapPseudoHeader(pseudoHeader);
9d005378:	0f402604 	jal	9d009810 <swaps>
9d00537c:	a7b2002a 	sh	s2,42(sp)
	header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader));
9d005380:	2405000c 	li	a1,12
9d005384:	27a40020 	addiu	a0,sp,32
9d005388:	0f40261b 	jal	9d00986c <CalcIPChecksum>
9d00538c:	a7a2002a 	sh	v0,42(sp)
9d005390:	00021027 	nor	v0,zero,v0

	// Write IP header
	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9d005394:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d005398:	a7a2003c 	sh	v0,60(sp)
9d00539c:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d0053a0:	2444000e 	addiu	a0,v0,14
	IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len);
9d0053a4:	3c04a000 	lui	a0,0xa000
9d0053a8:	24050006 	li	a1,6
9d0053ac:	248448f8 	addiu	a0,a0,18680
9d0053b0:	0f4024b9 	jal	9d0092e4 <IPPutHeader>
9d0053b4:	02403021 	move	a2,s2
	MACPutArray((BYTE*)&header, sizeof(header));
9d0053b8:	27a4002c 	addiu	a0,sp,44
9d0053bc:	0f400d45 	jal	9d003514 <MACPutArray>
9d0053c0:	24050014 	li	a1,20
	if(vTCPFlags & SYN)
9d0053c4:	12600003 	beqz	s3,9d0053d4 <SendTCP+0x2c4>
9d0053c8:	27a4001c 	addiu	a0,sp,28
		MACPutArray((BYTE*)&options, sizeof(options));
9d0053cc:	0f400d45 	jal	9d003514 <MACPutArray>
9d0053d0:	24050004 	li	a1,4

	// Update the TCP checksum
	MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9d0053d4:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d0053d8:	00000000 	nop
9d0053dc:	0f400e0d 	jal	9d003834 <MACSetReadPtr>
9d0053e0:	24440022 	addiu	a0,v0,34
	wVal.Val = CalcIPBufferChecksum(len);
9d0053e4:	0f400e43 	jal	9d00390c <CalcIPBufferChecksum>
9d0053e8:	02402021 	move	a0,s2
	if(LFSRRand() > DEBUG_GENERATE_TX_LOSS)
	{
		wVal.Val++;
	}
#endif
	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16);
9d0053ec:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d0053f0:	a7a20018 	sh	v0,24(sp)
9d0053f4:	0f400cee 	jal	9d0033b8 <MACSetWritePtr>
9d0053f8:	24440032 	addiu	a0,v0,50
	MACPutArray((BYTE*)&wVal, sizeof(WORD));
9d0053fc:	27a40018 	addiu	a0,sp,24
9d005400:	0f400d45 	jal	9d003514 <MACPutArray>
9d005404:	24050002 	li	a1,2

	// Physically start the packet transmission over the network
	MACFlush();
9d005408:	0f400d77 	jal	9d0035dc <MACFlush>
9d00540c:	00000000 	nop
}
9d005410:	8fbf0064 	lw	ra,100(sp)
9d005414:	8fb70060 	lw	s7,96(sp)
9d005418:	8fb6005c 	lw	s6,92(sp)
9d00541c:	8fb50058 	lw	s5,88(sp)
9d005420:	8fb40054 	lw	s4,84(sp)
9d005424:	8fb30050 	lw	s3,80(sp)
9d005428:	8fb2004c 	lw	s2,76(sp)
9d00542c:	8fb10048 	lw	s1,72(sp)
9d005430:	8fb00044 	lw	s0,68(sp)
9d005434:	03e00008 	jr	ra
9d005438:	27bd0068 	addiu	sp,sp,104

	// Calculate the amount of free space in the RX buffer area of this socket
	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
		header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
	else
		header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9d00543c:	00621023 	subu	v0,v1,v0

	// Calculate the amount of free space in the MAC RX buffer area and adjust window if needed
	wVal.Val = MACGetFreeRxSize()-64;
9d005440:	0f400e25 	jal	9d003894 <MACGetFreeRxSize>
9d005444:	a7a2003a 	sh	v0,58(sp)
9d005448:	2442ffc0 	addiu	v0,v0,-64
9d00544c:	3042ffff 	andi	v0,v0,0xffff
	if((SHORT)wVal.Val < (SHORT)0)
9d005450:	7c021e20 	seh	v1,v0
9d005454:	0461ffa7 	bgez	v1,9d0052f4 <SendTCP+0x1e4>
9d005458:	a7a20018 	sh	v0,24(sp)
		wVal.Val = 0;
9d00545c:	a7a00018 	sh	zero,24(sp)
9d005460:	0b4014bd 	j	9d0052f4 <SendTCP+0x1e4>
9d005464:	00001021 	move	v0,zero
		len = 0;
	}
	else
	{
		// Begin copying any application data over to the TX space
		if(MyTCBStub.txHead == MyTCB.txUnackedTail)
9d005468:	3c15a000 	lui	s5,0xa000
9d00546c:	26b448e0 	addiu	s4,s5,18656
9d005470:	00161100 	sll	v0,s6,0x4
9d005474:	00161980 	sll	v1,s6,0x6
9d005478:	00622023 	subu	a0,v1,v0
9d00547c:	02242021 	addu	a0,s1,a0
9d005480:	8c85000c 	lw	a1,12(a0)
9d005484:	8e86000c 	lw	a2,12(s4)
9d005488:	10a6003c 	beq	a1,a2,9d00557c <SendTCP+0x46c>
9d00548c:	00009821 	move	s3,zero
		{
			// All caught up on data TX, no real data for this packet
			len = 0;
		}
		else if(MyTCBStub.txHead > MyTCB.txUnackedTail)
9d005490:	00c5102b 	sltu	v0,a2,a1
9d005494:	14400079 	bnez	v0,9d00567c <SendTCP+0x56c>
9d005498:	96820014 	lhu	v0,20(s4)
			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len);
			MyTCB.txUnackedTail += len;
		}
		else
		{
			pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail;
9d00549c:	8c870004 	lw	a3,4(a0)
			len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart;
9d0054a0:	8c830000 	lw	v1,0(a0)
			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len);
			MyTCB.txUnackedTail += len;
		}
		else
		{
			pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail;
9d0054a4:	00e63023 	subu	a2,a3,a2
9d0054a8:	30c6ffff 	andi	a2,a2,0xffff
			len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart;
9d0054ac:	00c31823 	subu	v1,a2,v1
9d0054b0:	00652821 	addu	a1,v1,a1
9d0054b4:	30a5ffff 	andi	a1,a1,0xffff

			if(len > MyTCB.remoteWindow)
				len = MyTCB.remoteWindow;

			if(len > MyTCB.wRemoteMSS)
9d0054b8:	96830028 	lhu	v1,40(s4)
			MyTCB.txUnackedTail += len;
		}
		else
		{
			pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail;
			len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart;
9d0054bc:	0045982b 	sltu	s3,v0,a1
9d0054c0:	0053280b 	movn	a1,v0,s3

			if(len > MyTCB.remoteWindow)
				len = MyTCB.remoteWindow;

			if(len > MyTCB.wRemoteMSS)
9d0054c4:	0065102b 	sltu	v0,v1,a1
9d0054c8:	00a09821 	move	s3,a1
9d0054cc:	10400006 	beqz	v0,9d0054e8 <SendTCP+0x3d8>
9d0054d0:	a7a6002a 	sh	a2,42(sp)
			{
				len = MyTCB.wRemoteMSS;
				MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9d0054d4:	8c820028 	lw	v0,40(a0)
9d0054d8:	00609821 	move	s3,v1
9d0054dc:	24030001 	li	v1,1
9d0054e0:	7c625284 	ins	v0,v1,0xa,0x1
9d0054e4:	ac820028 	sw	v0,40(a0)
			}

			if(pseudoHeader.Length > len)
9d0054e8:	0266302b 	sltu	a2,s3,a2
9d0054ec:	54c00001 	bnezl	a2,9d0054f4 <SendTCP+0x3e4>
9d0054f0:	a7b3002a 	sh	s3,42(sp)
				pseudoHeader.Length = len;

			// Copy application data into the raw TX buffer
			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9d0054f4:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d0054f8:	00000000 	nop
9d0054fc:	93848023 	lbu	a0,-32733(gp)
9d005500:	97a3002a 	lhu	v1,42(sp)
9d005504:	8e86000c 	lw	a2,12(s4)
9d005508:	00042900 	sll	a1,a0,0x4
9d00550c:	00042180 	sll	a0,a0,0x6
9d005510:	00852023 	subu	a0,a0,a1
9d005514:	02242021 	addu	a0,s1,a0
9d005518:	9087002c 	lbu	a3,44(a0)
9d00551c:	00002821 	move	a1,zero
9d005520:	24440036 	addiu	a0,v0,54
9d005524:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d005528:	afa30010 	sw	v1,16(sp)
			pseudoHeader.Length = len - pseudoHeader.Length;
9d00552c:	97a2002a 	lhu	v0,42(sp)
9d005530:	02621023 	subu	v0,s3,v0
9d005534:	3042ffff 	andi	v0,v0,0xffff
	
			// Copy any left over chunks of application data over
			if(pseudoHeader.Length)
9d005538:	14400099 	bnez	v0,9d0057a0 <SendTCP+0x690>
9d00553c:	a7a2002a 	sh	v0,42(sp)
			{
				TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
			}

			MyTCB.txUnackedTail += len;
			if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9d005540:	93968023 	lbu	s6,-32733(gp)
			if(pseudoHeader.Length)
			{
				TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
			}

			MyTCB.txUnackedTail += len;
9d005544:	8e84000c 	lw	a0,12(s4)
			if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9d005548:	00161100 	sll	v0,s6,0x4
9d00554c:	00161980 	sll	v1,s6,0x6
9d005550:	00623023 	subu	a2,v1,v0
9d005554:	02263021 	addu	a2,s1,a2
9d005558:	8cc50004 	lw	a1,4(a2)
			if(pseudoHeader.Length)
			{
				TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
			}

			MyTCB.txUnackedTail += len;
9d00555c:	02642021 	addu	a0,s3,a0
			if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9d005560:	0085382b 	sltu	a3,a0,a1
9d005564:	14e00005 	bnez	a3,9d00557c <SendTCP+0x46c>
9d005568:	ae84000c 	sw	a0,12(s4)
				MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart;
9d00556c:	8cc60000 	lw	a2,0(a2)
9d005570:	00c52823 	subu	a1,a2,a1
9d005574:	00a42021 	addu	a0,a1,a0
9d005578:	ae84000c 	sw	a0,12(s4)
		}

		// If we are to transmit a FIN, make sure we can put one in this packet
		if(MyTCBStub.Flags.bTXFIN)
9d00557c:	00621023 	subu	v0,v1,v0
9d005580:	02221021 	addu	v0,s1,v0
9d005584:	8c420028 	lw	v0,40(v0)
9d005588:	7c4202c0 	ext	v0,v0,0xb,0x1
9d00558c:	5440002a 	bnezl	v0,9d005638 <SendTCP+0x528>
9d005590:	96820014 	lhu	v0,20(s4)
	}

	// Ensure that all packets with data of some kind are 
	// retransmitted by TCPTick() until acknowledged
	// Pure ACK packets with no data are not ACKed back in TCP
	if(len || (vTCPFlags & (SYN | FIN)))
9d005594:	1260ff05 	beqz	s3,9d0051ac <SendTCP+0x9c>
9d005598:	32020003 	andi	v0,s0,0x3
	{
		// Transmitting data, update remote window variable to reflect smaller 
		// window.
		MyTCB.remoteWindow -= len;
9d00559c:	96820014 	lhu	v0,20(s4)
		// Push (PSH) all data for enhanced responsiveness on 
		// the remote end, especially with GUIs
		if(len)
			vTCPFlags |= PSH;

		if(vSendFlags & SENDTCP_RESET_TIMERS)
9d0055a0:	32520001 	andi	s2,s2,0x1
		MyTCB.remoteWindow -= len;

		// Push (PSH) all data for enhanced responsiveness on 
		// the remote end, especially with GUIs
		if(len)
			vTCPFlags |= PSH;
9d0055a4:	36100008 	ori	s0,s0,0x8
	// Pure ACK packets with no data are not ACKed back in TCP
	if(len || (vTCPFlags & (SYN | FIN)))
	{
		// Transmitting data, update remote window variable to reflect smaller 
		// window.
		MyTCB.remoteWindow -= len;
9d0055a8:	00531023 	subu	v0,v0,s3
		// Push (PSH) all data for enhanced responsiveness on 
		// the remote end, especially with GUIs
		if(len)
			vTCPFlags |= PSH;

		if(vSendFlags & SENDTCP_RESET_TIMERS)
9d0055ac:	1240ff04 	beqz	s2,9d0051c0 <SendTCP+0xb0>
9d0055b0:	a6820014 	sh	v0,20(s4)
		{
			MyTCB.retryCount = 0;
			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
9d0055b4:	0b40157b 	j	9d0055ec <SendTCP+0x4dc>
9d0055b8:	3c020004 	lui	v0,0x4
	SyncTCB();

	// FINs must be handled specially
	if(vTCPFlags & FIN)
	{
		MyTCBStub.Flags.bTXFIN = 1;
9d0055bc:	3c11a000 	lui	s1,0xa000
9d0055c0:	26314700 	addiu	s1,s1,18176
9d0055c4:	00031100 	sll	v0,v1,0x4
9d0055c8:	00031980 	sll	v1,v1,0x6
9d0055cc:	00622023 	subu	a0,v1,v0
9d0055d0:	02242021 	addu	a0,s1,a0
9d0055d4:	8c850028 	lw	a1,40(a0)
9d0055d8:	24060001 	li	a2,1
		vTCPFlags &= ~FIN;
9d0055dc:	321000fe 	andi	s0,s0,0xfe
	SyncTCB();

	// FINs must be handled specially
	if(vTCPFlags & FIN)
	{
		MyTCBStub.Flags.bTXFIN = 1;
9d0055e0:	7cc55ac4 	ins	a1,a2,0xb,0x1
9d0055e4:	0b401458 	j	9d005160 <SendTCP+0x50>
9d0055e8:	ac850028 	sw	a1,40(a0)
			vTCPFlags |= PSH;

		if(vSendFlags & SENDTCP_RESET_TIMERS)
		{
			MyTCB.retryCount = 0;
			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
9d0055ec:	3442c4b4 	ori	v0,v0,0xc4b4
		if(len)
			vTCPFlags |= PSH;

		if(vSendFlags & SENDTCP_RESET_TIMERS)
		{
			MyTCB.retryCount = 0;
9d0055f0:	a280002a 	sb	zero,42(s4)
			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
9d0055f4:	0b401470 	j	9d0051c0 <SendTCP+0xb0>
9d0055f8:	aea248e0 	sw	v0,18656(s5)
		}	

		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
		MyTCBStub.Flags.bTimerEnabled = 1;
	}
	else if(vSendFlags & SENDTCP_KEEP_ALIVE)
9d0055fc:	32420002 	andi	v0,s2,0x2
9d005600:	14400046 	bnez	v0,9d00571c <SendTCP+0x60c>
9d005604:	00161980 	sll	v1,s6,0x6
		
		// Generate a dummy byte
		MyTCB.MySEQ -= 1;
		len = 1;
	}
	else if(MyTCBStub.Flags.bTimerEnabled) 
9d005608:	00169900 	sll	s3,s6,0x4
9d00560c:	0016b980 	sll	s7,s6,0x6
9d005610:	02f31023 	subu	v0,s7,s3
9d005614:	02221021 	addu	v0,s1,v0
9d005618:	8c420028 	lw	v0,40(v0)
9d00561c:	7c420100 	ext	v0,v0,0x4,0x1
9d005620:	5440004a 	bnezl	v0,9d00574c <SendTCP+0x63c>
9d005624:	32520001 	andi	s2,s2,0x1
9d005628:	8e830004 	lw	v1,4(s4)
9d00562c:	24120014 	li	s2,20
9d005630:	0b401484 	j	9d005210 <SendTCP+0x100>
9d005634:	00009821 	move	s3,zero
		}

		// If we are to transmit a FIN, make sure we can put one in this packet
		if(MyTCBStub.Flags.bTXFIN)
		{
			if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS))
9d005638:	1053ffd6 	beq	v0,s3,9d005594 <SendTCP+0x484>
9d00563c:	36020001 	ori	v0,s0,0x1
9d005640:	96830028 	lhu	v1,40(s4)
				vTCPFlags |= FIN;
9d005644:	00731826 	xor	v1,v1,s3
9d005648:	0b401565 	j	9d005594 <SendTCP+0x484>
9d00564c:	0043800b 	movn	s0,v0,v1
		if(MyTCB.flags.bFINSent)
			header.SeqNumber--;
		else
		{
			MyTCB.MySEQ++;
			MyTCB.flags.bFINSent = 1;
9d005650:	24040001 	li	a0,1
9d005654:	7c828404 	ins	v0,a0,0x10,0x1
	{
		if(MyTCB.flags.bFINSent)
			header.SeqNumber--;
		else
		{
			MyTCB.MySEQ++;
9d005658:	24630001 	addiu	v1,v1,1
9d00565c:	ae830004 	sw	v1,4(s4)
			MyTCB.flags.bFINSent = 1;
9d005660:	0b4014a8 	j	9d0052a0 <SendTCP+0x190>
9d005664:	ae820024 	sw	v0,36(s4)

		if(MyTCB.flags.bSYNSent)
			header.SeqNumber--;
		else
		{
			MyTCB.MySEQ++;
9d005668:	24840001 	addiu	a0,a0,1
			MyTCB.flags.bSYNSent = 1;
9d00566c:	7c628c44 	ins	v0,v1,0x11,0x1

		if(MyTCB.flags.bSYNSent)
			header.SeqNumber--;
		else
		{
			MyTCB.MySEQ++;
9d005670:	ae840004 	sw	a0,4(s4)
			MyTCB.flags.bSYNSent = 1;
9d005674:	0b40149e 	j	9d005278 <SendTCP+0x168>
9d005678:	ae820024 	sw	v0,36(s4)
			// All caught up on data TX, no real data for this packet
			len = 0;
		}
		else if(MyTCBStub.txHead > MyTCB.txUnackedTail)
		{
			len = MyTCBStub.txHead - MyTCB.txUnackedTail;
9d00567c:	00a62823 	subu	a1,a1,a2
9d005680:	30a5ffff 	andi	a1,a1,0xffff

			if(len > MyTCB.remoteWindow)
				len = MyTCB.remoteWindow;

			if(len > MyTCB.wRemoteMSS)
9d005684:	96830028 	lhu	v1,40(s4)
			// All caught up on data TX, no real data for this packet
			len = 0;
		}
		else if(MyTCBStub.txHead > MyTCB.txUnackedTail)
		{
			len = MyTCBStub.txHead - MyTCB.txUnackedTail;
9d005688:	0045982b 	sltu	s3,v0,a1
9d00568c:	0053280b 	movn	a1,v0,s3

			if(len > MyTCB.remoteWindow)
				len = MyTCB.remoteWindow;

			if(len > MyTCB.wRemoteMSS)
9d005690:	0065102b 	sltu	v0,v1,a1
9d005694:	10400006 	beqz	v0,9d0056b0 <SendTCP+0x5a0>
9d005698:	00a09821 	move	s3,a1
			{
				len = MyTCB.wRemoteMSS;
				MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9d00569c:	8c820028 	lw	v0,40(a0)
9d0056a0:	00609821 	move	s3,v1
9d0056a4:	24030001 	li	v1,1
9d0056a8:	7c625284 	ins	v0,v1,0xa,0x1
9d0056ac:	ac820028 	sw	v0,40(a0)
			}

			// Copy application data into the raw TX buffer
			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len);
9d0056b0:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d0056b4:	00000000 	nop
9d0056b8:	93838023 	lbu	v1,-32733(gp)
9d0056bc:	24440036 	addiu	a0,v0,54
9d0056c0:	8e86000c 	lw	a2,12(s4)
9d0056c4:	00031100 	sll	v0,v1,0x4
9d0056c8:	00031980 	sll	v1,v1,0x6
9d0056cc:	00621023 	subu	v0,v1,v0
9d0056d0:	02221021 	addu	v0,s1,v0
9d0056d4:	9047002c 	lbu	a3,44(v0)
9d0056d8:	00002821 	move	a1,zero
9d0056dc:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d0056e0:	afb30010 	sw	s3,16(sp)
			MyTCB.txUnackedTail += len;
9d0056e4:	8e82000c 	lw	v0,12(s4)
9d0056e8:	93968023 	lbu	s6,-32733(gp)
9d0056ec:	02621021 	addu	v0,s3,v0
9d0056f0:	ae82000c 	sw	v0,12(s4)
9d0056f4:	00161980 	sll	v1,s6,0x6
9d0056f8:	00161100 	sll	v0,s6,0x4
			if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
				MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart;
		}

		// If we are to transmit a FIN, make sure we can put one in this packet
		if(MyTCBStub.Flags.bTXFIN)
9d0056fc:	00621023 	subu	v0,v1,v0
9d005700:	02221021 	addu	v0,s1,v0
9d005704:	8c420028 	lw	v0,40(v0)
9d005708:	7c4202c0 	ext	v0,v0,0xb,0x1
9d00570c:	1040ffa1 	beqz	v0,9d005594 <SendTCP+0x484>
9d005710:	00000000 	nop
		{
			if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS))
9d005714:	0b40158e 	j	9d005638 <SendTCP+0x528>
9d005718:	96820014 	lhu	v0,20(s4)
		MyTCBStub.Flags.bTimerEnabled = 1;
	}
	else if(vSendFlags & SENDTCP_KEEP_ALIVE)
	{
		// Increment Keep Alive TX counter to handle disconnection if not response is returned
		MyTCBStub.Flags.vUnackedKeepalives++;
9d00571c:	00161100 	sll	v0,s6,0x4
9d005720:	00621023 	subu	v0,v1,v0
9d005724:	02221021 	addu	v0,s1,v0
9d005728:	8c440028 	lw	a0,40(v0)
		
		// Generate a dummy byte
		MyTCB.MySEQ -= 1;
9d00572c:	8e830004 	lw	v1,4(s4)
9d005730:	24120015 	li	s2,21
		MyTCBStub.Flags.bTimerEnabled = 1;
	}
	else if(vSendFlags & SENDTCP_KEEP_ALIVE)
	{
		// Increment Keep Alive TX counter to handle disconnection if not response is returned
		MyTCBStub.Flags.vUnackedKeepalives++;
9d005734:	24850001 	addiu	a1,a0,1
9d005738:	7ca41004 	ins	a0,a1,0x0,0x3
9d00573c:	ac440028 	sw	a0,40(v0)
		
		// Generate a dummy byte
		MyTCB.MySEQ -= 1;
9d005740:	2463ffff 	addiu	v1,v1,-1
9d005744:	0b401484 	j	9d005210 <SendTCP+0x100>
9d005748:	24130001 	li	s3,1
	{
		// If we have data to transmit, but the remote RX window is zero, 
		// so we aren't transmitting any right now then make sure to not 
		// extend the retry counter or timer.  This will stall our TX 
		// with a periodic ACK sent to the remote node.
		if(!(vSendFlags & SENDTCP_RESET_TIMERS))
9d00574c:	16400009 	bnez	s2,9d005774 <SendTCP+0x664>
9d005750:	00000000 	nop
		{
			// Roll back retry counters since we can't send anything, 
			// but only if we incremented it in the first place
			if(MyTCB.retryCount)
9d005754:	9282002a 	lbu	v0,42(s4)
9d005758:	10400006 	beqz	v0,9d005774 <SendTCP+0x664>
9d00575c:	3c03a000 	lui	v1,0xa000
			{
				MyTCB.retryCount--;
				MyTCB.retryInterval >>= 1;
9d005760:	8c6448e0 	lw	a0,18656(v1)
		{
			// Roll back retry counters since we can't send anything, 
			// but only if we incremented it in the first place
			if(MyTCB.retryCount)
			{
				MyTCB.retryCount--;
9d005764:	2442ffff 	addiu	v0,v0,-1
9d005768:	a282002a 	sb	v0,42(s4)
				MyTCB.retryInterval >>= 1;
9d00576c:	00041042 	srl	v0,a0,0x1
9d005770:	ac6248e0 	sw	v0,18656(v1)
			}
		}
	
		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9d005774:	0f400b53 	jal	9d002d4c <TickGet>
9d005778:	02f39823 	subu	s3,s7,s3
9d00577c:	8ea448e0 	lw	a0,18656(s5)
9d005780:	02339821 	addu	s3,s1,s3
9d005784:	00441021 	addu	v0,v0,a0
9d005788:	ae62001c 	sw	v0,28(s3)
9d00578c:	8e830004 	lw	v1,4(s4)
9d005790:	93968023 	lbu	s6,-32733(gp)
9d005794:	24120014 	li	s2,20
9d005798:	0b401484 	j	9d005210 <SendTCP+0x100>
9d00579c:	00009821 	move	s3,zero
			pseudoHeader.Length = len - pseudoHeader.Length;
	
			// Copy any left over chunks of application data over
			if(pseudoHeader.Length)
			{
				TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9d0057a0:	0f400ce9 	jal	9d0033a4 <MACGetTxBaseAddr>
9d0057a4:	00000000 	nop
9d0057a8:	93858023 	lbu	a1,-32733(gp)
9d0057ac:	8e88000c 	lw	t0,12(s4)
9d0057b0:	97a3002a 	lhu	v1,42(sp)
9d0057b4:	00052100 	sll	a0,a1,0x4
9d0057b8:	00052980 	sll	a1,a1,0x6
9d0057bc:	00a42023 	subu	a0,a1,a0
9d0057c0:	02242021 	addu	a0,s1,a0
9d0057c4:	8c850004 	lw	a1,4(a0)
9d0057c8:	8c860000 	lw	a2,0(a0)
9d0057cc:	9087002c 	lbu	a3,44(a0)
9d0057d0:	24a40036 	addiu	a0,a1,54
9d0057d4:	00882023 	subu	a0,a0,t0
9d0057d8:	00822021 	addu	a0,a0,v0
9d0057dc:	00002821 	move	a1,zero
9d0057e0:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d0057e4:	afa30010 	sw	v1,16(sp)
			}

			MyTCB.txUnackedTail += len;
			if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9d0057e8:	0b401551 	j	9d005544 <SendTCP+0x434>
9d0057ec:	93968023 	lbu	s6,-32733(gp)

9d0057f0 <GetMaxSegSizeOption>:

  Remarks:
	The internal MAC Read Pointer is moved but not restored.
  ***************************************************************************/
static WORD GetMaxSegSizeOption(void)
{
9d0057f0:	27bdffd0 	addiu	sp,sp,-48
	BYTE vOptionsBytes;
	BYTE vOption;
	WORD wMSS;

	// Find out how many options bytes are in this packet.
	IPSetRxBuffer(2+2+4+4);	// Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4)
9d0057f4:	2404000c 	li	a0,12

  Remarks:
	The internal MAC Read Pointer is moved but not restored.
  ***************************************************************************/
static WORD GetMaxSegSizeOption(void)
{
9d0057f8:	afbf002c 	sw	ra,44(sp)
9d0057fc:	afb20024 	sw	s2,36(sp)
9d005800:	afb0001c 	sw	s0,28(sp)
9d005804:	afb30028 	sw	s3,40(sp)
	BYTE vOptionsBytes;
	BYTE vOption;
	WORD wMSS;

	// Find out how many options bytes are in this packet.
	IPSetRxBuffer(2+2+4+4);	// Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4)
9d005808:	0f4024f1 	jal	9d0093c4 <IPSetRxBuffer>
9d00580c:	afb10020 	sw	s1,32(sp)
	vOptionsBytes = MACGet();
9d005810:	0f400e10 	jal	9d003840 <MACGet>
9d005814:	24100218 	li	s0,536
	vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER);
9d005818:	305200f0 	andi	s2,v0,0xf0
9d00581c:	00129082 	srl	s2,s2,0x2
9d005820:	2652ffec 	addiu	s2,s2,-20
9d005824:	325200ff 	andi	s2,s2,0xff

	// Return minimum Maximum Segment Size value of 536 bytes if none are 
	// present
	if(vOptionsBytes == 0u)
9d005828:	16400009 	bnez	s2,9d005850 <GetMaxSegSizeOption+0x60>
9d00582c:	00002021 	move	a0,zero
		
	}
	
	// Did not find MSS option, return worst case default
	return 536;
}
9d005830:	8fbf002c 	lw	ra,44(sp)
9d005834:	02001021 	move	v0,s0
9d005838:	8fb30028 	lw	s3,40(sp)
9d00583c:	8fb20024 	lw	s2,36(sp)
9d005840:	8fb10020 	lw	s1,32(sp)
9d005844:	8fb0001c 	lw	s0,28(sp)
9d005848:	03e00008 	jr	ra
9d00584c:	27bd0030 	addiu	sp,sp,48
	// present
	if(vOptionsBytes == 0u)
		return 536;
		
	// Seek to beginning of options
	MACGetArray(NULL, 7);
9d005850:	0f400e15 	jal	9d003854 <MACGetArray>
9d005854:	24050007 	li	a1,7
		vOption = MACGet();
		
		if(vOption == 0u)	// End of Options list
			break;
		
		if(vOption == 1u)	// NOP option
9d005858:	24100001 	li	s0,1
			continue;
			
		if(vOption == 2u)	// Maximum Segment Size option
9d00585c:	24110002 	li	s1,2
		
	// Seek to beginning of options
	MACGetArray(NULL, 7);

	// Search for the Maximum Segment Size option	
	while(vOptionsBytes--)
9d005860:	12400018 	beqz	s2,9d0058c4 <GetMaxSegSizeOption+0xd4>
9d005864:	8fbf002c 	lw	ra,44(sp)
	{
		vOption = MACGet();
9d005868:	0f400e10 	jal	9d003840 <MACGet>
9d00586c:	2652ffff 	addiu	s2,s2,-1
		
		if(vOption == 0u)	// End of Options list
9d005870:	10400013 	beqz	v0,9d0058c0 <GetMaxSegSizeOption+0xd0>
9d005874:	325200ff 	andi	s2,s2,0xff
			break;
		
		if(vOption == 1u)	// NOP option
9d005878:	1050fff9 	beq	v0,s0,9d005860 <GetMaxSegSizeOption+0x70>
9d00587c:	2e430002 	sltiu	v1,s2,2
			continue;
			
		if(vOption == 2u)	// Maximum Segment Size option
9d005880:	50510018 	beql	v0,s1,9d0058e4 <GetMaxSegSizeOption+0xf4>
9d005884:	2e520003 	sltiu	s2,s2,3
			else 
				return wMSS;
		}
		else
		{ // Assume this is a multi byte option and throw it way
			if(vOptionsBytes < 2u)
9d005888:	1460000e 	bnez	v1,9d0058c4 <GetMaxSegSizeOption+0xd4>
9d00588c:	8fbf002c 	lw	ra,44(sp)
				break;
			vOption = MACGet();
9d005890:	0f400e10 	jal	9d003840 <MACGet>
9d005894:	00000000 	nop
9d005898:	00409821 	move	s3,v0
			if(vOptionsBytes < vOption)
				break;
			MACGetArray(NULL, vOption);
9d00589c:	00402821 	move	a1,v0
		else
		{ // Assume this is a multi byte option and throw it way
			if(vOptionsBytes < 2u)
				break;
			vOption = MACGet();
			if(vOptionsBytes < vOption)
9d0058a0:	0242102b 	sltu	v0,s2,v0
9d0058a4:	14400006 	bnez	v0,9d0058c0 <GetMaxSegSizeOption+0xd0>
9d0058a8:	00002021 	move	a0,zero
				break;
			MACGetArray(NULL, vOption);
			vOptionsBytes -= vOption;
9d0058ac:	02539023 	subu	s2,s2,s3
			if(vOptionsBytes < 2u)
				break;
			vOption = MACGet();
			if(vOptionsBytes < vOption)
				break;
			MACGetArray(NULL, vOption);
9d0058b0:	0f400e15 	jal	9d003854 <MACGetArray>
9d0058b4:	325200ff 	andi	s2,s2,0xff
		
	// Seek to beginning of options
	MACGetArray(NULL, 7);

	// Search for the Maximum Segment Size option	
	while(vOptionsBytes--)
9d0058b8:	1640ffeb 	bnez	s2,9d005868 <GetMaxSegSizeOption+0x78>
9d0058bc:	00000000 	nop
		
	}
	
	// Did not find MSS option, return worst case default
	return 536;
}
9d0058c0:	8fbf002c 	lw	ra,44(sp)
		}
		
	}
	
	// Did not find MSS option, return worst case default
	return 536;
9d0058c4:	24100218 	li	s0,536
}
9d0058c8:	02001021 	move	v0,s0
9d0058cc:	8fb30028 	lw	s3,40(sp)
9d0058d0:	8fb20024 	lw	s2,36(sp)
9d0058d4:	8fb10020 	lw	s1,32(sp)
9d0058d8:	8fb0001c 	lw	s0,28(sp)
9d0058dc:	03e00008 	jr	ra
9d0058e0:	27bd0030 	addiu	sp,sp,48
		if(vOption == 1u)	// NOP option
			continue;
			
		if(vOption == 2u)	// Maximum Segment Size option
		{
			if(vOptionsBytes < 3u)
9d0058e4:	1640ffd2 	bnez	s2,9d005830 <GetMaxSegSizeOption+0x40>
9d0058e8:	24100218 	li	s0,536
				break;

			wMSS = 0;
				
			// Get option length
			vOption = MACGet();
9d0058ec:	0f400e10 	jal	9d003840 <MACGet>
9d0058f0:	a7a00010 	sh	zero,16(sp)
			if(vOption == 4u)
9d0058f4:	24030004 	li	v1,4
9d0058f8:	1443ffce 	bne	v0,v1,9d005834 <GetMaxSegSizeOption+0x44>
9d0058fc:	8fbf002c 	lw	ra,44(sp)
			{// Retrieve MSS and swap value to little endian
				((BYTE*)&wMSS)[1] = MACGet();
9d005900:	0f400e10 	jal	9d003840 <MACGet>
9d005904:	00000000 	nop
				((BYTE*)&wMSS)[0] = MACGet();
9d005908:	0f400e10 	jal	9d003840 <MACGet>
9d00590c:	a3a20011 	sb	v0,17(sp)
9d005910:	a3a20010 	sb	v0,16(sp)
9d005914:	97a20010 	lhu	v0,16(sp)
			}
			
			if(wMSS < 536u)
9d005918:	2c430218 	sltiu	v1,v0,536
9d00591c:	1460ffc4 	bnez	v1,9d005830 <GetMaxSegSizeOption+0x40>
9d005920:	2c4305b5 	sltiu	v1,v0,1461
9d005924:	241005b4 	li	s0,1460
9d005928:	0b40160c 	j	9d005830 <GetMaxSegSizeOption+0x40>
9d00592c:	0043800b 	movn	s0,v0,v1

9d005930 <CloseSocket>:

  Returns:
	None
  ***************************************************************************/
static void CloseSocket(void)
{
9d005930:	27bdffd8 	addiu	sp,sp,-40
9d005934:	afbf0024 	sw	ra,36(sp)
9d005938:	afb30020 	sw	s3,32(sp)
9d00593c:	afb2001c 	sw	s2,28(sp)
9d005940:	afb10018 	sw	s1,24(sp)
	SyncTCB();
9d005944:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d005948:	afb00014 	sw	s0,20(sp)

	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
9d00594c:	93838023 	lbu	v1,-32733(gp)
9d005950:	3c10a000 	lui	s0,0xa000
9d005954:	261048e0 	addiu	s0,s0,18656
9d005958:	96040012 	lhu	a0,18(s0)
9d00595c:	00032900 	sll	a1,v1,0x4
9d005960:	3c02a000 	lui	v0,0xa000
9d005964:	00031980 	sll	v1,v1,0x6
9d005968:	00651823 	subu	v1,v1,a1
9d00596c:	24424700 	addiu	v0,v0,18176
9d005970:	00431021 	addu	v0,v0,v1
9d005974:	a444002a 	sh	a0,42(v0)
	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9d005978:	8c440028 	lw	a0,40(v0)
	MyTCBStub.Flags.vUnackedKeepalives = 0;
	MyTCBStub.Flags.bTimerEnabled = 0;
9d00597c:	2406fff8 	li	a2,-8
	
	#if defined(STACK_USE_SSL_SERVER)
	MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
	#endif

	MyTCB.flags.bFINSent = 0;
9d005980:	8e050024 	lw	a1,36(s0)
	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
	MyTCBStub.Flags.vUnackedKeepalives = 0;
	MyTCBStub.Flags.bTimerEnabled = 0;
9d005984:	00863024 	and	a2,a0,a2
	MyTCBStub.Flags.bTimer2Enabled = 0;
9d005988:	2403ffcf 	li	v1,-49
	MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9d00598c:	00c33024 	and	a2,a2,v1
	MyTCBStub.Flags.bOneSegmentReceived = 0;
9d005990:	2403ff3f 	li	v1,-193
	MyTCBStub.Flags.bHalfFullFlush = 0;
9d005994:	00c33024 	and	a2,a2,v1
	MyTCBStub.Flags.bTXASAP = 0;
	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9d005998:	2408fcff 	li	t0,-769
static void CloseSocket(void)
{
	SyncTCB();

	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9d00599c:	8c430000 	lw	v1,0(v0)
	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
9d0059a0:	8c470004 	lw	a3,4(v0)
	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9d0059a4:	7c8900c0 	ext	t1,a0,0x3,0x1
	MyTCBStub.Flags.bTimer2Enabled = 0;
	MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
	MyTCBStub.Flags.bOneSegmentReceived = 0;
	MyTCBStub.Flags.bHalfFullFlush = 0;
	MyTCBStub.Flags.bTXASAP = 0;
	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9d0059a8:	00c83024 	and	a2,a2,t0
	MyTCBStub.Flags.bTXFIN = 0;
	MyTCBStub.Flags.bSocketReset = 1;
9d0059ac:	2404f3ff 	li	a0,-3073
	
	#if defined(STACK_USE_SSL_SERVER)
	MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
	#endif

	MyTCB.flags.bFINSent = 0;
9d0059b0:	7c058404 	ins	a1,zero,0x10,0x1
	MyTCBStub.Flags.bOneSegmentReceived = 0;
	MyTCBStub.Flags.bHalfFullFlush = 0;
	MyTCBStub.Flags.bTXASAP = 0;
	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
	MyTCBStub.Flags.bTXFIN = 0;
	MyTCBStub.Flags.bSocketReset = 1;
9d0059b4:	24110001 	li	s1,1
	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9d0059b8:	2408000d 	li	t0,13
	MyTCBStub.Flags.bOneSegmentReceived = 0;
	MyTCBStub.Flags.bHalfFullFlush = 0;
	MyTCBStub.Flags.bTXASAP = 0;
	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
	MyTCBStub.Flags.bTXFIN = 0;
	MyTCBStub.Flags.bSocketReset = 1;
9d0059bc:	00c43024 	and	a2,a2,a0
	#if defined(STACK_USE_SSL_SERVER)
	MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
	#endif

	MyTCB.flags.bFINSent = 0;
	MyTCB.flags.bSYNSent = 0;
9d0059c0:	7c058c44 	ins	a1,zero,0x11,0x1
	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9d0059c4:	24040004 	li	a0,4
	MyTCBStub.Flags.bOneSegmentReceived = 0;
	MyTCBStub.Flags.bHalfFullFlush = 0;
	MyTCBStub.Flags.bTXASAP = 0;
	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
	MyTCBStub.Flags.bTXFIN = 0;
	MyTCBStub.Flags.bSocketReset = 1;
9d0059c8:	7e266304 	ins	a2,s1,0xc,0x1
	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9d0059cc:	0109200a 	movz	a0,t0,t1
	MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
	#endif

	MyTCB.flags.bFINSent = 0;
	MyTCB.flags.bSYNSent = 0;
	MyTCB.flags.bRXNoneACKed1 = 0;
9d0059d0:	7c059cc4 	ins	a1,zero,0x13,0x1
	MyTCBStub.Flags.bOneSegmentReceived = 0;
	MyTCBStub.Flags.bHalfFullFlush = 0;
	MyTCBStub.Flags.bTXASAP = 0;
	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
	MyTCBStub.Flags.bTXFIN = 0;
	MyTCBStub.Flags.bSocketReset = 1;
9d0059d4:	ac460028 	sw	a2,40(v0)
	#endif

	MyTCB.flags.bFINSent = 0;
	MyTCB.flags.bSYNSent = 0;
	MyTCB.flags.bRXNoneACKed1 = 0;
	MyTCB.flags.bRXNoneACKed2 = 0;
9d0059d8:	7c05a504 	ins	a1,zero,0x14,0x1
static void CloseSocket(void)
{
	SyncTCB();

	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9d0059dc:	ac43000c 	sw	v1,12(v0)
	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
9d0059e0:	ac430010 	sw	v1,16(v0)
	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
9d0059e4:	ac470014 	sw	a3,20(v0)
	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9d0059e8:	ac470018 	sw	a3,24(v0)
	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9d0059ec:	ac440024 	sw	a0,36(v0)
	MyTCB.flags.bFINSent = 0;
	MyTCB.flags.bSYNSent = 0;
	MyTCB.flags.bRXNoneACKed1 = 0;
	MyTCB.flags.bRXNoneACKed2 = 0;
	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
	((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
9d0059f0:	3c12a000 	lui	s2,0xa000
	#endif

	MyTCB.flags.bFINSent = 0;
	MyTCB.flags.bSYNSent = 0;
	MyTCB.flags.bRXNoneACKed1 = 0;
	MyTCB.flags.bRXNoneACKed2 = 0;
9d0059f4:	ae050024 	sw	a1,36(s0)
	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
	((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
9d0059f8:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d0059fc:	ae03000c 	sw	v1,12(s0)
	((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand();
9d005a00:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d005a04:	a64248e4 	sh	v0,18660(s2)
	MyTCB.sHoleSize = -1;
	MyTCB.remoteWindow = 1;
}
9d005a08:	8fbf0024 	lw	ra,36(sp)
	MyTCB.flags.bFINSent = 0;
	MyTCB.flags.bSYNSent = 0;
	MyTCB.flags.bRXNoneACKed1 = 0;
	MyTCB.flags.bRXNoneACKed2 = 0;
	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
	((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
9d005a0c:	265348e4 	addiu	s3,s2,18660
	((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand();
9d005a10:	a6620002 	sh	v0,2(s3)
	MyTCB.sHoleSize = -1;
9d005a14:	2402ffff 	li	v0,-1
	MyTCB.remoteWindow = 1;
9d005a18:	a6110014 	sh	s1,20(s0)
	MyTCB.flags.bRXNoneACKed1 = 0;
	MyTCB.flags.bRXNoneACKed2 = 0;
	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
	((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
	((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand();
	MyTCB.sHoleSize = -1;
9d005a1c:	a6020024 	sh	v0,36(s0)
	MyTCB.remoteWindow = 1;
}
9d005a20:	8fb30020 	lw	s3,32(sp)
9d005a24:	8fb2001c 	lw	s2,28(sp)
9d005a28:	8fb10018 	lw	s1,24(sp)
9d005a2c:	8fb00014 	lw	s0,20(sp)
9d005a30:	03e00008 	jr	ra
9d005a34:	27bd0028 	addiu	sp,sp,40

9d005a38 <TCPInit>:
		// Initialize NextPort to a random value if it is zero (such as after 
		// reset on a PIC32 or PIC18 when the static memory initializer is 
		// used).  By starting with a random number, we decrease the risk of 
		// reusing a port number that was previously used if the user power 
		// cycles the device.
		if(NextPort == 0u)
9d005a38:	978280fa 	lhu	v0,-32518(gp)
  	
  Remarks:
	This function is called only one during lifetime of the application.
  ***************************************************************************/
void TCPInit(void)
{
9d005a3c:	27bdffc0 	addiu	sp,sp,-64
9d005a40:	afbf003c 	sw	ra,60(sp)
9d005a44:	afbe0038 	sw	s8,56(sp)
9d005a48:	afb70034 	sw	s7,52(sp)
9d005a4c:	afb60030 	sw	s6,48(sp)
9d005a50:	afb5002c 	sw	s5,44(sp)
9d005a54:	afb40028 	sw	s4,40(sp)
9d005a58:	afb30024 	sw	s3,36(sp)
9d005a5c:	afb20020 	sw	s2,32(sp)
9d005a60:	afb1001c 	sw	s1,28(sp)
		// Initialize NextPort to a random value if it is zero (such as after 
		// reset on a PIC32 or PIC18 when the static memory initializer is 
		// used).  By starting with a random number, we decrease the risk of 
		// reusing a port number that was previously used if the user power 
		// cycles the device.
		if(NextPort == 0u)
9d005a64:	14400006 	bnez	v0,9d005a80 <TCPInit+0x48>
9d005a68:	afb00018 	sw	s0,24(sp)
			NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER;
9d005a6c:	0f402519 	jal	9d009464 <GenerateRandomDWORD>
9d005a70:	00000000 	nop
9d005a74:	304207ff 	andi	v0,v0,0x7ff
9d005a78:	24420400 	addiu	v0,v0,1024
9d005a7c:	a78280fa 	sh	v0,-32518(gp)
	#endif


	// Mark all SYN Queue entries as invalid by zeroing the memory
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
9d005a80:	3c04a000 	lui	a0,0xa000
9d005a84:	2484490c 	addiu	a0,a0,18700
9d005a88:	00002821 	move	a1,zero
9d005a8c:	0f402fd9 	jal	9d00bf64 <memset>
9d005a90:	2406003c 	li	a2,60
9d005a94:	3c02a000 	lui	v0,0xa000
9d005a98:	24424700 	addiu	v0,v0,18176
9d005a9c:	3c169d01 	lui	s6,0x9d01
	BYTE vMedium;
	#if TCP_ETH_RAM_SIZE > 0
	WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS;
	#endif
	#if TCP_PIC_RAM_SIZE > 0
	PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS;
9d005aa0:	3c1ea000 	lui	s8,0xa000
9d005aa4:	3c13a001 	lui	s3,0xa001
9d005aa8:	3c12a000 	lui	s2,0xa000
	#endif


	// Mark all SYN Queue entries as invalid by zeroing the memory
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
9d005aac:	26d6dcc5 	addiu	s6,s6,-9019
9d005ab0:	0040a021 	move	s4,v0
	BYTE vMedium;
	#if TCP_ETH_RAM_SIZE > 0
	WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS;
	#endif
	#if TCP_PIC_RAM_SIZE > 0
	PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS;
9d005ab4:	27de4948 	addiu	s8,s8,18760
	#endif


	// Mark all SYN Queue entries as invalid by zeroing the memory
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
9d005ab8:	0000a821 	move	s5,zero
9d005abc:	26739948 	addiu	s3,s3,-26296
9d005ac0:	265248e0 	addiu	s2,s2,18656
	
		vMedium = TCPSocketInitializer[i].vMemoryMedium;
		wTXSize = TCPSocketInitializer[i].wTXBufferSize;
		wRXSize = TCPSocketInitializer[i].wRXBufferSize;
	
		switch(vMedium)
9d005ac4:	24170001 	li	s7,1
	
		MyTCBStub.vMemoryMedium = vMedium;
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
		MyTCBStub.smState		= TCP_CLOSED;
9d005ac8:	2411000d 	li	s1,13
		memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
	#endif
	
	// Allocate all socket FIFO addresses
	vSocketsAllocated = 0;
	for(i = 0; i < TCP_SOCKET_COUNT; i++)
9d005acc:	2410000a 	li	s0,10
	
		vMedium = TCPSocketInitializer[i].vMemoryMedium;
		wTXSize = TCPSocketInitializer[i].wTXBufferSize;
		wRXSize = TCPSocketInitializer[i].wRXBufferSize;
	
		switch(vMedium)
9d005ad0:	92c30000 	lbu	v1,0(s6)
	{
		// Generate all needed sockets of each type (TCP_PURPOSE_*)
		SyncTCBStub(i);
	
		vMedium = TCPSocketInitializer[i].vMemoryMedium;
		wTXSize = TCPSocketInitializer[i].wTXBufferSize;
9d005ad4:	96c70001 	lhu	a3,1(s6)
		wRXSize = TCPSocketInitializer[i].wRXBufferSize;
9d005ad8:	96c60003 	lhu	a2,3(s6)
	
		switch(vMedium)
9d005adc:	10770003 	beq	v1,s7,9d005aec <TCPInit+0xb4>
9d005ae0:	a3958023 	sb	s5,-32733(gp)
9d005ae4:	0b4016b9 	j	9d005ae4 <TCPInit+0xac>
9d005ae8:	00000000 	nop
			default:
				while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations.
		}
	
		MyTCBStub.vMemoryMedium = vMedium;
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
9d005aec:	27c5002c 	addiu	a1,s8,44
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
9d005af0:	24e40001 	addiu	a0,a3,1
9d005af4:	00852021 	addu	a0,a0,a1
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
9d005af8:	00864021 	addu	t0,a0,a2
			#endif
				
			#if TCP_PIC_RAM_SIZE > 0
			case TCP_PIC_RAM:
				ptrBaseAddress = ptrCurrentPICAddress;
				ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
9d005afc:	00e63021 	addu	a2,a3,a2
9d005b00:	24c6002e 	addiu	a2,a2,46
		MyTCBStub.vMemoryMedium = vMedium;
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
		MyTCBStub.smState		= TCP_CLOSED;
		MyTCBStub.Flags.bServer	= FALSE;
9d005b04:	00151900 	sll	v1,s5,0x4
9d005b08:	00154980 	sll	t1,s5,0x6
			#endif
				
			#if TCP_PIC_RAM_SIZE > 0
			case TCP_PIC_RAM:
				ptrBaseAddress = ptrCurrentPICAddress;
				ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
9d005b0c:	00def021 	addu	s8,a2,s8
		MyTCBStub.vMemoryMedium = vMedium;
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
		MyTCBStub.smState		= TCP_CLOSED;
		MyTCBStub.Flags.bServer	= FALSE;
9d005b10:	01231823 	subu	v1,t1,v1
			case TCP_PIC_RAM:
				ptrBaseAddress = ptrCurrentPICAddress;
				ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
				while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE);
9d005b14:	027e302b 	sltu	a2,s3,s8
		MyTCBStub.vMemoryMedium = vMedium;
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
		MyTCBStub.smState		= TCP_CLOSED;
		MyTCBStub.Flags.bServer	= FALSE;
9d005b18:	00431821 	addu	v1,v0,v1
			case TCP_PIC_RAM:
				ptrBaseAddress = ptrCurrentPICAddress;
				ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
				while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE);
9d005b1c:	14c0001e 	bnez	a2,9d005b98 <TCPInit+0x160>
9d005b20:	26b50001 	addiu	s5,s5,1
			default:
				while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations.
		}
	
		MyTCBStub.vMemoryMedium = vMedium;
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
9d005b24:	ae850000 	sw	a1,0(s4)
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
9d005b28:	ae880008 	sw	t0,8(s4)
			
			default:
				while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations.
		}
	
		MyTCBStub.vMemoryMedium = vMedium;
9d005b2c:	a297002c 	sb	s7,44(s4)
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
9d005b30:	ae840004 	sw	a0,4(s4)
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
		MyTCBStub.smState		= TCP_CLOSED;
9d005b34:	ae910024 	sw	s1,36(s4)
		MyTCBStub.Flags.bServer	= FALSE;
9d005b38:	8c640028 	lw	a0,40(v1)
		MyTCBStub.sslStubID = SSL_INVALID_ID;
		#endif		

		SyncTCB();
		MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose;
		CloseSocket();
9d005b3c:	26940030 	addiu	s4,s4,48
		MyTCBStub.vMemoryMedium = vMedium;
		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
		MyTCBStub.smState		= TCP_CLOSED;
		MyTCBStub.Flags.bServer	= FALSE;
9d005b40:	7c0418c4 	ins	a0,zero,0x3,0x1
9d005b44:	ac640028 	sw	a0,40(v1)
		#if defined(STACK_USE_SSL)
		MyTCBStub.sslStubID = SSL_INVALID_ID;
		#endif		

		SyncTCB();
9d005b48:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d005b4c:	afa20010 	sw	v0,16(sp)
		MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose;
9d005b50:	92c3ffff 	lbu	v1,-1(s6)
		CloseSocket();
9d005b54:	26d60006 	addiu	s6,s6,6
9d005b58:	0f40164c 	jal	9d005930 <CloseSocket>
9d005b5c:	a243002b 	sb	v1,43(s2)
		memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
	#endif
	
	// Allocate all socket FIFO addresses
	vSocketsAllocated = 0;
	for(i = 0; i < TCP_SOCKET_COUNT; i++)
9d005b60:	16b0ffdb 	bne	s5,s0,9d005ad0 <TCPInit+0x98>
9d005b64:	8fa20010 	lw	v0,16(sp)

		SyncTCB();
		MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose;
		CloseSocket();
	}
}
9d005b68:	8fbf003c 	lw	ra,60(sp)
9d005b6c:	8fbe0038 	lw	s8,56(sp)
9d005b70:	8fb70034 	lw	s7,52(sp)
9d005b74:	8fb60030 	lw	s6,48(sp)
9d005b78:	8fb5002c 	lw	s5,44(sp)
9d005b7c:	8fb40028 	lw	s4,40(sp)
9d005b80:	8fb30024 	lw	s3,36(sp)
9d005b84:	8fb20020 	lw	s2,32(sp)
9d005b88:	8fb1001c 	lw	s1,28(sp)
9d005b8c:	8fb00018 	lw	s0,24(sp)
9d005b90:	03e00008 	jr	ra
9d005b94:	27bd0040 	addiu	sp,sp,64
9d005b98:	0b4016e6 	j	9d005b98 <TCPInit+0x160>
9d005b9c:	00000000 	nop

9d005ba0 <TCPOpen>:
    skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO,
                    cache.remotePort.Val, TCP_PURPOSE_DEFAULT);
    </code>                                                    
  *****************************************************************************/
TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
{
9d005ba0:	27bdffc8 	addiu	sp,sp,-56
9d005ba4:	afb7002c 	sw	s7,44(sp)
9d005ba8:	afb40020 	sw	s4,32(sp)
			continue;

		SyncTCB();

		// See if this socket matches the desired type
		if(MyTCB.vSocketPurpose != vSocketPurpose)
9d005bac:	3c17a000 	lui	s7,0xa000
		
		return hTCP;		
	}

	// If there is no socket available, return error.
	return INVALID_SOCKET;
9d005bb0:	3c14a000 	lui	s4,0xa000
    skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO,
                    cache.remotePort.Val, TCP_PURPOSE_DEFAULT);
    </code>                                                    
  *****************************************************************************/
TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
{
9d005bb4:	afbe0030 	sw	s8,48(sp)
9d005bb8:	afb60028 	sw	s6,40(sp)
9d005bbc:	afb50024 	sw	s5,36(sp)
9d005bc0:	afb20018 	sw	s2,24(sp)
9d005bc4:	afb10014 	sw	s1,20(sp)
9d005bc8:	afb00010 	sw	s0,16(sp)
9d005bcc:	afbf0034 	sw	ra,52(sp)
9d005bd0:	afb3001c 	sw	s3,28(sp)
9d005bd4:	afa40038 	sw	a0,56(sp)
9d005bd8:	30b100ff 	andi	s1,a1,0xff
9d005bdc:	30d0ffff 	andi	s0,a2,0xffff
9d005be0:	30fe00ff 	andi	s8,a3,0xff
		
		return hTCP;		
	}

	// If there is no socket available, return error.
	return INVALID_SOCKET;
9d005be4:	26944724 	addiu	s4,s4,18212
TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
{
	TCP_SOCKET hTCP;

	// Find an available socket that matches the specified socket type
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9d005be8:	00009021 	move	s2,zero
	{
		SyncTCBStub(hTCP);

		// Sockets that are in use will be in a non-closed state
		if(MyTCBStub.smState != TCP_CLOSED)
9d005bec:	2415000d 	li	s5,13
			continue;

		SyncTCB();

		// See if this socket matches the desired type
		if(MyTCB.vSocketPurpose != vSocketPurpose)
9d005bf0:	26f748e0 	addiu	s7,s7,18656
TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
{
	TCP_SOCKET hTCP;

	// Find an available socket that matches the specified socket type
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9d005bf4:	2416000a 	li	s6,10
	{
		SyncTCBStub(hTCP);

		// Sockets that are in use will be in a non-closed state
		if(MyTCBStub.smState != TCP_CLOSED)
9d005bf8:	8e820000 	lw	v0,0(s4)
	TCP_SOCKET hTCP;

	// Find an available socket that matches the specified socket type
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
	{
		SyncTCBStub(hTCP);
9d005bfc:	a3928023 	sb	s2,-32733(gp)

		// Sockets that are in use will be in a non-closed state
		if(MyTCBStub.smState != TCP_CLOSED)
9d005c00:	10550013 	beq	v0,s5,9d005c50 <TCPOpen+0xb0>
9d005c04:	26940030 	addiu	s4,s4,48
TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
{
	TCP_SOCKET hTCP;

	// Find an available socket that matches the specified socket type
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9d005c08:	26520001 	addiu	s2,s2,1
9d005c0c:	325200ff 	andi	s2,s2,0xff
9d005c10:	5656fffa 	bnel	s2,s6,9d005bfc <TCPOpen+0x5c>
9d005c14:	8e820000 	lw	v0,0(s4)
		
		return hTCP;		
	}

	// If there is no socket available, return error.
	return INVALID_SOCKET;
9d005c18:	241200fe 	li	s2,254
}
9d005c1c:	8fbf0034 	lw	ra,52(sp)
9d005c20:	02401021 	move	v0,s2
9d005c24:	8fbe0030 	lw	s8,48(sp)
9d005c28:	8fb7002c 	lw	s7,44(sp)
9d005c2c:	8fb60028 	lw	s6,40(sp)
9d005c30:	8fb50024 	lw	s5,36(sp)
9d005c34:	8fb40020 	lw	s4,32(sp)
9d005c38:	8fb3001c 	lw	s3,28(sp)
9d005c3c:	8fb20018 	lw	s2,24(sp)
9d005c40:	8fb10014 	lw	s1,20(sp)
9d005c44:	8fb00010 	lw	s0,16(sp)
9d005c48:	03e00008 	jr	ra
9d005c4c:	27bd0038 	addiu	sp,sp,56

		// Sockets that are in use will be in a non-closed state
		if(MyTCBStub.smState != TCP_CLOSED)
			continue;

		SyncTCB();
9d005c50:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d005c54:	02e09821 	move	s3,s7

		// See if this socket matches the desired type
		if(MyTCB.vSocketPurpose != vSocketPurpose)
9d005c58:	92e2002b 	lbu	v0,43(s7)
9d005c5c:	545effeb 	bnel	v0,s8,9d005c0c <TCPOpen+0x6c>
9d005c60:	26520001 	addiu	s2,s2,1
			continue;

		// Start out assuming worst case Maximum Segment Size (changes when MSS 
		// option is received from remote node)
		MyTCB.wRemoteMSS = 536;
9d005c64:	24020218 	li	v0,536

		// See if this is a server socket
		if(vRemoteHostType == TCP_OPEN_SERVER)
9d005c68:	12200030 	beqz	s1,9d005d2c <TCPOpen+0x18c>
9d005c6c:	a6e20028 	sh	v0,40(s7)
		{
			#if defined(STACK_CLIENT_MODE)
			{
				// Each new socket that is opened by this node, gets the 
				// next sequential local port number.
				if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER)
9d005c70:	978280fa 	lhu	v0,-32518(gp)
9d005c74:	2443fc00 	addiu	v1,v0,-1024
9d005c78:	3063ffff 	andi	v1,v1,0xffff
9d005c7c:	2c630f89 	sltiu	v1,v1,3977
9d005c80:	10600028 	beqz	v1,9d005d24 <TCPOpen+0x184>
9d005c84:	24030401 	li	v1,1025
9d005c88:	24430001 	addiu	v1,v0,1
9d005c8c:	3063ffff 	andi	v1,v1,0xffff
				// Set the non-zero TCB fields
				MyTCB.localPort.Val = NextPort++;
				MyTCB.remotePort.Val = wPort;
	
				// Flag to start the DNS, ARP, SYN processes
				MyTCBStub.eventTime = TickGet();
9d005c90:	93948023 	lbu	s4,-32733(gp)
				// next sequential local port number.
				if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER)
					NextPort = LOCAL_PORT_START_NUMBER;
				
				// Set the non-zero TCB fields
				MyTCB.localPort.Val = NextPort++;
9d005c94:	a6620012 	sh	v0,18(s3)
				MyTCB.remotePort.Val = wPort;
9d005c98:	a6700010 	sh	s0,16(s3)
	
				// Flag to start the DNS, ARP, SYN processes
				MyTCBStub.eventTime = TickGet();
9d005c9c:	0f400b53 	jal	9d002d4c <TickGet>
9d005ca0:	a78380fa 	sh	v1,-32518(gp)
				MyTCBStub.Flags.bTimerEnabled = 1;
9d005ca4:	93848023 	lbu	a0,-32733(gp)
				// Set the non-zero TCB fields
				MyTCB.localPort.Val = NextPort++;
				MyTCB.remotePort.Val = wPort;
	
				// Flag to start the DNS, ARP, SYN processes
				MyTCBStub.eventTime = TickGet();
9d005ca8:	00142900 	sll	a1,s4,0x4
9d005cac:	3c03a000 	lui	v1,0xa000
9d005cb0:	0014a180 	sll	s4,s4,0x6
9d005cb4:	24634700 	addiu	v1,v1,18176
				MyTCBStub.Flags.bTimerEnabled = 1;
9d005cb8:	00043100 	sll	a2,a0,0x4
				// Set the non-zero TCB fields
				MyTCB.localPort.Val = NextPort++;
				MyTCB.remotePort.Val = wPort;
	
				// Flag to start the DNS, ARP, SYN processes
				MyTCBStub.eventTime = TickGet();
9d005cbc:	02852823 	subu	a1,s4,a1
				MyTCBStub.Flags.bTimerEnabled = 1;
9d005cc0:	00042180 	sll	a0,a0,0x6
				// Set the non-zero TCB fields
				MyTCB.localPort.Val = NextPort++;
				MyTCB.remotePort.Val = wPort;
	
				// Flag to start the DNS, ARP, SYN processes
				MyTCBStub.eventTime = TickGet();
9d005cc4:	00652821 	addu	a1,v1,a1
				MyTCBStub.Flags.bTimerEnabled = 1;
9d005cc8:	00862023 	subu	a0,a0,a2
				// Set the non-zero TCB fields
				MyTCB.localPort.Val = NextPort++;
				MyTCB.remotePort.Val = wPort;
	
				// Flag to start the DNS, ARP, SYN processes
				MyTCBStub.eventTime = TickGet();
9d005ccc:	aca2001c 	sw	v0,28(a1)
				MyTCBStub.Flags.bTimerEnabled = 1;
9d005cd0:	00831021 	addu	v0,a0,v1
9d005cd4:	8c430028 	lw	v1,40(v0)
9d005cd8:	24040001 	li	a0,1
9d005cdc:	7c832104 	ins	v1,a0,0x4,0x1
9d005ce0:	ac430028 	sw	v1,40(v0)
	
				switch(vRemoteHostType)
9d005ce4:	24030003 	li	v1,3
9d005ce8:	12230043 	beq	s1,v1,9d005df8 <TCPOpen+0x258>
9d005cec:	2e230004 	sltiu	v1,s1,4
9d005cf0:	1060001e 	beqz	v1,9d005d6c <TCPOpen+0x1cc>
9d005cf4:	24030004 	li	v1,4
9d005cf8:	1220ffc9 	beqz	s1,9d005c20 <TCPOpen+0x80>
9d005cfc:	8fbf0034 	lw	ra,52(sp)
				{
					#if defined(STACK_USE_DNS)
					case TCP_OPEN_RAM_HOST:
					case TCP_OPEN_ROM_HOST:
						MyTCB.remote.dwRemoteHost = dwRemoteHost;
						MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST);
9d005d00:	8e630024 	lw	v1,36(s3)
				switch(vRemoteHostType)
				{
					#if defined(STACK_USE_DNS)
					case TCP_OPEN_RAM_HOST:
					case TCP_OPEN_ROM_HOST:
						MyTCB.remote.dwRemoteHost = dwRemoteHost;
9d005d04:	8fa40038 	lw	a0,56(sp)
						MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST);
9d005d08:	3a310002 	xori	s1,s1,0x2
9d005d0c:	2e310001 	sltiu	s1,s1,1
9d005d10:	7e239484 	ins	v1,s1,0x12,0x1
9d005d14:	ae630024 	sw	v1,36(s3)
				switch(vRemoteHostType)
				{
					#if defined(STACK_USE_DNS)
					case TCP_OPEN_RAM_HOST:
					case TCP_OPEN_ROM_HOST:
						MyTCB.remote.dwRemoteHost = dwRemoteHost;
9d005d18:	ae640018 	sw	a0,24(s3)
						MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST);
						MyTCBStub.smState = TCP_GET_DNS_MODULE;
						break;
9d005d1c:	0b401707 	j	9d005c1c <TCPOpen+0x7c>
9d005d20:	ac400024 	sw	zero,36(v0)
		{
			#if defined(STACK_CLIENT_MODE)
			{
				// Each new socket that is opened by this node, gets the 
				// next sequential local port number.
				if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER)
9d005d24:	0b401724 	j	9d005c90 <TCPOpen+0xf0>
9d005d28:	24020400 	li	v0,1024

		// See if this is a server socket
		if(vRemoteHostType == TCP_OPEN_SERVER)
		{
			MyTCB.localPort.Val = wPort;
			MyTCBStub.Flags.bServer = TRUE;
9d005d2c:	93838023 	lbu	v1,-32733(gp)
9d005d30:	24040001 	li	a0,1
9d005d34:	00031100 	sll	v0,v1,0x4
9d005d38:	00031980 	sll	v1,v1,0x6
9d005d3c:	00621823 	subu	v1,v1,v0
9d005d40:	3c02a000 	lui	v0,0xa000
9d005d44:	24424700 	addiu	v0,v0,18176
9d005d48:	00621021 	addu	v0,v1,v0
9d005d4c:	8c430028 	lw	v1,40(v0)
9d005d50:	7c8318c4 	ins	v1,a0,0x3,0x1
9d005d54:	ac430028 	sw	v1,40(v0)
			MyTCBStub.smState = TCP_LISTEN;
9d005d58:	24030004 	li	v1,4
		MyTCB.wRemoteMSS = 536;

		// See if this is a server socket
		if(vRemoteHostType == TCP_OPEN_SERVER)
		{
			MyTCB.localPort.Val = wPort;
9d005d5c:	a6f00012 	sh	s0,18(s7)
			MyTCBStub.Flags.bServer = TRUE;
			MyTCBStub.smState = TCP_LISTEN;
9d005d60:	ac430024 	sw	v1,36(v0)
			MyTCBStub.remoteHash.Val = wPort;
9d005d64:	0b401707 	j	9d005c1c <TCPOpen+0x7c>
9d005d68:	a450002a 	sh	s0,42(v0)
	
				// Flag to start the DNS, ARP, SYN processes
				MyTCBStub.eventTime = TickGet();
				MyTCBStub.Flags.bTimerEnabled = 1;
	
				switch(vRemoteHostType)
9d005d6c:	5623ffac 	bnel	s1,v1,9d005c20 <TCPOpen+0x80>
9d005d70:	8fbf0034 	lw	ra,52(sp)
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
						break;
		
					case TCP_OPEN_NODE_INFO:
						MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val;
9d005d74:	8fa30038 	lw	v1,56(sp)
9d005d78:	96640012 	lhu	a0,18(s3)
						memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO));
9d005d7c:	3c07a000 	lui	a3,0xa000
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
						break;
		
					case TCP_OPEN_NODE_INFO:
						MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val;
9d005d80:	90660001 	lbu	a2,1(v1)
9d005d84:	90650003 	lbu	a1,3(v1)
9d005d88:	90690000 	lbu	t1,0(v1)
9d005d8c:	90680002 	lbu	t0,2(v1)
9d005d90:	00063200 	sll	a2,a2,0x8
9d005d94:	00052a00 	sll	a1,a1,0x8
9d005d98:	00c93025 	or	a2,a2,t1
9d005d9c:	00a82825 	or	a1,a1,t0
9d005da0:	00c52821 	addu	a1,a2,a1
9d005da4:	02058021 	addu	s0,s0,a1
9d005da8:	02048026 	xor	s0,s0,a0
9d005dac:	a450002a 	sh	s0,42(v0)
						memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO));
9d005db0:	88650003 	lwl	a1,3(v1)
9d005db4:	88640007 	lwl	a0,7(v1)
9d005db8:	24e648f8 	addiu	a2,a3,18680
9d005dbc:	98650000 	lwr	a1,0(v1)
9d005dc0:	98640004 	lwr	a0,4(v1)
9d005dc4:	ace548f8 	sw	a1,18680(a3)
9d005dc8:	acc40004 	sw	a0,4(a2)
9d005dcc:	90670008 	lbu	a3,8(v1)
						MyTCBStub.smState = TCP_SYN_SENT;
						SendTCP(SYN, SENDTCP_RESET_TIMERS);
9d005dd0:	24040002 	li	a0,2
9d005dd4:	24050001 	li	a1,1
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
						break;
		
					case TCP_OPEN_NODE_INFO:
						MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val;
						memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO));
9d005dd8:	a0c70008 	sb	a3,8(a2)
9d005ddc:	90630009 	lbu	v1,9(v1)
						MyTCBStub.smState = TCP_SYN_SENT;
9d005de0:	24070005 	li	a3,5
9d005de4:	ac470024 	sw	a3,36(v0)
						SendTCP(SYN, SENDTCP_RESET_TIMERS);
9d005de8:	0f401444 	jal	9d005110 <SendTCP>
9d005dec:	a0c30009 	sb	v1,9(a2)
						break;
9d005df0:	0b401708 	j	9d005c20 <TCPOpen+0x80>
9d005df4:	8fbf0034 	lw	ra,52(sp)
		
					case TCP_OPEN_IP_ADDRESS:
						// dwRemoteHost is a literal IP address.  This 
						// doesn't need DNS and can skip directly to the 
						// Gateway ARPing step.
						MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val;
9d005df8:	97a4003a 	lhu	a0,58(sp)
9d005dfc:	97a50038 	lhu	a1,56(sp)
9d005e00:	96630012 	lhu	v1,18(s3)
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost;
						MyTCB.retryCount = 0;
9d005e04:	a260002a 	sb	zero,42(s3)
		
					case TCP_OPEN_IP_ADDRESS:
						// dwRemoteHost is a literal IP address.  This 
						// doesn't need DNS and can skip directly to the 
						// Gateway ARPing step.
						MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val;
9d005e08:	00a42021 	addu	a0,a1,a0
9d005e0c:	02048021 	addu	s0,s0,a0
9d005e10:	02038026 	xor	s0,s0,v1
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost;
9d005e14:	8fa30038 	lw	v1,56(sp)
						MyTCB.retryCount = 0;
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
9d005e18:	24040131 	li	a0,305
		
					case TCP_OPEN_IP_ADDRESS:
						// dwRemoteHost is a literal IP address.  This 
						// doesn't need DNS and can skip directly to the 
						// Gateway ARPing step.
						MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val;
9d005e1c:	a450002a 	sh	s0,42(v0)
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost;
9d005e20:	ae630018 	sw	v1,24(s3)
						MyTCB.retryCount = 0;
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
9d005e24:	3c03a000 	lui	v1,0xa000
9d005e28:	ac6448e0 	sw	a0,18656(v1)
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d005e2c:	24030002 	li	v1,2
						break;
9d005e30:	0b401707 	j	9d005c1c <TCPOpen+0x7c>
9d005e34:	ac430024 	sw	v1,36(v0)

9d005e38 <TCPIsConnected>:
  Remarks:
	A socket is said to be connected only if it is in the TCP_ESTABLISHED
	state.  Sockets in the process of opening or closing will return FALSE.
  ***************************************************************************/
BOOL TCPIsConnected(TCP_SOCKET hTCP)
{
9d005e38:	308400ff 	andi	a0,a0,0xff
	SyncTCBStub(hTCP);
	return (MyTCBStub.smState == TCP_ESTABLISHED);
9d005e3c:	00041100 	sll	v0,a0,0x4
9d005e40:	00041980 	sll	v1,a0,0x6
9d005e44:	00621823 	subu	v1,v1,v0
9d005e48:	3c02a000 	lui	v0,0xa000
9d005e4c:	24424700 	addiu	v0,v0,18176
9d005e50:	00431021 	addu	v0,v0,v1
9d005e54:	8c420024 	lw	v0,36(v0)
	A socket is said to be connected only if it is in the TCP_ESTABLISHED
	state.  Sockets in the process of opening or closing will return FALSE.
  ***************************************************************************/
BOOL TCPIsConnected(TCP_SOCKET hTCP)
{
	SyncTCBStub(hTCP);
9d005e58:	a3848023 	sb	a0,-32733(gp)
	return (MyTCBStub.smState == TCP_ESTABLISHED);
9d005e5c:	38420007 	xori	v0,v0,0x7
}
9d005e60:	03e00008 	jr	ra
9d005e64:	2c420001 	sltiu	v0,v0,1

9d005e68 <TCPDisconnect>:
  Remarks:
	If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted
	first to allow the SSL session to be resumed at a later time.
  ***************************************************************************/
void TCPDisconnect(TCP_SOCKET hTCP)
{
9d005e68:	308400ff 	andi	a0,a0,0xff
9d005e6c:	27bdffe0 	addiu	sp,sp,-32
9d005e70:	afb00014 	sw	s0,20(sp)
	// immediately invalid after calling this function, so there 
	// is no longer any way to receive data from the TCP RX FIFO, 
	// even though the data is still there.  Leaving the data there 
	// could interfere with the remote node sending us a FIN if our
	// RX window is zero
	MyTCBStub.rxTail = MyTCBStub.rxHead;
9d005e74:	00042900 	sll	a1,a0,0x4
9d005e78:	00043180 	sll	a2,a0,0x6
9d005e7c:	3c10a000 	lui	s0,0xa000
9d005e80:	00c51023 	subu	v0,a2,a1
9d005e84:	26104700 	addiu	s0,s0,18176
9d005e88:	02021021 	addu	v0,s0,v0

	switch(MyTCBStub.smState)
9d005e8c:	8c430024 	lw	v1,36(v0)
	// immediately invalid after calling this function, so there 
	// is no longer any way to receive data from the TCP RX FIFO, 
	// even though the data is still there.  Leaving the data there 
	// could interfere with the remote node sending us a FIN if our
	// RX window is zero
	MyTCBStub.rxTail = MyTCBStub.rxHead;
9d005e90:	8c470014 	lw	a3,20(v0)
	If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted
	first to allow the SSL session to be resumed at a later time.
  ***************************************************************************/
void TCPDisconnect(TCP_SOCKET hTCP)
{
	SyncTCBStub(hTCP);
9d005e94:	a3848023 	sb	a0,-32733(gp)
	// even though the data is still there.  Leaving the data there 
	// could interfere with the remote node sending us a FIN if our
	// RX window is zero
	MyTCBStub.rxTail = MyTCBStub.rxHead;

	switch(MyTCBStub.smState)
9d005e98:	2c64000f 	sltiu	a0,v1,15
  Remarks:
	If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted
	first to allow the SSL session to be resumed at a later time.
  ***************************************************************************/
void TCPDisconnect(TCP_SOCKET hTCP)
{
9d005e9c:	afbf001c 	sw	ra,28(sp)
9d005ea0:	afb10018 	sw	s1,24(sp)
	// even though the data is still there.  Leaving the data there 
	// could interfere with the remote node sending us a FIN if our
	// RX window is zero
	MyTCBStub.rxTail = MyTCBStub.rxHead;

	switch(MyTCBStub.smState)
9d005ea4:	14800009 	bnez	a0,9d005ecc <TCPDisconnect+0x64>
9d005ea8:	ac470018 	sw	a3,24(v0)
		// regardless of what the other node's state is in (half open).
		case TCP_FIN_WAIT_1:
		case TCP_FIN_WAIT_2:
		case TCP_LAST_ACK:
		default:
			SendTCP(RST | ACK, 0);
9d005eac:	24040014 	li	a0,20
9d005eb0:	0f401444 	jal	9d005110 <SendTCP>
9d005eb4:	00002821 	move	a1,zero
			CloseSocket();
			break;
	}
}
9d005eb8:	8fbf001c 	lw	ra,28(sp)
9d005ebc:	8fb10018 	lw	s1,24(sp)
9d005ec0:	8fb00014 	lw	s0,20(sp)
		case TCP_FIN_WAIT_1:
		case TCP_FIN_WAIT_2:
		case TCP_LAST_ACK:
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
9d005ec4:	0b40164c 	j	9d005930 <CloseSocket>
9d005ec8:	27bd0020 	addiu	sp,sp,32
	// even though the data is still there.  Leaving the data there 
	// could interfere with the remote node sending us a FIN if our
	// RX window is zero
	MyTCBStub.rxTail = MyTCBStub.rxHead;

	switch(MyTCBStub.smState)
9d005ecc:	3c029d01 	lui	v0,0x9d01
9d005ed0:	2442dc54 	addiu	v0,v0,-9132
9d005ed4:	00031880 	sll	v1,v1,0x2
9d005ed8:	00431821 	addu	v1,v0,v1
9d005edc:	8c620000 	lw	v0,0(v1)
9d005ee0:	00400008 	jr	v0
9d005ee4:	00000000 	nop
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
			break;
	}
}
9d005ee8:	8fbf001c 	lw	ra,28(sp)
		//case TCP_CLOSING:
		//case TCP_TIME_WAIT:
		//	return;

		case TCP_CLOSED_BUT_RESERVED:
			MyTCBStub.smState = TCP_CLOSED;
9d005eec:	00c52823 	subu	a1,a2,a1
9d005ef0:	02058021 	addu	s0,s0,a1
9d005ef4:	2402000d 	li	v0,13
9d005ef8:	ae020024 	sw	v0,36(s0)
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
			break;
	}
}
9d005efc:	8fb10018 	lw	s1,24(sp)
9d005f00:	8fb00014 	lw	s0,20(sp)
9d005f04:	03e00008 	jr	ra
9d005f08:	27bd0020 	addiu	sp,sp,32

	switch(MyTCBStub.smState)
	{
		#if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS)
		case TCP_DNS_RESOLVE:
			DNSEndUsage();	// Release the DNS module, since the user is aborting
9d005f0c:	0f400fef 	jal	9d003fbc <DNSEndUsage>
9d005f10:	00000000 	nop
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
			break;
	}
}
9d005f14:	8fbf001c 	lw	ra,28(sp)
9d005f18:	8fb10018 	lw	s1,24(sp)
9d005f1c:	8fb00014 	lw	s0,20(sp)
		case TCP_FIN_WAIT_1:
		case TCP_FIN_WAIT_2:
		case TCP_LAST_ACK:
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
9d005f20:	0b40164c 	j	9d005930 <CloseSocket>
9d005f24:	27bd0020 	addiu	sp,sp,32
9d005f28:	3c11a000 	lui	s1,0xa000
9d005f2c:	263148e0 	addiu	s1,s1,18656
			// packet (due to the remote Max Segment Size packet size limit), 
			// we will keep generating more packets until either all data gets 
			// transmitted or the remote node's receive window fills up.
			do
			{
				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9d005f30:	24040011 	li	a0,17
9d005f34:	0f401444 	jal	9d005110 <SendTCP>
9d005f38:	24050001 	li	a1,1
				if(MyTCB.remoteWindow == 0u)
9d005f3c:	96220014 	lhu	v0,20(s1)
9d005f40:	1040002b 	beqz	v0,9d005ff0 <TCPDisconnect+0x188>
9d005f44:	93828023 	lbu	v0,-32733(gp)
					break;
			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9d005f48:	8e24000c 	lw	a0,12(s1)
9d005f4c:	00021900 	sll	v1,v0,0x4
9d005f50:	00021180 	sll	v0,v0,0x6
9d005f54:	00432823 	subu	a1,v0,v1
9d005f58:	02052821 	addu	a1,s0,a1
9d005f5c:	8ca5000c 	lw	a1,12(a1)
9d005f60:	14a4fff4 	bne	a1,a0,9d005f34 <TCPDisconnect+0xcc>
9d005f64:	24040011 	li	a0,17
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
			break;
	}
}
9d005f68:	8fbf001c 	lw	ra,28(sp)
				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
				if(MyTCB.remoteWindow == 0u)
					break;
			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);
			
			MyTCBStub.smState = TCP_FIN_WAIT_1;
9d005f6c:	00431023 	subu	v0,v0,v1
9d005f70:	02028021 	addu	s0,s0,v0
9d005f74:	24020008 	li	v0,8
9d005f78:	ae020024 	sw	v0,36(s0)
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
			break;
	}
}
9d005f7c:	8fb10018 	lw	s1,24(sp)
9d005f80:	8fb00014 	lw	s0,20(sp)
9d005f84:	03e00008 	jr	ra
9d005f88:	27bd0020 	addiu	sp,sp,32
9d005f8c:	3c11a000 	lui	s1,0xa000
9d005f90:	263148e0 	addiu	s1,s1,18656
			// packet (due to the remote Max Segment Size packet size limit), 
			// we will keep generating more packets until either all data gets 
			// transmitted or the remote node's receive window fills up.
			do
			{
				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9d005f94:	24040011 	li	a0,17
9d005f98:	0f401444 	jal	9d005110 <SendTCP>
9d005f9c:	24050001 	li	a1,1
				if(MyTCB.remoteWindow == 0u)
9d005fa0:	96220014 	lhu	v0,20(s1)
9d005fa4:	10400015 	beqz	v0,9d005ffc <TCPDisconnect+0x194>
9d005fa8:	93828023 	lbu	v0,-32733(gp)
					break;
			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9d005fac:	8e24000c 	lw	a0,12(s1)
9d005fb0:	00021900 	sll	v1,v0,0x4
9d005fb4:	00021180 	sll	v0,v0,0x6
9d005fb8:	00432823 	subu	a1,v0,v1
9d005fbc:	02052821 	addu	a1,s0,a1
9d005fc0:	8ca5000c 	lw	a1,12(a1)
9d005fc4:	14a4fff4 	bne	a1,a0,9d005f98 <TCPDisconnect+0x130>
9d005fc8:	24040011 	li	a0,17
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
			break;
	}
}
9d005fcc:	8fbf001c 	lw	ra,28(sp)
				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
				if(MyTCB.remoteWindow == 0u)
					break;
			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);

			MyTCBStub.smState = TCP_LAST_ACK;
9d005fd0:	00431023 	subu	v0,v0,v1
9d005fd4:	02028021 	addu	s0,s0,v0
9d005fd8:	2402000c 	li	v0,12
9d005fdc:	ae020024 	sw	v0,36(s0)
		default:
			SendTCP(RST | ACK, 0);
			CloseSocket();
			break;
	}
}
9d005fe0:	8fb10018 	lw	s1,24(sp)
9d005fe4:	8fb00014 	lw	s0,20(sp)
9d005fe8:	03e00008 	jr	ra
9d005fec:	27bd0020 	addiu	sp,sp,32
9d005ff0:	00021900 	sll	v1,v0,0x4
9d005ff4:	0b4017da 	j	9d005f68 <TCPDisconnect+0x100>
9d005ff8:	00021180 	sll	v0,v0,0x6
9d005ffc:	00021900 	sll	v1,v0,0x4
9d006000:	0b4017f3 	j	9d005fcc <TCPDisconnect+0x164>
9d006004:	00021180 	sll	v0,v0,0x6

9d006008 <TCPClose>:

  Returns:
	None
  ***************************************************************************/
void TCPClose(TCP_SOCKET hTCP)
{
9d006008:	308200ff 	andi	v0,a0,0xff
	SyncTCBStub(hTCP);
	MyTCBStub.Flags.bServer = FALSE;
9d00600c:	00022180 	sll	a0,v0,0x6
9d006010:	00021900 	sll	v1,v0,0x4
9d006014:	00831823 	subu	v1,a0,v1
9d006018:	3c04a000 	lui	a0,0xa000
9d00601c:	24844700 	addiu	a0,a0,18176
9d006020:	00641821 	addu	v1,v1,a0
9d006024:	8c650028 	lw	a1,40(v1)
	TCPDisconnect(hTCP);
9d006028:	00402021 	move	a0,v0
  Returns:
	None
  ***************************************************************************/
void TCPClose(TCP_SOCKET hTCP)
{
	SyncTCBStub(hTCP);
9d00602c:	a3828023 	sb	v0,-32733(gp)
	MyTCBStub.Flags.bServer = FALSE;
9d006030:	7c0518c4 	ins	a1,zero,0x3,0x1
	TCPDisconnect(hTCP);
9d006034:	0b40179a 	j	9d005e68 <TCPDisconnect>
9d006038:	ac650028 	sw	a1,40(v1)

9d00603c <TCPFlush>:
  Remarks:
	SSL application data is automatically flushed, so this function has 
	no effect for SSL sockets.
  ***************************************************************************/
void TCPFlush(TCP_SOCKET hTCP)
{
9d00603c:	27bdffe8 	addiu	sp,sp,-24
9d006040:	afbf0014 	sw	ra,20(sp)
	SyncTCBStub(hTCP);
	SyncTCB();
9d006044:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d006048:	a3848023 	sb	a0,-32733(gp)

	// NOTE: Pending SSL data will NOT be transferred here

	if(MyTCBStub.txHead != MyTCB.txUnackedTail)
9d00604c:	93828023 	lbu	v0,-32733(gp)
9d006050:	00021900 	sll	v1,v0,0x4
9d006054:	00021180 	sll	v0,v0,0x6
9d006058:	00431023 	subu	v0,v0,v1
9d00605c:	3c03a000 	lui	v1,0xa000
9d006060:	24634700 	addiu	v1,v1,18176
9d006064:	00621021 	addu	v0,v1,v0
9d006068:	8c43000c 	lw	v1,12(v0)
9d00606c:	3c02a000 	lui	v0,0xa000
9d006070:	8c4248ec 	lw	v0,18668(v0)
9d006074:	10620005 	beq	v1,v0,9d00608c <TCPFlush+0x50>
9d006078:	8fbf0014 	lw	ra,20(sp)
	{
		// Send the TCP segment with all unacked bytes
		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9d00607c:	24040010 	li	a0,16
9d006080:	24050001 	li	a1,1
9d006084:	0b401444 	j	9d005110 <SendTCP>
9d006088:	27bd0018 	addiu	sp,sp,24
	}
}
9d00608c:	03e00008 	jr	ra
9d006090:	27bd0018 	addiu	sp,sp,24

9d006094 <TCPIsPutReady>:

  Returns:
	The number of bytes available to be written in the TCP TX buffer.
  ***************************************************************************/
WORD TCPIsPutReady(TCP_SOCKET hTCP)
{
9d006094:	308400ff 	andi	a0,a0,0xff
	BYTE i;

	SyncTCBStub(hTCP);

	i = MyTCBStub.smState;
9d006098:	00043100 	sll	a2,a0,0x4
9d00609c:	00043980 	sll	a3,a0,0x6
9d0060a0:	3c05a000 	lui	a1,0xa000
9d0060a4:	24a54700 	addiu	a1,a1,18176
9d0060a8:	00e61023 	subu	v0,a3,a2
9d0060ac:	00a21021 	addu	v0,a1,v0
9d0060b0:	90430024 	lbu	v1,36(v0)

	// Unconnected sockets shouldn't be transmitting anything.
	if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) ))
9d0060b4:	24020007 	li	v0,7
9d0060b8:	10620006 	beq	v1,v0,9d0060d4 <TCPIsPutReady+0x40>
9d0060bc:	a3848023 	sb	a0,-32733(gp)
9d0060c0:	2404000b 	li	a0,11
9d0060c4:	10640003 	beq	v1,a0,9d0060d4 <TCPIsPutReady+0x40>
9d0060c8:	00001021 	move	v0,zero
	
	if(MyTCBStub.txHead >= MyTCBStub.txTail)
		return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail);
	else
		return MyTCBStub.txTail - MyTCBStub.txHead - 1;
}
9d0060cc:	03e00008 	jr	ra
9d0060d0:	00000000 	nop
		else
			return 0;
	}
	#endif
	
	if(MyTCBStub.txHead >= MyTCBStub.txTail)
9d0060d4:	00e63023 	subu	a2,a3,a2
9d0060d8:	00a62821 	addu	a1,a1,a2
9d0060dc:	8ca3000c 	lw	v1,12(a1)
9d0060e0:	8ca20010 	lw	v0,16(a1)
9d0060e4:	0062202b 	sltu	a0,v1,v0
9d0060e8:	50800005 	beqzl	a0,9d006100 <TCPIsPutReady+0x6c>
9d0060ec:	8ca60004 	lw	a2,4(a1)
		return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail);
	else
		return MyTCBStub.txTail - MyTCBStub.txHead - 1;
9d0060f0:	2442ffff 	addiu	v0,v0,-1
9d0060f4:	00431023 	subu	v0,v0,v1
}
9d0060f8:	03e00008 	jr	ra
9d0060fc:	3042ffff 	andi	v0,v0,0xffff
			return 0;
	}
	#endif
	
	if(MyTCBStub.txHead >= MyTCBStub.txTail)
		return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail);
9d006100:	8ca40000 	lw	a0,0(a1)
9d006104:	00c21021 	addu	v0,a2,v0
9d006108:	2442ffff 	addiu	v0,v0,-1
9d00610c:	00441023 	subu	v0,v0,a0
9d006110:	00431023 	subu	v0,v0,v1
9d006114:	03e00008 	jr	ra
9d006118:	3042ffff 	andi	v0,v0,0xffff

9d00611c <TCPPut>:
  Return Values:
	TRUE - The byte was written to the transmit buffer.
	FALSE - The transmit buffer was full, or the socket is not connected.
  ***************************************************************************/
BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
{
9d00611c:	27bdffd0 	addiu	sp,sp,-48
9d006120:	afb0001c 	sw	s0,28(sp)
9d006124:	309000ff 	andi	s0,a0,0xff
	WORD wFreeTXSpace;

	SyncTCBStub(hTCP);

	wFreeTXSpace = TCPIsPutReady(hTCP);
9d006128:	02002021 	move	a0,s0
  Return Values:
	TRUE - The byte was written to the transmit buffer.
	FALSE - The transmit buffer was full, or the socket is not connected.
  ***************************************************************************/
BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
{
9d00612c:	afb30028 	sw	s3,40(sp)
9d006130:	afb10020 	sw	s1,32(sp)
9d006134:	afbf002c 	sw	ra,44(sp)
9d006138:	afb20024 	sw	s2,36(sp)
9d00613c:	a3a50034 	sb	a1,52(sp)
	WORD wFreeTXSpace;

	SyncTCBStub(hTCP);

	wFreeTXSpace = TCPIsPutReady(hTCP);
9d006140:	0f401825 	jal	9d006094 <TCPIsPutReady>
9d006144:	a3908023 	sb	s0,-32733(gp)
9d006148:	00408821 	move	s1,v0
	if(wFreeTXSpace == 0u)
9d00614c:	10400032 	beqz	v0,9d006218 <TCPPut+0xfc>
9d006150:	00009821 	move	s3,zero
		return FALSE;
	else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster
9d006154:	24020001 	li	v0,1
9d006158:	12220053 	beq	s1,v0,9d0062a8 <TCPPut+0x18c>
9d00615c:	00000000 	nop
		TCPFlush(hTCP);	

	// Send all current bytes if we are crossing half full
	// This is required to improve performance with the delayed 
	// acknowledgement algorithm
	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9d006160:	93828023 	lbu	v0,-32733(gp)
9d006164:	3c12a000 	lui	s2,0xa000
9d006168:	26524700 	addiu	s2,s2,18176
9d00616c:	00021900 	sll	v1,v0,0x4
9d006170:	00021180 	sll	v0,v0,0x6
9d006174:	00432023 	subu	a0,v0,v1
9d006178:	02442021 	addu	a0,s2,a0
9d00617c:	8c850028 	lw	a1,40(a0)
9d006180:	7ca50200 	ext	a1,a1,0x8,0x1
9d006184:	54a00009 	bnezl	a1,9d0061ac <TCPPut+0x90>
9d006188:	00431023 	subu	v0,v0,v1
9d00618c:	8c850004 	lw	a1,4(a0)
9d006190:	8c840000 	lw	a0,0(a0)
9d006194:	00a42023 	subu	a0,a1,a0
9d006198:	00042042 	srl	a0,a0,0x1
9d00619c:	0091202b 	sltu	a0,a0,s1
9d0061a0:	10800035 	beqz	a0,9d006278 <TCPPut+0x15c>
9d0061a4:	00000000 	nop
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
		if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	}
	#else
	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
9d0061a8:	00431023 	subu	v0,v0,v1
9d0061ac:	02421021 	addu	v0,s2,v0
9d0061b0:	8c44000c 	lw	a0,12(v0)
9d0061b4:	9045002c 	lbu	a1,44(v0)
9d0061b8:	27a60034 	addiu	a2,sp,52
9d0061bc:	24020001 	li	v0,1
9d0061c0:	24070001 	li	a3,1
9d0061c4:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d0061c8:	afa20010 	sw	v0,16(sp)
	if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
9d0061cc:	93828023 	lbu	v0,-32733(gp)
9d0061d0:	00022100 	sll	a0,v0,0x4
9d0061d4:	00022980 	sll	a1,v0,0x6
9d0061d8:	00a41023 	subu	v0,a1,a0
9d0061dc:	02421021 	addu	v0,s2,v0
9d0061e0:	8c43000c 	lw	v1,12(v0)
9d0061e4:	8c460004 	lw	a2,4(v0)
9d0061e8:	24630001 	addiu	v1,v1,1
9d0061ec:	0066302b 	sltu	a2,v1,a2
9d0061f0:	10c00011 	beqz	a2,9d006238 <TCPPut+0x11c>
9d0061f4:	ac43000c 	sw	v1,12(v0)
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	#endif
	

	// Send the last byte as a separate packet (likely will make the remote node send back ACK faster)
	if(wFreeTXSpace == 1u)
9d0061f8:	24020001 	li	v0,1
9d0061fc:	1222002e 	beq	s1,v0,9d0062b8 <TCPPut+0x19c>
9d006200:	00a42023 	subu	a0,a1,a0
		TCPFlush(hTCP);
	}
	// If not already enabled, start a timer so this data will 
	// eventually get sent even if the application doens't call
	// TCPFlush()
	else if(!MyTCBStub.Flags.bTimer2Enabled)
9d006204:	02449021 	addu	s2,s2,a0
9d006208:	8e420028 	lw	v0,40(s2)
9d00620c:	7c430140 	ext	v1,v0,0x5,0x1
9d006210:	1060000c 	beqz	v1,9d006244 <TCPPut+0x128>
9d006214:	24130001 	li	s3,1
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
	}

	return TRUE;
}
9d006218:	8fbf002c 	lw	ra,44(sp)
9d00621c:	02601021 	move	v0,s3
9d006220:	8fb30028 	lw	s3,40(sp)
9d006224:	8fb20024 	lw	s2,36(sp)
9d006228:	8fb10020 	lw	s1,32(sp)
9d00622c:	8fb0001c 	lw	s0,28(sp)
9d006230:	03e00008 	jr	ra
9d006234:	27bd0030 	addiu	sp,sp,48
			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	}
	#else
	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
	if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9d006238:	8c430000 	lw	v1,0(v0)
9d00623c:	0b40187e 	j	9d0061f8 <TCPPut+0xdc>
9d006240:	ac43000c 	sw	v1,12(v0)
	// If not already enabled, start a timer so this data will 
	// eventually get sent even if the application doens't call
	// TCPFlush()
	else if(!MyTCBStub.Flags.bTimer2Enabled)
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9d006244:	7e622944 	ins	v0,s3,0x5,0x1
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9d006248:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d00624c:	ae420028 	sw	v0,40(s2)
	}

	return TRUE;
}
9d006250:	8fbf002c 	lw	ra,44(sp)
	// eventually get sent even if the application doens't call
	// TCPFlush()
	else if(!MyTCBStub.Flags.bTimer2Enabled)
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9d006254:	24420030 	addiu	v0,v0,48
9d006258:	a6420020 	sh	v0,32(s2)
	}

	return TRUE;
}
9d00625c:	8fb10020 	lw	s1,32(sp)
9d006260:	02601021 	move	v0,s3
9d006264:	8fb30028 	lw	s3,40(sp)
9d006268:	8fb20024 	lw	s2,36(sp)
9d00626c:	8fb0001c 	lw	s0,28(sp)
9d006270:	03e00008 	jr	ra
9d006274:	27bd0030 	addiu	sp,sp,48
	// Send all current bytes if we are crossing half full
	// This is required to improve performance with the delayed 
	// acknowledgement algorithm
	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
	{
		TCPFlush(hTCP);	
9d006278:	0f40180f 	jal	9d00603c <TCPFlush>
9d00627c:	02002021 	move	a0,s0
		MyTCBStub.Flags.bHalfFullFlush = TRUE;
9d006280:	93828023 	lbu	v0,-32733(gp)
9d006284:	24060001 	li	a2,1
9d006288:	00021900 	sll	v1,v0,0x4
9d00628c:	00021180 	sll	v0,v0,0x6
9d006290:	00432023 	subu	a0,v0,v1
9d006294:	00922021 	addu	a0,a0,s2
9d006298:	8c850028 	lw	a1,40(a0)
9d00629c:	7cc54204 	ins	a1,a2,0x8,0x1
9d0062a0:	0b40186a 	j	9d0061a8 <TCPPut+0x8c>
9d0062a4:	ac850028 	sw	a1,40(a0)

	wFreeTXSpace = TCPIsPutReady(hTCP);
	if(wFreeTXSpace == 0u)
		return FALSE;
	else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster
		TCPFlush(hTCP);	
9d0062a8:	0f40180f 	jal	9d00603c <TCPFlush>
9d0062ac:	02002021 	move	a0,s0

	// Send all current bytes if we are crossing half full
	// This is required to improve performance with the delayed 
	// acknowledgement algorithm
	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9d0062b0:	0b401859 	j	9d006164 <TCPPut+0x48>
9d0062b4:	93828023 	lbu	v0,-32733(gp)
	

	// Send the last byte as a separate packet (likely will make the remote node send back ACK faster)
	if(wFreeTXSpace == 1u)
	{
		TCPFlush(hTCP);
9d0062b8:	0f40180f 	jal	9d00603c <TCPFlush>
9d0062bc:	02002021 	move	a0,s0
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
	}

	return TRUE;
9d0062c0:	0b401886 	j	9d006218 <TCPPut+0xfc>
9d0062c4:	24130001 	li	s3,1

9d0062c8 <TCPPutArray>:
  Returns:
	The number of bytes written to the socket.  If less than len, the
	buffer became full or the socket is not conected.
  ***************************************************************************/
WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
{
9d0062c8:	27bdffc0 	addiu	sp,sp,-64
9d0062cc:	afb00020 	sw	s0,32(sp)
9d0062d0:	309000ff 	andi	s0,a0,0xff
	WORD wFreeTXSpace;
	WORD wRightLen = 0;

	SyncTCBStub(hTCP);

	wFreeTXSpace = TCPIsPutReady(hTCP);
9d0062d4:	02002021 	move	a0,s0
  Returns:
	The number of bytes written to the socket.  If less than len, the
	buffer became full or the socket is not conected.
  ***************************************************************************/
WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
{
9d0062d8:	afb20028 	sw	s2,40(sp)
9d0062dc:	afb10024 	sw	s1,36(sp)
9d0062e0:	afbf003c 	sw	ra,60(sp)
9d0062e4:	afb60038 	sw	s6,56(sp)
9d0062e8:	afb50034 	sw	s5,52(sp)
9d0062ec:	afb40030 	sw	s4,48(sp)
9d0062f0:	afb3002c 	sw	s3,44(sp)
9d0062f4:	00a08821 	move	s1,a1
9d0062f8:	30d2ffff 	andi	s2,a2,0xffff
	WORD wFreeTXSpace;
	WORD wRightLen = 0;

	SyncTCBStub(hTCP);

	wFreeTXSpace = TCPIsPutReady(hTCP);
9d0062fc:	0f401825 	jal	9d006094 <TCPIsPutReady>
9d006300:	a3908023 	sb	s0,-32733(gp)
	if(wFreeTXSpace == 0u)
9d006304:	1040006d 	beqz	v0,9d0064bc <TCPPutArray+0x1f4>
9d006308:	93858023 	lbu	a1,-32733(gp)
		wActualLen = len;

	// Send all current bytes if we are crossing half full
	// This is required to improve performance with the delayed 
	// acknowledgement algorithm
	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9d00630c:	3c16a000 	lui	s6,0xa000
9d006310:	26d64700 	addiu	s6,s6,18176
9d006314:	00051900 	sll	v1,a1,0x4
9d006318:	00052980 	sll	a1,a1,0x6
9d00631c:	00a32023 	subu	a0,a1,v1
9d006320:	02c42021 	addu	a0,s6,a0
9d006324:	8c870028 	lw	a3,40(a0)

	wFreeTXSpace = TCPIsPutReady(hTCP);
	if(wFreeTXSpace == 0u)
	{
		TCPFlush(hTCP);
		return 0;
9d006328:	0040a821 	move	s5,v0
9d00632c:	0242402b 	sltu	t0,s2,v0
9d006330:	0248a80b 	movn	s5,s2,t0
		wActualLen = len;

	// Send all current bytes if we are crossing half full
	// This is required to improve performance with the delayed 
	// acknowledgement algorithm
	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9d006334:	7ce60200 	ext	a2,a3,0x8,0x1
9d006338:	10c0002c 	beqz	a2,9d0063ec <TCPPutArray+0x124>
9d00633c:	02a0a021 	move	s4,s5
9d006340:	8c860004 	lw	a2,4(a0)
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
		MyTCBStub.txHead += wActualLen;
	}
	#else
	// See if we need a two part put
	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
9d006344:	00a33823 	subu	a3,a1,v1
9d006348:	02c73821 	addu	a3,s6,a3
9d00634c:	8ce4000c 	lw	a0,12(a3)
9d006350:	02a44021 	addu	t0,s5,a0
9d006354:	0106402b 	sltu	t0,t0,a2
9d006358:	11000040 	beqz	t0,9d00645c <TCPPutArray+0x194>
9d00635c:	00009821 	move	s3,zero
		data += wRightLen;
		wActualLen -= wRightLen;
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	}

	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
9d006360:	00a31823 	subu	v1,a1,v1
9d006364:	02c31821 	addu	v1,s6,v1
9d006368:	9065002c 	lbu	a1,44(v1)
9d00636c:	02203021 	move	a2,s1
9d006370:	24070001 	li	a3,1
9d006374:	afa20018 	sw	v0,24(sp)
9d006378:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d00637c:	afb40010 	sw	s4,16(sp)
	MyTCBStub.txHead += wActualLen;
	#endif

	// Send these bytes right now if we are out of TX buffer space
	if(wFreeTXSpace <= len)
9d006380:	8fa20018 	lw	v0,24(sp)
		wActualLen -= wRightLen;
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	}

	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
	MyTCBStub.txHead += wActualLen;
9d006384:	93838023 	lbu	v1,-32733(gp)
	#endif

	// Send these bytes right now if we are out of TX buffer space
	if(wFreeTXSpace <= len)
9d006388:	0242902b 	sltu	s2,s2,v0
		wActualLen -= wRightLen;
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
	}

	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
	MyTCBStub.txHead += wActualLen;
9d00638c:	00031100 	sll	v0,v1,0x4
9d006390:	00031980 	sll	v1,v1,0x6
9d006394:	00621823 	subu	v1,v1,v0
9d006398:	02c3b021 	addu	s6,s6,v1
9d00639c:	8ec2000c 	lw	v0,12(s6)
9d0063a0:	02821021 	addu	v0,s4,v0
	#endif

	// Send these bytes right now if we are out of TX buffer space
	if(wFreeTXSpace <= len)
9d0063a4:	12400041 	beqz	s2,9d0064ac <TCPPutArray+0x1e4>
9d0063a8:	aec2000c 	sw	v0,12(s6)
		TCPFlush(hTCP);
	}
	// If not already enabled, start a timer so this data will 
	// eventually get sent even if the application doens't call
	// TCPFlush()
	else if(!MyTCBStub.Flags.bTimer2Enabled)
9d0063ac:	8ec20028 	lw	v0,40(s6)
9d0063b0:	7c430140 	ext	v1,v0,0x5,0x1
9d0063b4:	1060004e 	beqz	v1,9d0064f0 <TCPPutArray+0x228>
9d0063b8:	24030001 	li	v1,1
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
	}

	return wActualLen + wRightLen;
}
9d0063bc:	8fbf003c 	lw	ra,60(sp)
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
	}

	return wActualLen + wRightLen;
9d0063c0:	02749821 	addu	s3,s3,s4
9d0063c4:	3262ffff 	andi	v0,s3,0xffff
}
9d0063c8:	8fb60038 	lw	s6,56(sp)
9d0063cc:	8fb50034 	lw	s5,52(sp)
9d0063d0:	8fb40030 	lw	s4,48(sp)
9d0063d4:	8fb3002c 	lw	s3,44(sp)
9d0063d8:	8fb20028 	lw	s2,40(sp)
9d0063dc:	8fb10024 	lw	s1,36(sp)
9d0063e0:	8fb00020 	lw	s0,32(sp)
9d0063e4:	03e00008 	jr	ra
9d0063e8:	27bd0040 	addiu	sp,sp,64
		wActualLen = len;

	// Send all current bytes if we are crossing half full
	// This is required to improve performance with the delayed 
	// acknowledgement algorithm
	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9d0063ec:	8c860004 	lw	a2,4(a0)
9d0063f0:	8c840000 	lw	a0,0(a0)
9d0063f4:	00c42023 	subu	a0,a2,a0
9d0063f8:	00042042 	srl	a0,a0,0x1
9d0063fc:	0082202b 	sltu	a0,a0,v0
9d006400:	1480ffd1 	bnez	a0,9d006348 <TCPPutArray+0x80>
9d006404:	00a33823 	subu	a3,a1,v1
	{
		TCPFlush(hTCP);	
9d006408:	02002021 	move	a0,s0
9d00640c:	0f40180f 	jal	9d00603c <TCPFlush>
9d006410:	afa20018 	sw	v0,24(sp)
		MyTCBStub.Flags.bHalfFullFlush = TRUE;
9d006414:	93858023 	lbu	a1,-32733(gp)
9d006418:	24080001 	li	t0,1
  ***************************************************************************/
WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
{
	WORD wActualLen;
	WORD wFreeTXSpace;
	WORD wRightLen = 0;
9d00641c:	00009821 	move	s3,zero
	// This is required to improve performance with the delayed 
	// acknowledgement algorithm
	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
	{
		TCPFlush(hTCP);	
		MyTCBStub.Flags.bHalfFullFlush = TRUE;
9d006420:	00051900 	sll	v1,a1,0x4
9d006424:	00052980 	sll	a1,a1,0x6
9d006428:	00a32023 	subu	a0,a1,v1
9d00642c:	00962021 	addu	a0,a0,s6
9d006430:	8c870028 	lw	a3,40(a0)
9d006434:	8c860004 	lw	a2,4(a0)
9d006438:	7d074204 	ins	a3,t0,0x8,0x1
9d00643c:	ac870028 	sw	a3,40(a0)
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
		MyTCBStub.txHead += wActualLen;
	}
	#else
	// See if we need a two part put
	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
9d006440:	00a33823 	subu	a3,a1,v1
9d006444:	02c73821 	addu	a3,s6,a3
9d006448:	8ce4000c 	lw	a0,12(a3)
9d00644c:	02a44021 	addu	t0,s5,a0
9d006450:	0106402b 	sltu	t0,t0,a2
9d006454:	1500ffc2 	bnez	t0,9d006360 <TCPPutArray+0x98>
9d006458:	8fa20018 	lw	v0,24(sp)
	{
		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
9d00645c:	90e5002c 	lbu	a1,44(a3)
	}
	#else
	// See if we need a two part put
	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
	{
		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
9d006460:	00c49823 	subu	s3,a2,a0
9d006464:	3273ffff 	andi	s3,s3,0xffff
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
9d006468:	02203021 	move	a2,s1
9d00646c:	24070001 	li	a3,1
9d006470:	afa20018 	sw	v0,24(sp)
9d006474:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006478:	afb30010 	sw	s3,16(sp)
		data += wRightLen;
		wActualLen -= wRightLen;
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9d00647c:	93858023 	lbu	a1,-32733(gp)
	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
	{
		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
		data += wRightLen;
		wActualLen -= wRightLen;
9d006480:	02b3a023 	subu	s4,s5,s3
	// See if we need a two part put
	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
	{
		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
		data += wRightLen;
9d006484:	02338821 	addu	s1,s1,s3
		wActualLen -= wRightLen;
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9d006488:	00051900 	sll	v1,a1,0x4
9d00648c:	00052980 	sll	a1,a1,0x6
9d006490:	00a33023 	subu	a2,a1,v1
9d006494:	00d63021 	addu	a2,a2,s6
9d006498:	8cc40000 	lw	a0,0(a2)
	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
	{
		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
		data += wRightLen;
		wActualLen -= wRightLen;
9d00649c:	3294ffff 	andi	s4,s4,0xffff
		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9d0064a0:	8fa20018 	lw	v0,24(sp)
9d0064a4:	0b4018d8 	j	9d006360 <TCPPutArray+0x98>
9d0064a8:	acc4000c 	sw	a0,12(a2)
	#endif

	// Send these bytes right now if we are out of TX buffer space
	if(wFreeTXSpace <= len)
	{
		TCPFlush(hTCP);
9d0064ac:	0f40180f 	jal	9d00603c <TCPFlush>
9d0064b0:	02002021 	move	a0,s0
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
	}

	return wActualLen + wRightLen;
}
9d0064b4:	0b4018f0 	j	9d0063c0 <TCPPutArray+0xf8>
9d0064b8:	8fbf003c 	lw	ra,60(sp)
	SyncTCBStub(hTCP);

	wFreeTXSpace = TCPIsPutReady(hTCP);
	if(wFreeTXSpace == 0u)
	{
		TCPFlush(hTCP);
9d0064bc:	0f40180f 	jal	9d00603c <TCPFlush>
9d0064c0:	02002021 	move	a0,s0
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
	}

	return wActualLen + wRightLen;
}
9d0064c4:	8fbf003c 	lw	ra,60(sp)

	wFreeTXSpace = TCPIsPutReady(hTCP);
	if(wFreeTXSpace == 0u)
	{
		TCPFlush(hTCP);
		return 0;
9d0064c8:	00001021 	move	v0,zero
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
	}

	return wActualLen + wRightLen;
}
9d0064cc:	8fb60038 	lw	s6,56(sp)
9d0064d0:	8fb50034 	lw	s5,52(sp)
9d0064d4:	8fb40030 	lw	s4,48(sp)
9d0064d8:	8fb3002c 	lw	s3,44(sp)
9d0064dc:	8fb20028 	lw	s2,40(sp)
9d0064e0:	8fb10024 	lw	s1,36(sp)
9d0064e4:	8fb00020 	lw	s0,32(sp)
9d0064e8:	03e00008 	jr	ra
9d0064ec:	27bd0040 	addiu	sp,sp,64
	// If not already enabled, start a timer so this data will 
	// eventually get sent even if the application doens't call
	// TCPFlush()
	else if(!MyTCBStub.Flags.bTimer2Enabled)
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9d0064f0:	7c622944 	ins	v0,v1,0x5,0x1
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9d0064f4:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d0064f8:	aec20028 	sw	v0,40(s6)
9d0064fc:	24420030 	addiu	v0,v0,48
9d006500:	0b4018ef 	j	9d0063bc <TCPPutArray+0xf4>
9d006504:	a6c20020 	sh	v0,32(s6)

9d006508 <TCPPutString>:
	first byte, then call this function repeatedly (breaking to the main 
	stack loop after each call) until the return value dereferences to a NUL
	byte.  Save the return value as the new starting *data pointer otherwise.
  ***************************************************************************/
BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
{
9d006508:	27bdffe0 	addiu	sp,sp,-32
9d00650c:	afb10018 	sw	s1,24(sp)
9d006510:	309100ff 	andi	s1,a0,0xff
	return data + TCPPutArray(hTCP, data, strlen((char*)data));
9d006514:	00a02021 	move	a0,a1
	first byte, then call this function repeatedly (breaking to the main 
	stack loop after each call) until the return value dereferences to a NUL
	byte.  Save the return value as the new starting *data pointer otherwise.
  ***************************************************************************/
BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
{
9d006518:	afbf001c 	sw	ra,28(sp)
9d00651c:	afb00014 	sw	s0,20(sp)
	return data + TCPPutArray(hTCP, data, strlen((char*)data));
9d006520:	0f40301c 	jal	9d00c070 <strlen>
9d006524:	00a08021 	move	s0,a1
9d006528:	3046ffff 	andi	a2,v0,0xffff
9d00652c:	02202021 	move	a0,s1
9d006530:	0f4018b2 	jal	9d0062c8 <TCPPutArray>
9d006534:	02002821 	move	a1,s0
}
9d006538:	8fbf001c 	lw	ra,28(sp)
9d00653c:	02021021 	addu	v0,s0,v0
9d006540:	8fb10018 	lw	s1,24(sp)
9d006544:	8fb00014 	lw	s0,20(sp)
9d006548:	03e00008 	jr	ra
9d00654c:	27bd0020 	addiu	sp,sp,32

9d006550 <TCPIsGetReady>:

  Returns:
	The number of bytes available to be read from the TCP RX buffer.
  ***************************************************************************/
WORD TCPIsGetReady(TCP_SOCKET hTCP)
{
9d006550:	308400ff 	andi	a0,a0,0xff
	SyncTCBStub(hTCP);
		
	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9d006554:	00041980 	sll	v1,a0,0x6
9d006558:	00041100 	sll	v0,a0,0x4
9d00655c:	00621023 	subu	v0,v1,v0
9d006560:	3c03a000 	lui	v1,0xa000
9d006564:	24634700 	addiu	v1,v1,18176
9d006568:	00621821 	addu	v1,v1,v0
9d00656c:	8c660014 	lw	a2,20(v1)
9d006570:	8c650018 	lw	a1,24(v1)
9d006574:	00c5102b 	sltu	v0,a2,a1
9d006578:	10400009 	beqz	v0,9d0065a0 <TCPIsGetReady+0x50>
9d00657c:	a3848023 	sb	a0,-32733(gp)
		return MyTCBStub.rxHead - MyTCBStub.rxTail;
	else
		return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart);
9d006580:	8c620008 	lw	v0,8(v1)
9d006584:	8c630004 	lw	v1,4(v1)
9d006588:	00461021 	addu	v0,v0,a2
9d00658c:	24420001 	addiu	v0,v0,1
9d006590:	00451023 	subu	v0,v0,a1
9d006594:	00431023 	subu	v0,v0,v1
}
9d006598:	03e00008 	jr	ra
9d00659c:	3042ffff 	andi	v0,v0,0xffff
WORD TCPIsGetReady(TCP_SOCKET hTCP)
{
	SyncTCBStub(hTCP);
		
	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
		return MyTCBStub.rxHead - MyTCBStub.rxTail;
9d0065a0:	00c52823 	subu	a1,a2,a1
9d0065a4:	03e00008 	jr	ra
9d0065a8:	30a2ffff 	andi	v0,a1,0xffff

9d0065ac <TCPDiscard>:

  Returns:
	None
  ***************************************************************************/
void TCPDiscard(TCP_SOCKET hTCP)
{
9d0065ac:	27bdffe8 	addiu	sp,sp,-24
9d0065b0:	afb00010 	sw	s0,16(sp)
9d0065b4:	309000ff 	andi	s0,a0,0xff
9d0065b8:	afbf0014 	sw	ra,20(sp)
	if(TCPIsGetReady(hTCP))
9d0065bc:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d0065c0:	02002021 	move	a0,s0
9d0065c4:	14400004 	bnez	v0,9d0065d8 <TCPDiscard+0x2c>
9d0065c8:	8fbf0014 	lw	ra,20(sp)
		MyTCBStub.rxTail = MyTCBStub.rxHead;
	
		// Send a Window update message to the remote node
		SendTCP(ACK, SENDTCP_RESET_TIMERS);
	}
}
9d0065cc:	8fb00010 	lw	s0,16(sp)
9d0065d0:	03e00008 	jr	ra
9d0065d4:	27bd0018 	addiu	sp,sp,24
	if(TCPIsGetReady(hTCP))
	{
		SyncTCBStub(hTCP);
	
		// Delete all data in the RX buffer
		MyTCBStub.rxTail = MyTCBStub.rxHead;
9d0065d8:	00101980 	sll	v1,s0,0x6
9d0065dc:	00101100 	sll	v0,s0,0x4
9d0065e0:	00621023 	subu	v0,v1,v0
9d0065e4:	3c03a000 	lui	v1,0xa000
9d0065e8:	24634700 	addiu	v1,v1,18176
9d0065ec:	00431021 	addu	v0,v0,v1
9d0065f0:	8c430014 	lw	v1,20(v0)
  ***************************************************************************/
void TCPDiscard(TCP_SOCKET hTCP)
{
	if(TCPIsGetReady(hTCP))
	{
		SyncTCBStub(hTCP);
9d0065f4:	a3908023 	sb	s0,-32733(gp)
		MyTCBStub.rxTail = MyTCBStub.rxHead;
	
		// Send a Window update message to the remote node
		SendTCP(ACK, SENDTCP_RESET_TIMERS);
	}
}
9d0065f8:	8fbf0014 	lw	ra,20(sp)
9d0065fc:	8fb00010 	lw	s0,16(sp)
	
		// Delete all data in the RX buffer
		MyTCBStub.rxTail = MyTCBStub.rxHead;
	
		// Send a Window update message to the remote node
		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9d006600:	24040010 	li	a0,16
9d006604:	24050001 	li	a1,1
	if(TCPIsGetReady(hTCP))
	{
		SyncTCBStub(hTCP);
	
		// Delete all data in the RX buffer
		MyTCBStub.rxTail = MyTCBStub.rxHead;
9d006608:	ac430018 	sw	v1,24(v0)
	
		// Send a Window update message to the remote node
		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9d00660c:	0b401444 	j	9d005110 <SendTCP>
9d006610:	27bd0018 	addiu	sp,sp,24

9d006614 <TCPGet>:
  Return Values:
	TRUE - A byte was read from the buffer.
	FALSE - The buffer was empty, or the socket is not connected.
  ***************************************************************************/
BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
{
9d006614:	27bdffc8 	addiu	sp,sp,-56
9d006618:	afb2002c 	sw	s2,44(sp)
9d00661c:	309200ff 	andi	s2,a0,0xff
	WORD wGetReadyCount;

	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
9d006620:	02402021 	move	a0,s2
  Return Values:
	TRUE - A byte was read from the buffer.
	FALSE - The buffer was empty, or the socket is not connected.
  ***************************************************************************/
BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
{
9d006624:	afb30030 	sw	s3,48(sp)
9d006628:	afb00024 	sw	s0,36(sp)
	WORD wGetReadyCount;

	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
9d00662c:	afa50018 	sw	a1,24(sp)
  Return Values:
	TRUE - A byte was read from the buffer.
	FALSE - The buffer was empty, or the socket is not connected.
  ***************************************************************************/
BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
{
9d006630:	afbf0034 	sw	ra,52(sp)
	WORD wGetReadyCount;

	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
9d006634:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d006638:	afb10028 	sw	s1,40(sp)
9d00663c:	00408021 	move	s0,v0
	if(wGetReadyCount == 0u)
		return FALSE;
9d006640:	00009821 	move	s3,zero
{
	WORD wGetReadyCount;

	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
	if(wGetReadyCount == 0u)
9d006644:	10400025 	beqz	v0,9d0066dc <TCPGet+0xc8>
9d006648:	8fa50018 	lw	a1,24(sp)
		return FALSE;

	SyncTCBStub(hTCP);
	
	if(byte)
9d00664c:	10a00038 	beqz	a1,9d006730 <TCPGet+0x11c>
9d006650:	a3928023 	sb	s2,-32733(gp)
		TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1);
9d006654:	00121100 	sll	v0,s2,0x4
9d006658:	3c11a000 	lui	s1,0xa000
9d00665c:	00129180 	sll	s2,s2,0x6
9d006660:	02429023 	subu	s2,s2,v0
9d006664:	26314700 	addiu	s1,s1,18176
9d006668:	02329021 	addu	s2,s1,s2
9d00666c:	8e460018 	lw	a2,24(s2)
9d006670:	9247002c 	lbu	a3,44(s2)
9d006674:	00a02021 	move	a0,a1
9d006678:	24020001 	li	v0,1
9d00667c:	24050001 	li	a1,1
9d006680:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006684:	afa20010 	sw	v0,16(sp)
9d006688:	93928023 	lbu	s2,-32733(gp)
	if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd)
9d00668c:	00122100 	sll	a0,s2,0x4
9d006690:	00129180 	sll	s2,s2,0x6
9d006694:	02441023 	subu	v0,s2,a0
9d006698:	02221021 	addu	v0,s1,v0
9d00669c:	8c430018 	lw	v1,24(v0)
9d0066a0:	8c450008 	lw	a1,8(v0)
9d0066a4:	24630001 	addiu	v1,v1,1
9d0066a8:	00a3282b 	sltu	a1,a1,v1
9d0066ac:	10a00003 	beqz	a1,9d0066bc <TCPGet+0xa8>
9d0066b0:	ac430018 	sw	v1,24(v0)
		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9d0066b4:	8c430004 	lw	v1,4(v0)
9d0066b8:	ac430018 	sw	v1,24(v0)

	// Send a window update if we've run out of data
	if(wGetReadyCount == 1u)
9d0066bc:	24020001 	li	v0,1
9d0066c0:	1202001e 	beq	s0,v0,9d00673c <TCPGet+0x128>
9d0066c4:	02449023 	subu	s2,s2,a0
	{
		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
	}
	// If not already enabled, start a timer so a window 
	// update will get sent to the remote node at some point
	else if(!MyTCBStub.Flags.bTimer2Enabled)
9d0066c8:	02328821 	addu	s1,s1,s2
9d0066cc:	8e220028 	lw	v0,40(s1)
9d0066d0:	7c430140 	ext	v1,v0,0x5,0x1
9d0066d4:	10600009 	beqz	v1,9d0066fc <TCPGet+0xe8>
9d0066d8:	24130001 	li	s3,1
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
	}


	return TRUE;
}
9d0066dc:	8fbf0034 	lw	ra,52(sp)
9d0066e0:	02601021 	move	v0,s3
9d0066e4:	8fb30030 	lw	s3,48(sp)
9d0066e8:	8fb2002c 	lw	s2,44(sp)
9d0066ec:	8fb10028 	lw	s1,40(sp)
9d0066f0:	8fb00024 	lw	s0,36(sp)
9d0066f4:	03e00008 	jr	ra
9d0066f8:	27bd0038 	addiu	sp,sp,56
	}
	// If not already enabled, start a timer so a window 
	// update will get sent to the remote node at some point
	else if(!MyTCBStub.Flags.bTimer2Enabled)
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9d0066fc:	7e622944 	ins	v0,s3,0x5,0x1
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9d006700:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d006704:	ae220028 	sw	v0,40(s1)
	}


	return TRUE;
}
9d006708:	8fbf0034 	lw	ra,52(sp)
	// If not already enabled, start a timer so a window 
	// update will get sent to the remote node at some point
	else if(!MyTCBStub.Flags.bTimer2Enabled)
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9d00670c:	244200f4 	addiu	v0,v0,244
9d006710:	a6220020 	sh	v0,32(s1)
	}


	return TRUE;
}
9d006714:	8fb2002c 	lw	s2,44(sp)
9d006718:	02601021 	move	v0,s3
9d00671c:	8fb30030 	lw	s3,48(sp)
9d006720:	8fb10028 	lw	s1,40(sp)
9d006724:	8fb00024 	lw	s0,36(sp)
9d006728:	03e00008 	jr	ra
9d00672c:	27bd0038 	addiu	sp,sp,56
9d006730:	3c11a000 	lui	s1,0xa000
9d006734:	0b4019a3 	j	9d00668c <TCPGet+0x78>
9d006738:	26314700 	addiu	s1,s1,18176
		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;

	// Send a window update if we've run out of data
	if(wGetReadyCount == 1u)
	{
		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9d00673c:	02328821 	addu	s1,s1,s2
9d006740:	8e220028 	lw	v0,40(s1)
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
	}


	return TRUE;
9d006744:	24130001 	li	s3,1
		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;

	// Send a window update if we've run out of data
	if(wGetReadyCount == 1u)
	{
		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9d006748:	7e025284 	ins	v0,s0,0xa,0x1
9d00674c:	ae220028 	sw	v0,40(s1)
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
	}


	return TRUE;
}
9d006750:	8fbf0034 	lw	ra,52(sp)
9d006754:	02601021 	move	v0,s3
9d006758:	8fb30030 	lw	s3,48(sp)
9d00675c:	8fb2002c 	lw	s2,44(sp)
9d006760:	8fb10028 	lw	s1,40(sp)
9d006764:	8fb00024 	lw	s0,36(sp)
9d006768:	03e00008 	jr	ra
9d00676c:	27bd0038 	addiu	sp,sp,56

9d006770 <TCPGetArray>:
  Returns:
	The number of bytes read from the socket.  If less than len, the
	RX FIFO buffer became empty or the socket is not conected.
  ***************************************************************************/
WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
{
9d006770:	27bdffc8 	addiu	sp,sp,-56
9d006774:	afb20020 	sw	s2,32(sp)
9d006778:	309200ff 	andi	s2,a0,0xff
	WORD wGetReadyCount;
	WORD RightLen = 0;

	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
9d00677c:	02402021 	move	a0,s2
  Returns:
	The number of bytes read from the socket.  If less than len, the
	RX FIFO buffer became empty or the socket is not conected.
  ***************************************************************************/
WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
{
9d006780:	afb60030 	sw	s6,48(sp)
9d006784:	afb40028 	sw	s4,40(sp)
9d006788:	afb1001c 	sw	s1,28(sp)
9d00678c:	afb00018 	sw	s0,24(sp)
9d006790:	afbf0034 	sw	ra,52(sp)
9d006794:	afb5002c 	sw	s5,44(sp)
9d006798:	afb30024 	sw	s3,36(sp)
9d00679c:	00a08821 	move	s1,a1
	WORD wGetReadyCount;
	WORD RightLen = 0;

	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
9d0067a0:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d0067a4:	30d0ffff 	andi	s0,a2,0xffff
9d0067a8:	0040a021 	move	s4,v0
	if(wGetReadyCount == 0u)
		return 0x0000u;
9d0067ac:	0000b021 	move	s6,zero
	WORD wGetReadyCount;
	WORD RightLen = 0;

	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
	if(wGetReadyCount == 0u)
9d0067b0:	1280003f 	beqz	s4,9d0068b0 <TCPGetArray+0x140>
9d0067b4:	02401021 	move	v0,s2
	// Make sure we don't try to read more data than is available
	if(len > wGetReadyCount)
		len = wGetReadyCount;

	// See if we need a two part get
	if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd)
9d0067b8:	00121900 	sll	v1,s2,0x4
9d0067bc:	00122980 	sll	a1,s2,0x6
9d0067c0:	3c15a000 	lui	s5,0xa000
9d0067c4:	00a32023 	subu	a0,a1,v1
9d0067c8:	26b54700 	addiu	s5,s5,18176
9d0067cc:	02a42021 	addu	a0,s5,a0
9d0067d0:	8c860018 	lw	a2,24(a0)
	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
	if(wGetReadyCount == 0u)
		return 0x0000u;

	SyncTCBStub(hTCP);
9d0067d4:	0214402b 	sltu	t0,s0,s4
9d0067d8:	02809821 	move	s3,s4
	// Make sure we don't try to read more data than is available
	if(len > wGetReadyCount)
		len = wGetReadyCount;

	// See if we need a two part get
	if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd)
9d0067dc:	8c870008 	lw	a3,8(a0)
9d0067e0:	0208980b 	movn	s3,s0,t0
9d0067e4:	02664021 	addu	t0,s3,a2
9d0067e8:	00e8402b 	sltu	t0,a3,t0
	// See if there is any data which can be read
	wGetReadyCount = TCPIsGetReady(hTCP);
	if(wGetReadyCount == 0u)
		return 0x0000u;

	SyncTCBStub(hTCP);
9d0067ec:	a3928023 	sb	s2,-32733(gp)
	// Make sure we don't try to read more data than is available
	if(len > wGetReadyCount)
		len = wGetReadyCount;

	// See if we need a two part get
	if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd)
9d0067f0:	1100003a 	beqz	t0,9d0068dc <TCPGetArray+0x16c>
9d0067f4:	02608021 	move	s0,s3
	{
		RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1;
9d0067f8:	24f20001 	addiu	s2,a3,1
9d0067fc:	02469023 	subu	s2,s2,a2
		if(buffer)
9d006800:	12200008 	beqz	s1,9d006824 <TCPGetArray+0xb4>
9d006804:	3252ffff 	andi	s2,s2,0xffff
		{
			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen);
9d006808:	9087002c 	lbu	a3,44(a0)
9d00680c:	24050001 	li	a1,1
9d006810:	02202021 	move	a0,s1
9d006814:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006818:	afb20010 	sw	s2,16(sp)
			buffer += RightLen;
9d00681c:	93828023 	lbu	v0,-32733(gp)
9d006820:	02328821 	addu	s1,s1,s2
		}
		len -= RightLen;
		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9d006824:	00021900 	sll	v1,v0,0x4
9d006828:	00021180 	sll	v0,v0,0x6
9d00682c:	00432023 	subu	a0,v0,v1
9d006830:	02a42021 	addu	a0,s5,a0
9d006834:	8c860004 	lw	a2,4(a0)
		if(buffer)
		{
			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen);
			buffer += RightLen;
		}
		len -= RightLen;
9d006838:	02729823 	subu	s3,s3,s2
9d00683c:	3270ffff 	andi	s0,s3,0xffff
		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9d006840:	ac860018 	sw	a2,24(a0)
	}

	if(buffer)
9d006844:	1220000d 	beqz	s1,9d00687c <TCPGetArray+0x10c>
9d006848:	02202021 	move	a0,s1
		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len);
9d00684c:	00431023 	subu	v0,v0,v1
9d006850:	02a21021 	addu	v0,s5,v0
9d006854:	9047002c 	lbu	a3,44(v0)
9d006858:	24050001 	li	a1,1
9d00685c:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006860:	afb00010 	sw	s0,16(sp)
9d006864:	93828023 	lbu	v0,-32733(gp)
9d006868:	00021900 	sll	v1,v0,0x4
9d00686c:	00021180 	sll	v0,v0,0x6
9d006870:	00432023 	subu	a0,v0,v1
9d006874:	02a42021 	addu	a0,s5,a0
9d006878:	8c860018 	lw	a2,24(a0)
	MyTCBStub.rxTail += len;
	len += RightLen;
9d00687c:	02509021 	addu	s2,s2,s0
9d006880:	3256ffff 	andi	s6,s2,0xffff
		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	}

	if(buffer)
		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len);
	MyTCBStub.rxTail += len;
9d006884:	00431023 	subu	v0,v0,v1
	len += RightLen;

	// Send a window update if we've run low on data
	if(wGetReadyCount - len <= len)
9d006888:	0296a023 	subu	s4,s4,s6
		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
	}

	if(buffer)
		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len);
	MyTCBStub.rxTail += len;
9d00688c:	02a2a821 	addu	s5,s5,v0
9d006890:	00d08021 	addu	s0,a2,s0
	len += RightLen;

	// Send a window update if we've run low on data
	if(wGetReadyCount - len <= len)
9d006894:	02d4a02a 	slt	s4,s6,s4
9d006898:	12800013 	beqz	s4,9d0068e8 <TCPGetArray+0x178>
9d00689c:	aeb00018 	sw	s0,24(s5)
	{
		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
	}
	else if(!MyTCBStub.Flags.bTimer2Enabled)
9d0068a0:	8ea20028 	lw	v0,40(s5)
9d0068a4:	7c430140 	ext	v1,v0,0x5,0x1
9d0068a8:	1060001e 	beqz	v1,9d006924 <TCPGetArray+0x1b4>
9d0068ac:	24030001 	li	v1,1
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
	}

	return len;
}
9d0068b0:	8fbf0034 	lw	ra,52(sp)
9d0068b4:	02c01021 	move	v0,s6
9d0068b8:	8fb60030 	lw	s6,48(sp)
9d0068bc:	8fb5002c 	lw	s5,44(sp)
9d0068c0:	8fb40028 	lw	s4,40(sp)
9d0068c4:	8fb30024 	lw	s3,36(sp)
9d0068c8:	8fb20020 	lw	s2,32(sp)
9d0068cc:	8fb1001c 	lw	s1,28(sp)
9d0068d0:	8fb00018 	lw	s0,24(sp)
9d0068d4:	03e00008 	jr	ra
9d0068d8:	27bd0038 	addiu	sp,sp,56
	RX FIFO buffer became empty or the socket is not conected.
  ***************************************************************************/
WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
{
	WORD wGetReadyCount;
	WORD RightLen = 0;
9d0068dc:	00009021 	move	s2,zero
9d0068e0:	0b401a11 	j	9d006844 <TCPGetArray+0xd4>
9d0068e4:	00a01021 	move	v0,a1
	len += RightLen;

	// Send a window update if we've run low on data
	if(wGetReadyCount - len <= len)
	{
		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9d0068e8:	8ea20028 	lw	v0,40(s5)
9d0068ec:	24030001 	li	v1,1
9d0068f0:	7c625284 	ins	v0,v1,0xa,0x1
9d0068f4:	aea20028 	sw	v0,40(s5)
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
	}

	return len;
}
9d0068f8:	8fbf0034 	lw	ra,52(sp)
9d0068fc:	02c01021 	move	v0,s6
9d006900:	8fb60030 	lw	s6,48(sp)
9d006904:	8fb5002c 	lw	s5,44(sp)
9d006908:	8fb40028 	lw	s4,40(sp)
9d00690c:	8fb30024 	lw	s3,36(sp)
9d006910:	8fb20020 	lw	s2,32(sp)
9d006914:	8fb1001c 	lw	s1,28(sp)
9d006918:	8fb00018 	lw	s0,24(sp)
9d00691c:	03e00008 	jr	ra
9d006920:	27bd0038 	addiu	sp,sp,56
	}
	else if(!MyTCBStub.Flags.bTimer2Enabled)
	// If not already enabled, start a timer so a window 
	// update will get sent to the remote node at some point
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9d006924:	7c622944 	ins	v0,v1,0x5,0x1
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9d006928:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d00692c:	aea20028 	sw	v0,40(s5)
	}

	return len;
}
9d006930:	8fbf0034 	lw	ra,52(sp)
	else if(!MyTCBStub.Flags.bTimer2Enabled)
	// If not already enabled, start a timer so a window 
	// update will get sent to the remote node at some point
	{
		MyTCBStub.Flags.bTimer2Enabled = TRUE;
		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9d006934:	244200f4 	addiu	v0,v0,244
9d006938:	a6a20020 	sh	v0,32(s5)
	}

	return len;
}
9d00693c:	8fb40028 	lw	s4,40(sp)
9d006940:	02c01021 	move	v0,s6
9d006944:	8fb60030 	lw	s6,48(sp)
9d006948:	8fb5002c 	lw	s5,44(sp)
9d00694c:	8fb30024 	lw	s3,36(sp)
9d006950:	8fb20020 	lw	s2,32(sp)
9d006954:	8fb1001c 	lw	s1,28(sp)
9d006958:	8fb00018 	lw	s0,24(sp)
9d00695c:	03e00008 	jr	ra
9d006960:	27bd0038 	addiu	sp,sp,56

9d006964 <TCPPeekArray>:

  Remarks:
  	None
  ***************************************************************************/
WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart)
{
9d006964:	27bdffd0 	addiu	sp,sp,-48
9d006968:	afb00018 	sw	s0,24(sp)
9d00696c:	30d0ffff 	andi	s0,a2,0xffff
9d006970:	afb40028 	sw	s4,40(sp)
9d006974:	afb1001c 	sw	s1,28(sp)
9d006978:	afbf002c 	sw	ra,44(sp)
9d00697c:	afb30024 	sw	s3,36(sp)
9d006980:	afb20020 	sw	s2,32(sp)
9d006984:	00a08821 	move	s1,a1
9d006988:	308200ff 	andi	v0,a0,0xff
	PTR_BASE ptrRead;
	WORD w;
	WORD wBytesUntilWrap;

	if(wLen == 0u)
9d00698c:	1600000a 	bnez	s0,9d0069b8 <TCPPeekArray+0x54>
9d006990:	30f4ffff 	andi	s4,a3,0xffff
		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap);
		TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap);
	}
	
	return wLen;
}
9d006994:	8fbf002c 	lw	ra,44(sp)
9d006998:	02001021 	move	v0,s0
9d00699c:	8fb40028 	lw	s4,40(sp)
9d0069a0:	8fb30024 	lw	s3,36(sp)
9d0069a4:	8fb20020 	lw	s2,32(sp)
9d0069a8:	8fb1001c 	lw	s1,28(sp)
9d0069ac:	8fb00018 	lw	s0,24(sp)
9d0069b0:	03e00008 	jr	ra
9d0069b4:	27bd0030 	addiu	sp,sp,48

	SyncTCBStub(hTCP);

	// Find out how many bytes are in the RX FIFO and decrease read length 
	// if the start offset + read length is beyond the end of the FIFO
	w = TCPIsGetReady(hTCP);
9d0069b8:	00402021 	move	a0,v0
9d0069bc:	0f401954 	jal	9d006550 <TCPIsGetReady>
9d0069c0:	a3828023 	sb	v0,-32733(gp)
	if(wStart + wLen > w)
9d0069c4:	02901821 	addu	v1,s4,s0
9d0069c8:	0043182a 	slt	v1,v0,v1
9d0069cc:	10600003 	beqz	v1,9d0069dc <TCPPeekArray+0x78>
9d0069d0:	93848023 	lbu	a0,-32733(gp)
		wLen = w - wStart;
9d0069d4:	00548023 	subu	s0,v0,s4
9d0069d8:	3210ffff 	andi	s0,s0,0xffff

	// Find the read start location
	ptrRead = MyTCBStub.rxTail + wStart;
9d0069dc:	3c13a000 	lui	s3,0xa000
9d0069e0:	26734700 	addiu	s3,s3,18176
9d0069e4:	00041900 	sll	v1,a0,0x4
9d0069e8:	00042180 	sll	a0,a0,0x6
9d0069ec:	00831023 	subu	v0,a0,v1
9d0069f0:	02621021 	addu	v0,s3,v0
9d0069f4:	8c460018 	lw	a2,24(v0)
	if(ptrRead > MyTCBStub.bufferEnd)
9d0069f8:	8c520008 	lw	s2,8(v0)
	w = TCPIsGetReady(hTCP);
	if(wStart + wLen > w)
		wLen = w - wStart;

	// Find the read start location
	ptrRead = MyTCBStub.rxTail + wStart;
9d0069fc:	02863021 	addu	a2,s4,a2
	if(ptrRead > MyTCBStub.bufferEnd)
9d006a00:	0246282b 	sltu	a1,s2,a2
9d006a04:	54a00023 	bnezl	a1,9d006a94 <TCPPeekArray+0x130>
9d006a08:	8c420004 	lw	v0,4(v0)
		ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;

	// Calculate how many bytes can be read in a single go
	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1;
9d006a0c:	26520001 	addiu	s2,s2,1
9d006a10:	02469023 	subu	s2,s2,a2
9d006a14:	3252ffff 	andi	s2,s2,0xffff
	if(wLen <= wBytesUntilWrap)
9d006a18:	0250102b 	sltu	v0,s2,s0
9d006a1c:	10400026 	beqz	v0,9d006ab8 <TCPPeekArray+0x154>
9d006a20:	00831823 	subu	v1,a0,v1
	}
	else
	{
		// Read all bytes up to the wrap position and then read remaining bytes 
		// at the start of the buffer
		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap);
9d006a24:	02631821 	addu	v1,s3,v1
9d006a28:	9067002c 	lbu	a3,44(v1)
9d006a2c:	02202021 	move	a0,s1
9d006a30:	24050001 	li	a1,1
9d006a34:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006a38:	afb20010 	sw	s2,16(sp)
		TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap);
9d006a3c:	93838023 	lbu	v1,-32733(gp)
9d006a40:	02121023 	subu	v0,s0,s2
9d006a44:	3042ffff 	andi	v0,v0,0xffff
9d006a48:	00032100 	sll	a0,v1,0x4
9d006a4c:	00031980 	sll	v1,v1,0x6
9d006a50:	00641823 	subu	v1,v1,a0
9d006a54:	02639821 	addu	s3,s3,v1
9d006a58:	8e660004 	lw	a2,4(s3)
9d006a5c:	9267002c 	lbu	a3,44(s3)
9d006a60:	02322021 	addu	a0,s1,s2
9d006a64:	24050001 	li	a1,1
9d006a68:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006a6c:	afa20010 	sw	v0,16(sp)
	}
	
	return wLen;
}
9d006a70:	8fbf002c 	lw	ra,44(sp)
9d006a74:	02001021 	move	v0,s0
9d006a78:	8fb40028 	lw	s4,40(sp)
9d006a7c:	8fb30024 	lw	s3,36(sp)
9d006a80:	8fb20020 	lw	s2,32(sp)
9d006a84:	8fb1001c 	lw	s1,28(sp)
9d006a88:	8fb00018 	lw	s0,24(sp)
9d006a8c:	03e00008 	jr	ra
9d006a90:	27bd0030 	addiu	sp,sp,48
		wLen = w - wStart;

	// Find the read start location
	ptrRead = MyTCBStub.rxTail + wStart;
	if(ptrRead > MyTCBStub.bufferEnd)
		ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9d006a94:	02421023 	subu	v0,s2,v0
9d006a98:	00021027 	nor	v0,zero,v0
9d006a9c:	00c23021 	addu	a2,a2,v0

	// Calculate how many bytes can be read in a single go
	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1;
9d006aa0:	26520001 	addiu	s2,s2,1
9d006aa4:	02469023 	subu	s2,s2,a2
9d006aa8:	3252ffff 	andi	s2,s2,0xffff
	if(wLen <= wBytesUntilWrap)
9d006aac:	0250102b 	sltu	v0,s2,s0
9d006ab0:	1440ffdc 	bnez	v0,9d006a24 <TCPPeekArray+0xc0>
9d006ab4:	00831823 	subu	v1,a0,v1
	{
		// Read all at once
		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen);
9d006ab8:	02639821 	addu	s3,s3,v1
9d006abc:	9267002c 	lbu	a3,44(s3)
9d006ac0:	02202021 	move	a0,s1
9d006ac4:	24050001 	li	a1,1
9d006ac8:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006acc:	afb00010 	sw	s0,16(sp)
		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap);
		TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap);
	}
	
	return wLen;
}
9d006ad0:	8fbf002c 	lw	ra,44(sp)
9d006ad4:	02001021 	move	v0,s0
9d006ad8:	8fb40028 	lw	s4,40(sp)
9d006adc:	8fb30024 	lw	s3,36(sp)
9d006ae0:	8fb20020 	lw	s2,32(sp)
9d006ae4:	8fb1001c 	lw	s1,28(sp)
9d006ae8:	8fb00018 	lw	s0,24(sp)
9d006aec:	03e00008 	jr	ra
9d006af0:	27bd0030 	addiu	sp,sp,48

9d006af4 <TCPPeek>:
  Remarks:
  	Use the TCPPeekArray() function to read more than one byte.  It will 
  	perform better than calling TCPPeek() in a loop.
  ***************************************************************************/
BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
{
9d006af4:	27bdffe0 	addiu	sp,sp,-32
9d006af8:	30a7ffff 	andi	a3,a1,0xffff
	BYTE i;
	
	TCPPeekArray(hTCP, &i, 1, wStart);
9d006afc:	308400ff 	andi	a0,a0,0xff
9d006b00:	27a50010 	addiu	a1,sp,16
  Remarks:
  	Use the TCPPeekArray() function to read more than one byte.  It will 
  	perform better than calling TCPPeek() in a loop.
  ***************************************************************************/
BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
{
9d006b04:	afbf001c 	sw	ra,28(sp)
	BYTE i;
	
	TCPPeekArray(hTCP, &i, 1, wStart);
9d006b08:	0f401a59 	jal	9d006964 <TCPPeekArray>
9d006b0c:	24060001 	li	a2,1
	return i;
}
9d006b10:	8fbf001c 	lw	ra,28(sp)
9d006b14:	93a20010 	lbu	v0,16(sp)
9d006b18:	03e00008 	jr	ra
9d006b1c:	27bd0020 	addiu	sp,sp,32

9d006b20 <TCPTick>:

  Returns:
	None
  ***************************************************************************/
void TCPTick(void)
{
9d006b20:	27bdffa8 	addiu	sp,sp,-88
9d006b24:	afbe0050 	sw	s8,80(sp)
9d006b28:	afb7004c 	sw	s7,76(sp)
9d006b2c:	afb50044 	sw	s5,68(sp)
9d006b30:	afb40040 	sw	s4,64(sp)
9d006b34:	afb10034 	sw	s1,52(sp)
						// before continuing.  If not, break and leave this in the queue
						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
							break;
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9d006b38:	3c14a000 	lui	s4,0xa000
9d006b3c:	3c1ea000 	lui	s8,0xa000
9d006b40:	3c11a000 	lui	s1,0xa000
		// Load up extended TCB information
		SyncTCB();

		// A timeout has occured.  Respond to this timeout condition
		// depending on what state this socket is in.
		switch(MyTCBStub.smState)
9d006b44:	3c159d01 	lui	s5,0x9d01

				// Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
				if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
				{
					MyTCB.retryCount = TCP_MAX_RETRIES - 1;
					MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1);
9d006b48:	3c17004c 	lui	s7,0x4c

  Returns:
	None
  ***************************************************************************/
void TCPTick(void)
{
9d006b4c:	afb60048 	sw	s6,72(sp)
9d006b50:	afb3003c 	sw	s3,60(sp)
9d006b54:	afbf0054 	sw	ra,84(sp)
9d006b58:	afb20038 	sw	s2,56(sp)
9d006b5c:	afb00030 	sw	s0,48(sp)
9d006b60:	00001821 	move	v1,zero
9d006b64:	27de4700 	addiu	s8,s8,18176
9d006b68:	2631490c 	addiu	s1,s1,18700
			}
		}

		// Process listening server sockets that might have a SYN waiting in the SYNQueue[]
		#if TCP_SYN_QUEUE_MAX_ENTRIES
			if(MyTCBStub.smState == TCP_LISTEN)
9d006b6c:	3c13a000 	lui	s3,0xa000
		// Load up extended TCB information
		SyncTCB();

		// A timeout has occured.  Respond to this timeout condition
		// depending on what state this socket is in.
		switch(MyTCBStub.smState)
9d006b70:	26b5dc90 	addiu	s5,s5,-9072
				// caller must detect it and do something.
				vFlags = SYN;
				bRetransmit = TRUE;

				// Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
				if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
9d006b74:	0280b021 	move	s6,s4
				{
					MyTCB.retryCount = TCP_MAX_RETRIES - 1;
					MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1);
9d006b78:	26f74b40 	addiu	s7,s7,19264
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;

		// Transmit ASAP data if the medium is available
		if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
9d006b7c:	00031100 	sll	v0,v1,0x4
9d006b80:	00032180 	sll	a0,v1,0x6
9d006b84:	00822823 	subu	a1,a0,v0
9d006b88:	03c52821 	addu	a1,s8,a1
9d006b8c:	8ca50028 	lw	a1,40(a1)
9d006b90:	7ca60240 	ext	a2,a1,0x9,0x1
9d006b94:	14c000c1 	bnez	a2,9d006e9c <TCPTick+0x37c>
9d006b98:	a3838023 	sb	v1,-32733(gp)
9d006b9c:	7ca50280 	ext	a1,a1,0xa,0x1
9d006ba0:	14a000be 	bnez	a1,9d006e9c <TCPTick+0x37c>
9d006ba4:	00008021 	move	s0,zero
				SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage);
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
9d006ba8:	00009021 	move	s2,zero
				bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
			}
		}

		// Perform any needed window updates and data transmissions
		if(MyTCBStub.Flags.bTimer2Enabled)
9d006bac:	00822823 	subu	a1,a0,v0
9d006bb0:	03c52821 	addu	a1,s8,a1
9d006bb4:	8ca60028 	lw	a2,40(a1)
9d006bb8:	7cc60140 	ext	a2,a2,0x5,0x1
9d006bbc:	54c000c6 	bnezl	a2,9d006ed8 <TCPTick+0x3b8>
9d006bc0:	94a40020 	lhu	a0,32(a1)
			if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0)
				vFlags = ACK;
		}

		// Process Delayed ACKnowledgement timer
		if(MyTCBStub.Flags.bDelayedACKTimerEnabled)
9d006bc4:	00822823 	subu	a1,a0,v0
9d006bc8:	03c52821 	addu	a1,s8,a1
9d006bcc:	8ca60028 	lw	a2,40(a1)
9d006bd0:	7cc60180 	ext	a2,a2,0x6,0x1
9d006bd4:	54c000d2 	bnezl	a2,9d006f20 <TCPTick+0x400>
9d006bd8:	94a40022 	lhu	a0,34(a1)
			if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0)
				vFlags = ACK;
		}
		
		// Process TCP_CLOSE_WAIT timer
		if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9d006bdc:	00823023 	subu	a2,a0,v0
9d006be0:	03c63021 	addu	a2,s8,a2
9d006be4:	8cc50024 	lw	a1,36(a2)
9d006be8:	2407000b 	li	a3,11
9d006bec:	50a700de 	beql	a1,a3,9d006f68 <TCPTick+0x448>
9d006bf0:	94c40022 	lhu	a0,34(a2)
			}
		}

		// Process listening server sockets that might have a SYN waiting in the SYNQueue[]
		#if TCP_SYN_QUEUE_MAX_ENTRIES
			if(MyTCBStub.smState == TCP_LISTEN)
9d006bf4:	24060004 	li	a2,4
9d006bf8:	10a60047 	beq	a1,a2,9d006d18 <TCPTick+0x1f8>
9d006bfc:	00824823 	subu	t1,a0,v0
					}
				}
			}
		#endif

		if(vFlags)
9d006c00:	56000055 	bnezl	s0,9d006d58 <TCPTick+0x238>
9d006c04:	02002021 	move	a0,s0
			SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);

		// The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED 
		// state don't need any timeout events, so see if the timer is enabled
		if(!MyTCBStub.Flags.bTimerEnabled)
9d006c08:	00821023 	subu	v0,a0,v0
9d006c0c:	03c21021 	addu	v0,s8,v0
9d006c10:	8c440028 	lw	a0,40(v0)
9d006c14:	7c840100 	ext	a0,a0,0x4,0x1
9d006c18:	1480005b 	bnez	a0,9d006d88 <TCPTick+0x268>
9d006c1c:	00000000 	nop
		{
			#if defined(TCP_KEEP_ALIVE_TIMEOUT)
				// Only the established state has any use for keep-alives
				if(MyTCBStub.smState == TCP_ESTABLISHED)
9d006c20:	8c440024 	lw	a0,36(v0)
9d006c24:	24020007 	li	v0,7
9d006c28:	108200ec 	beq	a0,v0,9d006fdc <TCPTick+0x4bc>
9d006c2c:	00000000 	nop
				SendTCP(vFlags, SENDTCP_RESET_TIMERS);

		}
		
		if(bCloseSocket)
			CloseSocket();
9d006c30:	24630001 	addiu	v1,v1,1
	BOOL bCloseSocket;
	BYTE vFlags;
	WORD w;

	// Periodically all "not closed" sockets must perform timed operations
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9d006c34:	2402000a 	li	v0,10
9d006c38:	1462ffd1 	bne	v1,v0,9d006b80 <TCPTick+0x60>
9d006c3c:	00031100 	sll	v0,v1,0x4
9d006c40:	00009021 	move	s2,zero
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		// Process SYN Queue entry timeouts
		for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
		{
			// Abort search if there are no more valid records
			if(SYNQueue[w].wDestPort == 0u)
9d006c44:	0b401b17 	j	9d006c5c <TCPTick+0x13c>
9d006c48:	02208021 	move	s0,s1
	}
	
	
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		// Process SYN Queue entry timeouts
		for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9d006c4c:	3252ffff 	andi	s2,s2,0xffff
9d006c50:	2e420003 	sltiu	v0,s2,3
9d006c54:	10400025 	beqz	v0,9d006cec <TCPTick+0x1cc>
9d006c58:	8fbf0054 	lw	ra,84(sp)
		{
			// Abort search if there are no more valid records
			if(SYNQueue[w].wDestPort == 0u)
9d006c5c:	00121100 	sll	v0,s2,0x4
9d006c60:	0012a080 	sll	s4,s2,0x2
9d006c64:	0282a021 	addu	s4,s4,v0
9d006c68:	02349821 	addu	s3,s1,s4
9d006c6c:	96620010 	lhu	v0,16(s3)
9d006c70:	1040001e 	beqz	v0,9d006cec <TCPTick+0x1cc>
9d006c74:	8fbf0054 	lw	ra,84(sp)
				break;
			
			// See if this SYN has timed out
			if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
9d006c78:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d006c7c:	00000000 	nop
9d006c80:	96630012 	lhu	v1,18(s3)
9d006c84:	3042ffff 	andi	v0,v0,0xffff
9d006c88:	00431823 	subu	v1,v0,v1
9d006c8c:	28630e4f 	slti	v1,v1,3663
9d006c90:	5460ffee 	bnezl	v1,9d006c4c <TCPTick+0x12c>
9d006c94:	26520001 	addiu	s2,s2,1
			{
				// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
				TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d006c98:	26420001 	addiu	v0,s2,1
				SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
	
				// Since we deleted an entry, we need to roll back one 
				// index so next loop will process the correct record
				w--;	
9d006c9c:	2652ffff 	addiu	s2,s2,-1
			
			// See if this SYN has timed out
			if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
			{
				// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
				TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d006ca0:	00023080 	sll	a2,v0,0x2
9d006ca4:	0014a023 	negu	s4,s4
9d006ca8:	00021100 	sll	v0,v0,0x4
				SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
	
				// Since we deleted an entry, we need to roll back one 
				// index so next loop will process the correct record
				w--;	
9d006cac:	3252ffff 	andi	s2,s2,0xffff
			
			// See if this SYN has timed out
			if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
			{
				// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
				TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d006cb0:	00c23021 	addu	a2,a2,v0
	}
	
	
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		// Process SYN Queue entry timeouts
		for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9d006cb4:	26520001 	addiu	s2,s2,1
			
			// See if this SYN has timed out
			if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
			{
				// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
				TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d006cb8:	26820028 	addiu	v0,s4,40
9d006cbc:	3042ffff 	andi	v0,v0,0xffff
9d006cc0:	02602021 	move	a0,s3
9d006cc4:	24050001 	li	a1,1
9d006cc8:	02063021 	addu	a2,s0,a2
9d006ccc:	24070001 	li	a3,1
	}
	
	
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		// Process SYN Queue entry timeouts
		for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9d006cd0:	3252ffff 	andi	s2,s2,0xffff
			
			// See if this SYN has timed out
			if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
			{
				// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
				TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d006cd4:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d006cd8:	afa20010 	sw	v0,16(sp)
	}
	
	
	#if TCP_SYN_QUEUE_MAX_ENTRIES
		// Process SYN Queue entry timeouts
		for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9d006cdc:	2e420003 	sltiu	v0,s2,3
9d006ce0:	1440ffde 	bnez	v0,9d006c5c <TCPTick+0x13c>
9d006ce4:	a6000038 	sh	zero,56(s0)
				// index so next loop will process the correct record
				w--;	
			}
		}
	#endif
}
9d006ce8:	8fbf0054 	lw	ra,84(sp)
9d006cec:	8fbe0050 	lw	s8,80(sp)
9d006cf0:	8fb7004c 	lw	s7,76(sp)
9d006cf4:	8fb60048 	lw	s6,72(sp)
9d006cf8:	8fb50044 	lw	s5,68(sp)
9d006cfc:	8fb40040 	lw	s4,64(sp)
9d006d00:	8fb3003c 	lw	s3,60(sp)
9d006d04:	8fb20038 	lw	s2,56(sp)
9d006d08:	8fb10034 	lw	s1,52(sp)
9d006d0c:	8fb00030 	lw	s0,48(sp)
9d006d10:	03e00008 	jr	ra
9d006d14:	27bd0058 	addiu	sp,sp,88
			}
		}

		// Process listening server sockets that might have a SYN waiting in the SYNQueue[]
		#if TCP_SYN_QUEUE_MAX_ENTRIES
			if(MyTCBStub.smState == TCP_LISTEN)
9d006d18:	2666491c 	addiu	a2,s3,18716
9d006d1c:	00002821 	move	a1,zero
					
					// Stop searching if this SYN queue entry can be used by this socket
					#if defined(STACK_USE_SSL_SERVER)
					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead)
					#else
					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val)
9d006d20:	03c94821 	addu	t1,s8,t1

		// Process listening server sockets that might have a SYN waiting in the SYNQueue[]
		#if TCP_SYN_QUEUE_MAX_ENTRIES
			if(MyTCBStub.smState == TCP_LISTEN)
			{
				for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9d006d24:	240a0003 	li	t2,3
				{
					// Abort search if there are no more valid records
					if(SYNQueue[w].wDestPort == 0u)
9d006d28:	94c70000 	lhu	a3,0(a2)
9d006d2c:	10e0ffb4 	beqz	a3,9d006c00 <TCPTick+0xe0>
9d006d30:	30abffff 	andi	t3,a1,0xffff
					
					// Stop searching if this SYN queue entry can be used by this socket
					#if defined(STACK_USE_SSL_SERVER)
					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead)
					#else
					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val)
9d006d34:	9528002a 	lhu	t0,42(t1)
9d006d38:	510700f1 	beql	t0,a3,9d007100 <TCPTick+0x5e0>
9d006d3c:	afa30028 	sw	v1,40(sp)
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
						SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9d006d40:	24a50001 	addiu	a1,a1,1

		// Process listening server sockets that might have a SYN waiting in the SYNQueue[]
		#if TCP_SYN_QUEUE_MAX_ENTRIES
			if(MyTCBStub.smState == TCP_LISTEN)
			{
				for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9d006d44:	14aafff8 	bne	a1,t2,9d006d28 <TCPTick+0x208>
9d006d48:	24c60014 	addiu	a2,a2,20
					}
				}
			}
		#endif

		if(vFlags)
9d006d4c:	1200ffaf 	beqz	s0,9d006c0c <TCPTick+0xec>
9d006d50:	00821023 	subu	v0,a0,v0
9d006d54:	02002021 	move	a0,s0
			SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
9d006d58:	3a450001 	xori	a1,s2,0x1
9d006d5c:	0f401444 	jal	9d005110 <SendTCP>
9d006d60:	afa30028 	sw	v1,40(sp)
9d006d64:	93848023 	lbu	a0,-32733(gp)
9d006d68:	00041100 	sll	v0,a0,0x4
9d006d6c:	00042180 	sll	a0,a0,0x6

		// The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED 
		// state don't need any timeout events, so see if the timer is enabled
		if(!MyTCBStub.Flags.bTimerEnabled)
9d006d70:	00821023 	subu	v0,a0,v0
9d006d74:	03c21021 	addu	v0,s8,v0
9d006d78:	8c440028 	lw	a0,40(v0)
9d006d7c:	7c840100 	ext	a0,a0,0x4,0x1
9d006d80:	1080ffa7 	beqz	a0,9d006c20 <TCPTick+0x100>
9d006d84:	8fa30028 	lw	v1,40(sp)
			#endif
			continue;
		}

		// If timeout has not occured, do not do anything.
		if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
9d006d88:	0f400b53 	jal	9d002d4c <TickGet>
9d006d8c:	afa30028 	sw	v1,40(sp)
9d006d90:	93848023 	lbu	a0,-32733(gp)
9d006d94:	00042900 	sll	a1,a0,0x4
9d006d98:	00042180 	sll	a0,a0,0x6
9d006d9c:	00852023 	subu	a0,a0,a1
9d006da0:	03c42021 	addu	a0,s8,a0
9d006da4:	8c84001c 	lw	a0,28(a0)
9d006da8:	00441023 	subu	v0,v0,a0
9d006dac:	0440ffa0 	bltz	v0,9d006c30 <TCPTick+0x110>
9d006db0:	8fa30028 	lw	v1,40(sp)
			continue;

		// Load up extended TCB information
		SyncTCB();
9d006db4:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d006db8:	00000000 	nop

		// A timeout has occured.  Respond to this timeout condition
		// depending on what state this socket is in.
		switch(MyTCBStub.smState)
9d006dbc:	93858023 	lbu	a1,-32733(gp)
9d006dc0:	00052100 	sll	a0,a1,0x4
9d006dc4:	00053180 	sll	a2,a1,0x6
9d006dc8:	00c41023 	subu	v0,a2,a0
9d006dcc:	03c21021 	addu	v0,s8,v0
9d006dd0:	8c420024 	lw	v0,36(v0)
9d006dd4:	2c47000d 	sltiu	a3,v0,13
9d006dd8:	14e0007b 	bnez	a3,9d006fc8 <TCPTick+0x4a8>
9d006ddc:	8fa30028 	lw	v1,40(sp)
			
			default:
				break;
		}

		if(vFlags)
9d006de0:	5200ff94 	beqzl	s0,9d006c34 <TCPTick+0x114>
9d006de4:	24630001 	addiu	v1,v1,1
9d006de8:	02002021 	move	a0,s0
9d006dec:	00008021 	move	s0,zero
		{
			// Transmit all unacknowledged data over again
			if(bRetransmit)
9d006df0:	124000b6 	beqz	s2,9d0070cc <TCPTick+0x5ac>
9d006df4:	24050001 	li	a1,1
9d006df8:	93858023 	lbu	a1,-32733(gp)
9d006dfc:	3c08a000 	lui	t0,0xa000
9d006e00:	268248e0 	addiu	v0,s4,18656
				// Set the appropriate retry time
				MyTCB.retryCount++;
				MyTCB.retryInterval <<= 1;
		
				// Calculate how many bytes we have to roll back and retransmit
				w = MyTCB.txUnackedTail - MyTCBStub.txTail;
9d006e04:	00053100 	sll	a2,a1,0x4
9d006e08:	00052980 	sll	a1,a1,0x6
9d006e0c:	00a62823 	subu	a1,a1,a2
9d006e10:	03c52821 	addu	a1,s8,a1
		{
			// Transmit all unacknowledged data over again
			if(bRetransmit)
			{
				// Set the appropriate retry time
				MyTCB.retryCount++;
9d006e14:	904b002a 	lbu	t3,42(v0)
				MyTCB.retryInterval <<= 1;
9d006e18:	8d0a48e0 	lw	t2,18656(t0)
		
				// Calculate how many bytes we have to roll back and retransmit
				w = MyTCB.txUnackedTail - MyTCBStub.txTail;
9d006e1c:	8c49000c 	lw	t1,12(v0)
9d006e20:	8ca60010 	lw	a2,16(a1)
		{
			// Transmit all unacknowledged data over again
			if(bRetransmit)
			{
				// Set the appropriate retry time
				MyTCB.retryCount++;
9d006e24:	256b0001 	addiu	t3,t3,1
				MyTCB.retryInterval <<= 1;
9d006e28:	000a5040 	sll	t2,t2,0x1
		
				// Calculate how many bytes we have to roll back and retransmit
				w = MyTCB.txUnackedTail - MyTCBStub.txTail;
9d006e2c:	01263823 	subu	a3,t1,a2
				if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9d006e30:	0126482b 	sltu	t1,t1,a2
		{
			// Transmit all unacknowledged data over again
			if(bRetransmit)
			{
				// Set the appropriate retry time
				MyTCB.retryCount++;
9d006e34:	a04b002a 	sb	t3,42(v0)
				MyTCB.retryInterval <<= 1;
9d006e38:	ad0a48e0 	sw	t2,18656(t0)
		
				// Calculate how many bytes we have to roll back and retransmit
				w = MyTCB.txUnackedTail - MyTCBStub.txTail;
				if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9d006e3c:	11200006 	beqz	t1,9d006e58 <TCPTick+0x338>
9d006e40:	30e7ffff 	andi	a3,a3,0xffff
					w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9d006e44:	8ca80000 	lw	t0,0(a1)
9d006e48:	8ca50004 	lw	a1,4(a1)
9d006e4c:	00e83823 	subu	a3,a3,t0
9d006e50:	00e53821 	addu	a3,a3,a1
9d006e54:	30e7ffff 	andi	a3,a3,0xffff
				
				// Perform roll back of local SEQuence counter, remote window 
				// adjustment, and cause all unacknowledged data to be 
				// retransmitted by moving the unacked tail pointer.
				MyTCB.MySEQ -= w;
				MyTCB.remoteWindow += w;
9d006e58:	94450014 	lhu	a1,20(v0)
					w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
				
				// Perform roll back of local SEQuence counter, remote window 
				// adjustment, and cause all unacknowledged data to be 
				// retransmitted by moving the unacked tail pointer.
				MyTCB.MySEQ -= w;
9d006e5c:	8c480004 	lw	t0,4(v0)
				MyTCB.remoteWindow += w;
				MyTCB.txUnackedTail = MyTCBStub.txTail;		
9d006e60:	ac46000c 	sw	a2,12(v0)
					w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
				
				// Perform roll back of local SEQuence counter, remote window 
				// adjustment, and cause all unacknowledged data to be 
				// retransmitted by moving the unacked tail pointer.
				MyTCB.MySEQ -= w;
9d006e64:	01074023 	subu	t0,t0,a3
				MyTCB.remoteWindow += w;
9d006e68:	00e53821 	addu	a3,a3,a1
					w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
				
				// Perform roll back of local SEQuence counter, remote window 
				// adjustment, and cause all unacknowledged data to be 
				// retransmitted by moving the unacked tail pointer.
				MyTCB.MySEQ -= w;
9d006e6c:	ac480004 	sw	t0,4(v0)
				MyTCB.remoteWindow += w;
9d006e70:	a4470014 	sh	a3,20(v0)
				MyTCB.txUnackedTail = MyTCBStub.txTail;		
				SendTCP(vFlags, 0);
9d006e74:	00002821 	move	a1,zero
9d006e78:	0f401444 	jal	9d005110 <SendTCP>
9d006e7c:	afa30028 	sw	v1,40(sp)
9d006e80:	8fa30028 	lw	v1,40(sp)
			else
				SendTCP(vFlags, SENDTCP_RESET_TIMERS);

		}
		
		if(bCloseSocket)
9d006e84:	5200ff6b 	beqzl	s0,9d006c34 <TCPTick+0x114>
9d006e88:	24630001 	addiu	v1,v1,1
			CloseSocket();
9d006e8c:	0f40164c 	jal	9d005930 <CloseSocket>
9d006e90:	afa30028 	sw	v1,40(sp)
9d006e94:	0b401b0c 	j	9d006c30 <TCPTick+0x110>
9d006e98:	8fa30028 	lw	v1,40(sp)
		bCloseSocket = FALSE;

		// Transmit ASAP data if the medium is available
		if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
		{
			if(MACIsTxReady())
9d006e9c:	0f400cf1 	jal	9d0033c4 <MACIsTxReady>
9d006ea0:	afa30028 	sw	v1,40(sp)
9d006ea4:	1440003f 	bnez	v0,9d006fa4 <TCPTick+0x484>
9d006ea8:	8fa30028 	lw	v1,40(sp)
9d006eac:	93848023 	lbu	a0,-32733(gp)
			if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE)
				SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage);
		}
		#endif
		
		vFlags = 0x00;
9d006eb0:	00008021 	move	s0,zero
9d006eb4:	00041100 	sll	v0,a0,0x4
9d006eb8:	00042180 	sll	a0,a0,0x6
				bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
			}
		}

		// Perform any needed window updates and data transmissions
		if(MyTCBStub.Flags.bTimer2Enabled)
9d006ebc:	00822823 	subu	a1,a0,v0
9d006ec0:	03c52821 	addu	a1,s8,a1
9d006ec4:	8ca60028 	lw	a2,40(a1)
9d006ec8:	7cc60140 	ext	a2,a2,0x5,0x1
9d006ecc:	10c0ff3d 	beqz	a2,9d006bc4 <TCPTick+0xa4>
9d006ed0:	00009021 	move	s2,zero
		{
			// See if the timeout has occured, and we need to send a new window update and pending data
			if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0)
9d006ed4:	94a40020 	lhu	a0,32(a1)
9d006ed8:	afa30028 	sw	v1,40(sp)
9d006edc:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d006ee0:	afa40024 	sw	a0,36(sp)
9d006ee4:	8fa40024 	lw	a0,36(sp)
9d006ee8:	00822023 	subu	a0,a0,v0
9d006eec:	7c042620 	seh	a0,a0
9d006ef0:	18800060 	blez	a0,9d007074 <TCPTick+0x554>
9d006ef4:	8fa30028 	lw	v1,40(sp)
9d006ef8:	93848023 	lbu	a0,-32733(gp)
9d006efc:	00041100 	sll	v0,a0,0x4
9d006f00:	00042180 	sll	a0,a0,0x6
				vFlags = ACK;
		}

		// Process Delayed ACKnowledgement timer
		if(MyTCBStub.Flags.bDelayedACKTimerEnabled)
9d006f04:	00822823 	subu	a1,a0,v0
9d006f08:	03c52821 	addu	a1,s8,a1
9d006f0c:	8ca60028 	lw	a2,40(a1)
9d006f10:	7cc60180 	ext	a2,a2,0x6,0x1
9d006f14:	10c0ff32 	beqz	a2,9d006be0 <TCPTick+0xc0>
9d006f18:	00823023 	subu	a2,a0,v0
		{
			// See if the timeout has occured and delayed ACK needs to be sent
			if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0)
9d006f1c:	94a40022 	lhu	a0,34(a1)
9d006f20:	afa30028 	sw	v1,40(sp)
9d006f24:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d006f28:	afa40024 	sw	a0,36(sp)
9d006f2c:	8fa40024 	lw	a0,36(sp)
9d006f30:	00822023 	subu	a0,a0,v0
9d006f34:	7c042620 	seh	a0,a0
9d006f38:	18800049 	blez	a0,9d007060 <TCPTick+0x540>
9d006f3c:	8fa30028 	lw	v1,40(sp)
9d006f40:	93848023 	lbu	a0,-32733(gp)
				vFlags = ACK;
		}
		
		// Process TCP_CLOSE_WAIT timer
		if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9d006f44:	2407000b 	li	a3,11
9d006f48:	00041100 	sll	v0,a0,0x4
9d006f4c:	00042180 	sll	a0,a0,0x6
9d006f50:	00823023 	subu	a2,a0,v0
9d006f54:	03c63021 	addu	a2,s8,a2
9d006f58:	8cc50024 	lw	a1,36(a2)
9d006f5c:	54a7ff26 	bnel	a1,a3,9d006bf8 <TCPTick+0xd8>
9d006f60:	24060004 	li	a2,4
		{
			// Automatically close the socket on our end if the application 
			// fails to call TCPDisconnect() is a reasonable amount of time.
			if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0)
9d006f64:	94c40022 	lhu	a0,34(a2)
9d006f68:	afa30028 	sw	v1,40(sp)
9d006f6c:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d006f70:	afa40024 	sw	a0,36(sp)
9d006f74:	8fa40024 	lw	a0,36(sp)
9d006f78:	00822023 	subu	a0,a0,v0
9d006f7c:	7c042620 	seh	a0,a0
9d006f80:	18800056 	blez	a0,9d0070dc <TCPTick+0x5bc>
9d006f84:	8fa30028 	lw	v1,40(sp)
9d006f88:	93848023 	lbu	a0,-32733(gp)
9d006f8c:	00041100 	sll	v0,a0,0x4
9d006f90:	00042180 	sll	a0,a0,0x6
9d006f94:	00822823 	subu	a1,a0,v0
9d006f98:	03c52821 	addu	a1,s8,a1
9d006f9c:	0b401afd 	j	9d006bf4 <TCPTick+0xd4>
9d006fa0:	8ca50024 	lw	a1,36(a1)
		if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
		{
			if(MACIsTxReady())
			{
				vFlags = ACK;
				bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
9d006fa4:	93848023 	lbu	a0,-32733(gp)
		// Transmit ASAP data if the medium is available
		if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
		{
			if(MACIsTxReady())
			{
				vFlags = ACK;
9d006fa8:	24100010 	li	s0,16
				bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
9d006fac:	00041100 	sll	v0,a0,0x4
9d006fb0:	00042180 	sll	a0,a0,0x6
9d006fb4:	00822823 	subu	a1,a0,v0
9d006fb8:	03c52821 	addu	a1,s8,a1
9d006fbc:	8cb20028 	lw	s2,40(a1)
9d006fc0:	0b401aeb 	j	9d006bac <TCPTick+0x8c>
9d006fc4:	7e520280 	ext	s2,s2,0xa,0x1
		// Load up extended TCB information
		SyncTCB();

		// A timeout has occured.  Respond to this timeout condition
		// depending on what state this socket is in.
		switch(MyTCBStub.smState)
9d006fc8:	00021080 	sll	v0,v0,0x2
9d006fcc:	02a21021 	addu	v0,s5,v0
9d006fd0:	8c420000 	lw	v0,0(v0)
9d006fd4:	00400008 	jr	v0
9d006fd8:	00000000 	nop
			#if defined(TCP_KEEP_ALIVE_TIMEOUT)
				// Only the established state has any use for keep-alives
				if(MyTCBStub.smState == TCP_ESTABLISHED)
				{
					// If timeout has not occured, do not do anything.
					if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
9d006fdc:	0f400b53 	jal	9d002d4c <TickGet>
9d006fe0:	afa30028 	sw	v1,40(sp)
9d006fe4:	93848023 	lbu	a0,-32733(gp)
9d006fe8:	00042900 	sll	a1,a0,0x4
9d006fec:	00042180 	sll	a0,a0,0x6
9d006ff0:	00852023 	subu	a0,a0,a1
9d006ff4:	03c42021 	addu	a0,s8,a0
9d006ff8:	8c85001c 	lw	a1,28(a0)
9d006ffc:	00451023 	subu	v0,v0,a1
9d007000:	0440ff0b 	bltz	v0,9d006c30 <TCPTick+0x110>
9d007004:	8fa30028 	lw	v1,40(sp)
		
					// If timeout has occured and the connection appears to be dead (no 
					// responses from remote node at all), close the connection so the 
					// application doesn't sit around indefinitely with a useless socket 
					// that it thinks is still open
					if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES)
9d007008:	8c900028 	lw	s0,40(a0)
9d00700c:	24020006 	li	v0,6
9d007010:	32040007 	andi	a0,s0,0x7
9d007014:	108200f8 	beq	a0,v0,9d0073f8 <TCPTick+0x8d8>
9d007018:	00000000 	nop
						
						continue;
					}
					
					// Otherwise, if a timeout occured, simply send a keep-alive packet
					SyncTCB();
9d00701c:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d007020:	afa30028 	sw	v1,40(sp)
					SendTCP(ACK, SENDTCP_KEEP_ALIVE);
9d007024:	24040010 	li	a0,16
9d007028:	0f401444 	jal	9d005110 <SendTCP>
9d00702c:	24050002 	li	a1,2
					MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d007030:	0f400b53 	jal	9d002d4c <TickGet>
9d007034:	93908023 	lbu	s0,-32733(gp)
9d007038:	8fa30028 	lw	v1,40(sp)
9d00703c:	00102100 	sll	a0,s0,0x4
9d007040:	00108180 	sll	s0,s0,0x6
9d007044:	02048023 	subu	s0,s0,a0
9d007048:	3c04002f 	lui	a0,0x2f
9d00704c:	3484af08 	ori	a0,a0,0xaf08
9d007050:	03d08021 	addu	s0,s8,s0
9d007054:	00441021 	addu	v0,v0,a0
9d007058:	0b401b0c 	j	9d006c30 <TCPTick+0x110>
9d00705c:	ae02001c 	sw	v0,28(s0)

		// Process Delayed ACKnowledgement timer
		if(MyTCBStub.Flags.bDelayedACKTimerEnabled)
		{
			// See if the timeout has occured and delayed ACK needs to be sent
			if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0)
9d007060:	93848023 	lbu	a0,-32733(gp)
				vFlags = ACK;
9d007064:	24100010 	li	s0,16
9d007068:	00041100 	sll	v0,a0,0x4
9d00706c:	0b401af7 	j	9d006bdc <TCPTick+0xbc>
9d007070:	00042180 	sll	a0,a0,0x6

		// Perform any needed window updates and data transmissions
		if(MyTCBStub.Flags.bTimer2Enabled)
		{
			// See if the timeout has occured, and we need to send a new window update and pending data
			if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0)
9d007074:	93848023 	lbu	a0,-32733(gp)
				vFlags = ACK;
9d007078:	24100010 	li	s0,16
9d00707c:	00041100 	sll	v0,a0,0x4
9d007080:	0b401af1 	j	9d006bc4 <TCPTick+0xa4>
9d007084:	00042180 	sll	a0,a0,0x6
//				break;
//			

			case TCP_LAST_ACK:
				// Send some more FINs or close anyway
				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9d007088:	268248e0 	addiu	v0,s4,18656
9d00708c:	9044002a 	lbu	a0,42(v0)
9d007090:	2c840005 	sltiu	a0,a0,5
9d007094:	10800009 	beqz	a0,9d0070bc <TCPTick+0x59c>
9d007098:	3c08a000 	lui	t0,0xa000
9d00709c:	24040011 	li	a0,17
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;
9d0070a0:	0b401b81 	j	9d006e04 <TCPTick+0x2e4>
9d0070a4:	00008021 	move	s0,zero
				vFlags = RST | ACK;
				bCloseSocket = TRUE;
				break;

			case TCP_CLOSING:
				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9d0070a8:	268248e0 	addiu	v0,s4,18656
9d0070ac:	9044002a 	lbu	a0,42(v0)
9d0070b0:	2c840005 	sltiu	a0,a0,5
9d0070b4:	1480007f 	bnez	a0,9d0072b4 <TCPTick+0x794>
9d0070b8:	3c08a000 	lui	t0,0xa000
//				break;
//			

			case TCP_LAST_ACK:
				// Send some more FINs or close anyway
				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9d0070bc:	24040014 	li	a0,20
		}

		if(vFlags)
		{
			// Transmit all unacknowledged data over again
			if(bRetransmit)
9d0070c0:	1640ff4d 	bnez	s2,9d006df8 <TCPTick+0x2d8>
9d0070c4:	24100001 	li	s0,1
				MyTCB.remoteWindow += w;
				MyTCB.txUnackedTail = MyTCBStub.txTail;		
				SendTCP(vFlags, 0);
			}
			else
				SendTCP(vFlags, SENDTCP_RESET_TIMERS);
9d0070c8:	24050001 	li	a1,1
9d0070cc:	0f401444 	jal	9d005110 <SendTCP>
9d0070d0:	afa30028 	sw	v1,40(sp)
9d0070d4:	0b401ba1 	j	9d006e84 <TCPTick+0x364>
9d0070d8:	8fa30028 	lw	v1,40(sp)
			// Automatically close the socket on our end if the application 
			// fails to call TCPDisconnect() is a reasonable amount of time.
			if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0)
			{
				vFlags = FIN | ACK;
				MyTCBStub.smState = TCP_LAST_ACK;
9d0070dc:	93828023 	lbu	v0,-32733(gp)
		{
			// Automatically close the socket on our end if the application 
			// fails to call TCPDisconnect() is a reasonable amount of time.
			if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0)
			{
				vFlags = FIN | ACK;
9d0070e0:	24100011 	li	s0,17
				MyTCBStub.smState = TCP_LAST_ACK;
9d0070e4:	00022100 	sll	a0,v0,0x4
9d0070e8:	00021180 	sll	v0,v0,0x6
9d0070ec:	00441023 	subu	v0,v0,a0
9d0070f0:	03c21021 	addu	v0,s8,v0
9d0070f4:	2404000c 	li	a0,12
9d0070f8:	0b401b55 	j	9d006d54 <TCPTick+0x234>
9d0070fc:	ac440024 	sw	a0,36(v0)
					#else
					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val)
					#endif
					{
						// Set up our socket and generate a reponse SYN+ACK packet
						SyncTCB();
9d007100:	afa50024 	sw	a1,36(sp)
9d007104:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d007108:	afab0020 	sw	t3,32(sp)
						// before continuing.  If not, break and leave this in the queue
						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
							break;
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9d00710c:	8fa50024 	lw	a1,36(sp)
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d007110:	8fab0020 	lw	t3,32(sp)
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d007114:	93868023 	lbu	a2,-32733(gp)
						// before continuing.  If not, break and leave this in the queue
						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
							break;
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9d007118:	00051080 	sll	v0,a1,0x2
9d00711c:	00052900 	sll	a1,a1,0x4
9d007120:	00452821 	addu	a1,v0,a1
9d007124:	02252821 	addu	a1,s1,a1
9d007128:	8ca80000 	lw	t0,0(a1)
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
9d00712c:	94aa000a 	lhu	t2,10(a1)
						// before continuing.  If not, break and leave this in the queue
						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
							break;
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9d007130:	268248e0 	addiu	v0,s4,18656
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
9d007134:	8cad000c 	lw	t5,12(a1)
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d007138:	000b3880 	sll	a3,t3,0x2
9d00713c:	000b2100 	sll	a0,t3,0x4
						// before continuing.  If not, break and leave this in the queue
						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
							break;
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9d007140:	8caf0004 	lw	t7,4(a1)
9d007144:	94ae0008 	lhu	t6,8(a1)
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d007148:	00e42021 	addu	a0,a3,a0
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d00714c:	00086402 	srl	t4,t0,0x10
9d007150:	94470012 	lhu	a3,18(v0)
9d007154:	00068180 	sll	s0,a2,0x6
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d007158:	256b0001 	addiu	t3,t3,1
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d00715c:	00064900 	sll	t1,a2,0x4
9d007160:	014c6021 	addu	t4,t2,t4
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d007164:	00042823 	negu	a1,a0
9d007168:	000b3080 	sll	a2,t3,0x2
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d00716c:	02094823 	subu	t1,s0,t1
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d007170:	000b5900 	sll	t3,t3,0x4
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d007174:	01886021 	addu	t4,t4,t0
							break;
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
9d007178:	25ad0001 	addiu	t5,t5,1
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d00717c:	013e4821 	addu	t1,t1,s8
9d007180:	01876026 	xor	t4,t4,a3
						// before continuing.  If not, break and leave this in the queue
						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
							break;
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9d007184:	ac480018 	sw	t0,24(v0)
9d007188:	ac4f001c 	sw	t7,28(v0)
9d00718c:	a44e0020 	sh	t6,32(v0)
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
9d007190:	a44a0010 	sh	t2,16(v0)
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
9d007194:	ac4d0008 	sw	t5,8(v0)
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d007198:	00cb3021 	addu	a2,a2,t3
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
9d00719c:	24020006 	li	v0,6
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d0071a0:	24ab0028 	addiu	t3,a1,40
9d0071a4:	316bffff 	andi	t3,t3,0xffff
9d0071a8:	02242021 	addu	a0,s1,a0
						#endif
						
						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d0071ac:	a52c002a 	sh	t4,42(t1)
						vFlags = SYN | ACK;
						MyTCBStub.smState = TCP_SYN_RECEIVED;
9d0071b0:	ad220024 	sw	v0,36(t1)
						
						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9d0071b4:	24050001 	li	a1,1
9d0071b8:	02263021 	addu	a2,s1,a2
9d0071bc:	24070001 	li	a3,1
9d0071c0:	afab0010 	sw	t3,16(sp)
9d0071c4:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d0071c8:	24100012 	li	s0,18
						SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9d0071cc:	a6200038 	sh	zero,56(s1)
9d0071d0:	24040012 	li	a0,18
9d0071d4:	0b401b56 	j	9d006d58 <TCPTick+0x238>
9d0071d8:	8fa30028 	lw	v1,40(sp)
		switch(MyTCBStub.smState)
		{
			#if defined(STACK_CLIENT_MODE)
			#if defined(STACK_USE_DNS)
			case TCP_GET_DNS_MODULE:
				if(DNSBeginUsage())
9d0071dc:	0f400fe6 	jal	9d003f98 <DNSBeginUsage>
9d0071e0:	afa30028 	sw	v1,40(sp)
9d0071e4:	1040fefe 	beqz	v0,9d006de0 <TCPTick+0x2c0>
9d0071e8:	8fa30028 	lw	v1,40(sp)
				{
					MyTCBStub.smState = TCP_DNS_RESOLVE;
9d0071ec:	93828023 	lbu	v0,-32733(gp)
					if(MyTCB.flags.bRemoteHostIsROM)
9d0071f0:	268448e0 	addiu	a0,s4,18656
9d0071f4:	8c860024 	lw	a2,36(a0)
			#if defined(STACK_CLIENT_MODE)
			#if defined(STACK_USE_DNS)
			case TCP_GET_DNS_MODULE:
				if(DNSBeginUsage())
				{
					MyTCBStub.smState = TCP_DNS_RESOLVE;
9d0071f8:	00022900 	sll	a1,v0,0x4
9d0071fc:	00021180 	sll	v0,v0,0x6
9d007200:	00452823 	subu	a1,v0,a1
9d007204:	03c52821 	addu	a1,s8,a1
					if(MyTCB.flags.bRemoteHostIsROM)
9d007208:	7cc20480 	ext	v0,a2,0x12,0x1
			#if defined(STACK_CLIENT_MODE)
			#if defined(STACK_USE_DNS)
			case TCP_GET_DNS_MODULE:
				if(DNSBeginUsage())
				{
					MyTCBStub.smState = TCP_DNS_RESOLVE;
9d00720c:	24060001 	li	a2,1
					if(MyTCB.flags.bRemoteHostIsROM)
9d007210:	1040008c 	beqz	v0,9d007444 <TCPTick+0x924>
9d007214:	aca60024 	sw	a2,36(a1)
						DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
9d007218:	8c840018 	lw	a0,24(a0)
9d00721c:	0f401001 	jal	9d004004 <DNSResolve>
9d007220:	24050001 	li	a1,1
			
			default:
				break;
		}

		if(vFlags)
9d007224:	1200fe82 	beqz	s0,9d006c30 <TCPTick+0x110>
9d007228:	8fa30028 	lw	v1,40(sp)
9d00722c:	0b401b7b 	j	9d006dec <TCPTick+0x2cc>
9d007230:	02002021 	move	a0,s0
				// MyTCB.remote.dwRemoteHost is unioned with 
				// MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write 
				// the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We 
				// must copy it over only if the DNS is resolution step was 
				// successful.
				if(DNSIsResolved(&ipResolvedDNSIP))
9d007234:	27a40018 	addiu	a0,sp,24
9d007238:	0f401021 	jal	9d004084 <DNSIsResolved>
9d00723c:	afa30028 	sw	v1,40(sp)
9d007240:	1040fee7 	beqz	v0,9d006de0 <TCPTick+0x2c0>
9d007244:	8fa30028 	lw	v1,40(sp)
				{
					if(DNSEndUsage())
9d007248:	0f400fef 	jal	9d003fbc <DNSEndUsage>
9d00724c:	00000000 	nop
9d007250:	104000a5 	beqz	v0,9d0074e8 <TCPTick+0x9c8>
9d007254:	8fa30028 	lw	v1,40(sp)
					{
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
9d007258:	8fa40018 	lw	a0,24(sp)
9d00725c:	268248e0 	addiu	v0,s4,18656
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d007260:	93858023 	lbu	a1,-32733(gp)
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d007264:	94480010 	lhu	t0,16(v0)
9d007268:	00043402 	srl	a2,a0,0x10
9d00726c:	94470012 	lhu	a3,18(v0)
				if(DNSIsResolved(&ipResolvedDNSIP))
				{
					if(DNSEndUsage())
					{
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d007270:	00054900 	sll	t1,a1,0x4
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d007274:	00863021 	addu	a2,a0,a2
				if(DNSIsResolved(&ipResolvedDNSIP))
				{
					if(DNSEndUsage())
					{
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d007278:	00052980 	sll	a1,a1,0x6
9d00727c:	00a92823 	subu	a1,a1,t1
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d007280:	00c83021 	addu	a2,a2,t0
				if(DNSIsResolved(&ipResolvedDNSIP))
				{
					if(DNSEndUsage())
					{
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d007284:	03c52821 	addu	a1,s8,a1
				// successful.
				if(DNSIsResolved(&ipResolvedDNSIP))
				{
					if(DNSEndUsage())
					{
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
9d007288:	ac440018 	sw	a0,24(v0)
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d00728c:	00c73026 	xor	a2,a2,a3
				if(DNSIsResolved(&ipResolvedDNSIP))
				{
					if(DNSEndUsage())
					{
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d007290:	24040002 	li	a0,2
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
						MyTCB.retryCount = 0;
9d007294:	a040002a 	sb	zero,42(v0)
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
9d007298:	24020131 	li	v0,305
				if(DNSIsResolved(&ipResolvedDNSIP))
				{
					if(DNSEndUsage())
					{
						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d00729c:	aca40024 	sw	a0,36(a1)
						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9d0072a0:	a4a6002a 	sh	a2,42(a1)
			
			default:
				break;
		}

		if(vFlags)
9d0072a4:	1200fe62 	beqz	s0,9d006c30 <TCPTick+0x110>
9d0072a8:	ae8248e0 	sw	v0,18656(s4)
9d0072ac:	0b401b7b 	j	9d006dec <TCPTick+0x2cc>
9d0072b0:	02002021 	move	a0,s0
				break;
	
			case TCP_ESTABLISHED:
			case TCP_CLOSE_WAIT:
				// Retransmit any unacknowledged data
				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9d0072b4:	24040010 	li	a0,16
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;
9d0072b8:	0b401b81 	j	9d006e04 <TCPTick+0x2e4>
9d0072bc:	00008021 	move	s0,zero
				break;
	
			case TCP_ESTABLISHED:
			case TCP_CLOSE_WAIT:
				// Retransmit any unacknowledged data
				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9d0072c0:	268248e0 	addiu	v0,s4,18656
9d0072c4:	9047002a 	lbu	a3,42(v0)
9d0072c8:	2ce70005 	sltiu	a3,a3,5
9d0072cc:	14e0fff9 	bnez	a3,9d0072b4 <TCPTick+0x794>
9d0072d0:	3c08a000 	lui	t0,0xa000
				else
				{
					// No response back for too long, close connection
					// This could happen, for instance, if the communication 
					// medium was lost
					MyTCBStub.smState = TCP_FIN_WAIT_1;
9d0072d4:	00c42023 	subu	a0,a2,a0
9d0072d8:	03c42021 	addu	a0,s8,a0
9d0072dc:	24020008 	li	v0,8
9d0072e0:	ac820024 	sw	v0,36(a0)
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;
9d0072e4:	00008021 	move	s0,zero
				else
				{
					// No response back for too long, close connection
					// This could happen, for instance, if the communication 
					// medium was lost
					MyTCBStub.smState = TCP_FIN_WAIT_1;
9d0072e8:	0b401b7c 	j	9d006df0 <TCPTick+0x2d0>
9d0072ec:	24040011 	li	a0,17
			}
			#endif // #if defined(STACK_USE_DNS)
				
			case TCP_GATEWAY_SEND_ARP:
				// Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine)
				MyTCBStub.eventTime2 = (WORD)TickGetDiv256();
9d0072f0:	afa30028 	sw	v1,40(sp)
9d0072f4:	afa40024 	sw	a0,36(sp)
9d0072f8:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d0072fc:	afa60020 	sw	a2,32(sp)
9d007300:	8fa40024 	lw	a0,36(sp)
9d007304:	8fa60020 	lw	a2,32(sp)
9d007308:	00c43023 	subu	a2,a2,a0
9d00730c:	03c63021 	addu	a2,s8,a2
				ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr);
9d007310:	3c04a000 	lui	a0,0xa000
9d007314:	248448f8 	addiu	a0,a0,18680
9d007318:	0f400eb9 	jal	9d003ae4 <ARPResolve>
9d00731c:	a4c20020 	sh	v0,32(a2)
				MyTCBStub.smState = TCP_GATEWAY_GET_ARP;
9d007320:	93858023 	lbu	a1,-32733(gp)
9d007324:	24040003 	li	a0,3
				break;
9d007328:	8fa30028 	lw	v1,40(sp)
				
			case TCP_GATEWAY_SEND_ARP:
				// Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine)
				MyTCBStub.eventTime2 = (WORD)TickGetDiv256();
				ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr);
				MyTCBStub.smState = TCP_GATEWAY_GET_ARP;
9d00732c:	00051100 	sll	v0,a1,0x4
9d007330:	00052980 	sll	a1,a1,0x6
9d007334:	00a21023 	subu	v0,a1,v0
9d007338:	03c21021 	addu	v0,s8,v0
			
			default:
				break;
		}

		if(vFlags)
9d00733c:	1200fe3c 	beqz	s0,9d006c30 <TCPTick+0x110>
9d007340:	ac440024 	sw	a0,36(v0)
9d007344:	0b401b7b 	j	9d006dec <TCPTick+0x2cc>
9d007348:	02002021 	move	a0,s0
				MyTCBStub.smState = TCP_GATEWAY_GET_ARP;
				break;

			case TCP_GATEWAY_GET_ARP:
				// Wait for the MAC address to finish being obtained
				if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr))
9d00734c:	3c04a000 	lui	a0,0xa000
9d007350:	3c05a000 	lui	a1,0xa000
9d007354:	248448f8 	addiu	a0,a0,18680
9d007358:	24a548fc 	addiu	a1,a1,18684
9d00735c:	0f400e57 	jal	9d00395c <ARPIsResolved>
9d007360:	afa30028 	sw	v1,40(sp)
9d007364:	1040003f 	beqz	v0,9d007464 <TCPTick+0x944>
9d007368:	8fa30028 	lw	v1,40(sp)
				// Send out SYN connection request to remote node
				// This automatically disables the Timer from 
				// continuously firing for this socket
				vFlags = SYN;
				bRetransmit = FALSE;
				MyTCBStub.smState = TCP_SYN_SENT;
9d00736c:	93828023 	lbu	v0,-32733(gp)
				break;
9d007370:	24040002 	li	a0,2
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;
9d007374:	00008021 	move	s0,zero
				// Send out SYN connection request to remote node
				// This automatically disables the Timer from 
				// continuously firing for this socket
				vFlags = SYN;
				bRetransmit = FALSE;
				MyTCBStub.smState = TCP_SYN_SENT;
9d007378:	00022900 	sll	a1,v0,0x4
9d00737c:	00021180 	sll	v0,v0,0x6
9d007380:	00451023 	subu	v0,v0,a1
9d007384:	03c21021 	addu	v0,s8,v0
9d007388:	24050005 	li	a1,5
				break;
9d00738c:	0b401c32 	j	9d0070c8 <TCPTick+0x5a8>
9d007390:	ac450024 	sw	a1,36(v0)
				// caller must detect it and do something.
				vFlags = SYN;
				bRetransmit = TRUE;

				// Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
				if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
9d007394:	268248e0 	addiu	v0,s4,18656
9d007398:	9044002a 	lbu	a0,42(v0)
9d00739c:	2c840004 	sltiu	a0,a0,4
9d0073a0:	14800025 	bnez	a0,9d007438 <TCPTick+0x918>
9d0073a4:	3c08a000 	lui	t0,0xa000
				{
					MyTCB.retryCount = TCP_MAX_RETRIES - 1;
9d0073a8:	24040004 	li	a0,4
9d0073ac:	a044002a 	sb	a0,42(v0)
					MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1);
9d0073b0:	aed748e0 	sw	s7,18656(s6)
9d0073b4:	24040002 	li	a0,2
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;
9d0073b8:	0b401b81 	j	9d006e04 <TCPTick+0x2e4>
9d0073bc:	00008021 	move	s0,zero
	
			case TCP_SYN_RECEIVED:
				// We must receive ACK before timeout expires.
				// If not, resend SYN+ACK.
				// Abort, if maximum attempts counts are reached.
				if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES)
9d0073c0:	268248e0 	addiu	v0,s4,18656
9d0073c4:	9047002a 	lbu	a3,42(v0)
9d0073c8:	2ce70002 	sltiu	a3,a3,2
9d0073cc:	14e00043 	bnez	a3,9d0074dc <TCPTick+0x9bc>
9d0073d0:	3c08a000 	lui	t0,0xa000
					vFlags = SYN | ACK;
					bRetransmit = TRUE;
				}
				else
				{
					if(MyTCBStub.Flags.bServer)
9d0073d4:	00c42023 	subu	a0,a2,a0
9d0073d8:	03c42021 	addu	a0,s8,a0
9d0073dc:	8c900028 	lw	s0,40(a0)
9d0073e0:	24020002 	li	v0,2
9d0073e4:	24040014 	li	a0,20
9d0073e8:	7e1000c0 	ext	s0,s0,0x3,0x1
9d0073ec:	0050200a 	movz	a0,v0,s0
9d0073f0:	0b401b7c 	j	9d006df0 <TCPTick+0x2d0>
9d0073f4:	0010802b 	sltu	s0,zero,s0
						vFlags = MyTCBStub.Flags.bServer;

						// Force an immediate FIN and RST transmission
						// Double calling TCPDisconnect() will also place us 
						// back in the listening state immediately if a server socket.
						TCPDisconnect(hTCP);
9d0073f8:	0f40179a 	jal	9d005e68 <TCPDisconnect>
9d0073fc:	00602021 	move	a0,v1
						TCPDisconnect(hTCP);
9d007400:	8fa30028 	lw	v1,40(sp)
					// responses from remote node at all), close the connection so the 
					// application doesn't sit around indefinitely with a useless socket 
					// that it thinks is still open
					if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES)
					{
						vFlags = MyTCBStub.Flags.bServer;
9d007404:	7e1000c0 	ext	s0,s0,0x3,0x1

						// Force an immediate FIN and RST transmission
						// Double calling TCPDisconnect() will also place us 
						// back in the listening state immediately if a server socket.
						TCPDisconnect(hTCP);
						TCPDisconnect(hTCP);
9d007408:	0f40179a 	jal	9d005e68 <TCPDisconnect>
9d00740c:	00602021 	move	a0,v1
						
						// Prevent client mode sockets from getting reused by other applications.  
						// The application must call TCPDisconnect() with the handle to free this 
						// socket (and the handle associated with it)
						if(!vFlags)
9d007410:	1600fe07 	bnez	s0,9d006c30 <TCPTick+0x110>
9d007414:	8fa30028 	lw	v1,40(sp)
							MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED;
9d007418:	93828023 	lbu	v0,-32733(gp)
9d00741c:	00022100 	sll	a0,v0,0x4
9d007420:	00021180 	sll	v0,v0,0x6
9d007424:	00441023 	subu	v0,v0,a0
9d007428:	03c21021 	addu	v0,s8,v0
9d00742c:	2404000e 	li	a0,14
9d007430:	0b401b0c 	j	9d006c30 <TCPTick+0x110>
9d007434:	ac440024 	sw	a0,36(v0)
				// caller must detect it and do something.
				vFlags = SYN;
				bRetransmit = TRUE;

				// Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
				if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
9d007438:	24040002 	li	a0,2
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;
9d00743c:	0b401b81 	j	9d006e04 <TCPTick+0x2e4>
9d007440:	00008021 	move	s0,zero
				{
					MyTCBStub.smState = TCP_DNS_RESOLVE;
					if(MyTCB.flags.bRemoteHostIsROM)
						DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
					else
						DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
9d007444:	8c840018 	lw	a0,24(a0)
9d007448:	24050001 	li	a1,1
9d00744c:	0f401001 	jal	9d004004 <DNSResolve>
9d007450:	afa30028 	sw	v1,40(sp)
			
			default:
				break;
		}

		if(vFlags)
9d007454:	1200fdf6 	beqz	s0,9d006c30 <TCPTick+0x110>
9d007458:	8fa30028 	lw	v1,40(sp)
9d00745c:	0b401b7b 	j	9d006dec <TCPTick+0x2cc>
9d007460:	02002021 	move	a0,s0
				{
					// Time out if too much time is spent in this state
					// Note that this will continuously send out ARP 
					// requests for an infinite time if the Gateway 
					// never responds
					if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval)
9d007464:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d007468:	00000000 	nop
9d00746c:	93858023 	lbu	a1,-32733(gp)
9d007470:	8e8448e0 	lw	a0,18656(s4)
9d007474:	3042ffff 	andi	v0,v0,0xffff
9d007478:	00053100 	sll	a2,a1,0x4
9d00747c:	00052980 	sll	a1,a1,0x6
9d007480:	00a63823 	subu	a3,a1,a2
9d007484:	03c73821 	addu	a3,s8,a3
9d007488:	94e80020 	lhu	t0,32(a3)
9d00748c:	3087ffff 	andi	a3,a0,0xffff
9d007490:	00481023 	subu	v0,v0,t0
9d007494:	00e2102a 	slt	v0,a3,v0
9d007498:	1040fe51 	beqz	v0,9d006de0 <TCPTick+0x2c0>
9d00749c:	8fa30028 	lw	v1,40(sp)
					{
						// Exponentially increase timeout until we reach 6 attempts then stay constant
						if(MyTCB.retryCount < 6u)
9d0074a0:	268248e0 	addiu	v0,s4,18656
9d0074a4:	9047002a 	lbu	a3,42(v0)
9d0074a8:	2ce80006 	sltiu	t0,a3,6
9d0074ac:	11000005 	beqz	t0,9d0074c4 <TCPTick+0x9a4>
9d0074b0:	00a62823 	subu	a1,a1,a2
						{
							MyTCB.retryCount++;
9d0074b4:	24e70001 	addiu	a3,a3,1
							MyTCB.retryInterval <<= 1;
9d0074b8:	00042040 	sll	a0,a0,0x1
					if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval)
					{
						// Exponentially increase timeout until we reach 6 attempts then stay constant
						if(MyTCB.retryCount < 6u)
						{
							MyTCB.retryCount++;
9d0074bc:	a047002a 	sb	a3,42(v0)
							MyTCB.retryInterval <<= 1;
9d0074c0:	ae8448e0 	sw	a0,18656(s4)
						}

						// Retransmit ARP request
						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9d0074c4:	03c52821 	addu	a1,s8,a1
9d0074c8:	24020002 	li	v0,2
			
			default:
				break;
		}

		if(vFlags)
9d0074cc:	1200fdd8 	beqz	s0,9d006c30 <TCPTick+0x110>
9d0074d0:	aca20024 	sw	v0,36(a1)
9d0074d4:	0b401b7b 	j	9d006dec <TCPTick+0x2cc>
9d0074d8:	02002021 	move	a0,s0
	
			case TCP_SYN_RECEIVED:
				// We must receive ACK before timeout expires.
				// If not, resend SYN+ACK.
				// Abort, if maximum attempts counts are reached.
				if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES)
9d0074dc:	24040012 	li	a0,18
		}
		#endif
		
		vFlags = 0x00;
		bRetransmit = FALSE;
		bCloseSocket = FALSE;
9d0074e0:	0b401b81 	j	9d006e04 <TCPTick+0x2e4>
9d0074e4:	00008021 	move	s0,zero
						MyTCB.retryCount = 0;
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
					}
					else
					{
						MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND;
9d0074e8:	93868023 	lbu	a2,-32733(gp)
9d0074ec:	afa30028 	sw	v1,40(sp)
9d0074f0:	0f400b53 	jal	9d002d4c <TickGet>
9d0074f4:	afa60020 	sw	a2,32(sp)
9d0074f8:	8fa60020 	lw	a2,32(sp)
9d0074fc:	24040030 	li	a0,48
						MyTCBStub.smState = TCP_GET_DNS_MODULE;
9d007500:	93858023 	lbu	a1,-32733(gp)
						MyTCB.retryCount = 0;
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
					}
					else
					{
						MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND;
9d007504:	70c43802 	mul	a3,a2,a0
9d007508:	8fa30028 	lw	v1,40(sp)
9d00750c:	00fe3021 	addu	a2,a3,s8
9d007510:	3c07002f 	lui	a3,0x2f
9d007514:	34e7af08 	ori	a3,a3,0xaf08
9d007518:	00471021 	addu	v0,v0,a3
						MyTCBStub.smState = TCP_GET_DNS_MODULE;
9d00751c:	70a43802 	mul	a3,a1,a0
						MyTCB.retryCount = 0;
						MyTCB.retryInterval = (TICK_SECOND/4)/256;
					}
					else
					{
						MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND;
9d007520:	acc2001c 	sw	v0,28(a2)
						MyTCBStub.smState = TCP_GET_DNS_MODULE;
9d007524:	00fe2021 	addu	a0,a3,s8
			
			default:
				break;
		}

		if(vFlags)
9d007528:	1200fdc1 	beqz	s0,9d006c30 <TCPTick+0x110>
9d00752c:	ac800024 	sw	zero,36(a0)
9d007530:	0b401b7b 	j	9d006dec <TCPTick+0x2cc>
9d007534:	02002021 	move	a0,s0

9d007538 <TCPProcess>:
  Return Values:
	TRUE - the segment was properly handled.
	FALSE - otherwise
  ***************************************************************************/
BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
{
9d007538:	27bdff90 	addiu	sp,sp,-112
9d00753c:	afbf006c 	sw	ra,108(sp)
9d007540:	afb60060 	sw	s6,96(sp)
9d007544:	afb20050 	sw	s2,80(sp)
9d007548:	afb00048 	sw	s0,72(sp)
9d00754c:	afbe0068 	sw	s8,104(sp)
9d007550:	afb70064 	sw	s7,100(sp)
9d007554:	afb5005c 	sw	s5,92(sp)
9d007558:	afb40058 	sw	s4,88(sp)
9d00755c:	afb30054 	sw	s3,84(sp)
9d007560:	afb1004c 	sw	s1,76(sp)
	WORD_VAL        checksum1;
	WORD_VAL        checksum2;
	BYTE            optionsSize;

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress      = remote->IPAddr;
9d007564:	88820003 	lwl	v0,3(a0)
  Return Values:
	TRUE - the segment was properly handled.
	FALSE - otherwise
  ***************************************************************************/
BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
{
9d007568:	0080b021 	move	s6,a0
9d00756c:	30d2ffff 	andi	s2,a2,0xffff
	WORD_VAL        checksum1;
	WORD_VAL        checksum2;
	BYTE            optionsSize;

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress      = remote->IPAddr;
9d007570:	9ac20000 	lwr	v0,0(s6)
	pseudoHeader.DestAddress        = *localIP;
	pseudoHeader.Zero               = 0x0;
	pseudoHeader.Protocol           = IP_PROT_TCP;
9d007574:	24030006 	li	v1,6
	pseudoHeader.Length          	= len;

	SwapPseudoHeader(pseudoHeader);
9d007578:	02402021 	move	a0,s2
	WORD_VAL        checksum1;
	WORD_VAL        checksum2;
	BYTE            optionsSize;

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress      = remote->IPAddr;
9d00757c:	afa20018 	sw	v0,24(sp)
	pseudoHeader.DestAddress        = *localIP;
9d007580:	8ca20000 	lw	v0,0(a1)
	pseudoHeader.Zero               = 0x0;
	pseudoHeader.Protocol           = IP_PROT_TCP;
9d007584:	a3a30021 	sb	v1,33(sp)
	BYTE            optionsSize;

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress      = remote->IPAddr;
	pseudoHeader.DestAddress        = *localIP;
	pseudoHeader.Zero               = 0x0;
9d007588:	a3a00020 	sb	zero,32(sp)
	WORD_VAL        checksum2;
	BYTE            optionsSize;

	// Calculate IP pseudoheader checksum.
	pseudoHeader.SourceAddress      = remote->IPAddr;
	pseudoHeader.DestAddress        = *localIP;
9d00758c:	afa2001c 	sw	v0,28(sp)
	pseudoHeader.Zero               = 0x0;
	pseudoHeader.Protocol           = IP_PROT_TCP;
	pseudoHeader.Length          	= len;

	SwapPseudoHeader(pseudoHeader);
9d007590:	0f402604 	jal	9d009810 <swaps>
9d007594:	a7b20022 	sh	s2,34(sp)

	checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader,
9d007598:	2405000c 	li	a1,12
9d00759c:	27a40018 	addiu	a0,sp,24
9d0075a0:	0f40261b 	jal	9d00986c <CalcIPChecksum>
9d0075a4:	a7a20022 	sh	v0,34(sp)
9d0075a8:	00408021 	move	s0,v0
		sizeof(pseudoHeader));

	// Now calculate TCP packet checksum in NIC RAM - should match
	// pesudo header checksum
	checksum2.Val = CalcIPBufferChecksum(len);
9d0075ac:	02402021 	move	a0,s2
9d0075b0:	0f400e43 	jal	9d00390c <CalcIPBufferChecksum>
9d0075b4:	00108027 	nor	s0,zero,s0

	// Compare checksums.
	if(checksum1.Val != checksum2.Val)
9d0075b8:	3210ffff 	andi	s0,s0,0xffff
9d0075bc:	12020010 	beq	s0,v0,9d007600 <TCPProcess+0xc8>
9d0075c0:	00000000 	nop
//		//if(!TCPHeader.Flags.bits.flagRST)
//		//	SendTCP(RST, SENDTCP_RESET_TIMERS);
//	}

	// Finished with this packet, discard it and free the Ethernet RAM for new packets
	MACDiscardRx();
9d0075c4:	0f400d87 	jal	9d00361c <MACDiscardRx>
9d0075c8:	00000000 	nop

	return TRUE;
}
9d0075cc:	8fbf006c 	lw	ra,108(sp)
9d0075d0:	24020001 	li	v0,1
9d0075d4:	8fbe0068 	lw	s8,104(sp)
9d0075d8:	8fb70064 	lw	s7,100(sp)
9d0075dc:	8fb60060 	lw	s6,96(sp)
9d0075e0:	8fb5005c 	lw	s5,92(sp)
9d0075e4:	8fb40058 	lw	s4,88(sp)
9d0075e8:	8fb30054 	lw	s3,84(sp)
9d0075ec:	8fb20050 	lw	s2,80(sp)
9d0075f0:	8fb1004c 	lw	s1,76(sp)
9d0075f4:	8fb00048 	lw	s0,72(sp)
9d0075f8:	03e00008 	jr	ra
9d0075fc:	27bd0070 	addiu	sp,sp,112
		return TRUE;
	}
#endif

	// Retrieve TCP header.
	IPSetRxBuffer(0);
9d007600:	0f4024f1 	jal	9d0093c4 <IPSetRxBuffer>
9d007604:	00002021 	move	a0,zero
	MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
9d007608:	24050014 	li	a1,20
9d00760c:	0f400e15 	jal	9d003854 <MACGetArray>
9d007610:	27a40024 	addiu	a0,sp,36
	SwapTCPHeader(&TCPHeader);
9d007614:	0f401426 	jal	9d005098 <SwapTCPHeader>
9d007618:	27a40024 	addiu	a0,sp,36


	// Skip over options to retrieve data bytes
	optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
9d00761c:	8fb30030 	lw	s3,48(sp)
	TCP_SOCKET hTCP;
	TCP_SOCKET partialMatch;
	WORD hash;

	// Prevent connections on invalid port 0
	if(h->DestPort == 0u)
9d007620:	97a30026 	lhu	v1,38(sp)
9d007624:	1060ffe7 	beqz	v1,9d0075c4 <TCPProcess+0x8c>
9d007628:	7e731900 	ext	s3,s3,0x4,0x4
		return FALSE;

	partialMatch = INVALID_SOCKET;
	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;
9d00762c:	92c40001 	lbu	a0,1(s6)
9d007630:	92c20003 	lbu	v0,3(s6)
9d007634:	92c60000 	lbu	a2,0(s6)
9d007638:	92c50002 	lbu	a1,2(s6)
9d00763c:	00042200 	sll	a0,a0,0x8
9d007640:	00021200 	sll	v0,v0,0x8
9d007644:	00862025 	or	a0,a0,a2
9d007648:	00451025 	or	v0,v0,a1
9d00764c:	00821021 	addu	v0,a0,v0
9d007650:	97a40024 	lhu	a0,36(sp)
9d007654:	3c11a000 	lui	s1,0xa000
9d007658:	2631472a 	addiu	s1,s1,18218
9d00765c:	00441021 	addu	v0,v0,a0
9d007660:	00431026 	xor	v0,v0,v1
		{// Ignore if the hash doesn't match
			continue;
		}

		SyncTCB();
		if(	h->DestPort == MyTCB.localPort.Val &&
9d007664:	3c04a000 	lui	a0,0xa000
	// Prevent connections on invalid port 0
	if(h->DestPort == 0u)
		return FALSE;

	partialMatch = INVALID_SOCKET;
	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;
9d007668:	3042ffff 	andi	v0,v0,0xffff

	// Prevent connections on invalid port 0
	if(h->DestPort == 0u)
		return FALSE;

	partialMatch = INVALID_SOCKET;
9d00766c:	240300fe 	li	v1,254
	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;

	// Loop through all sockets looking for a socket that is expecting this 
	// packet or can handle it.
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
9d007670:	00008021 	move	s0,zero
	{
		SyncTCBStub(hTCP);

		if(MyTCBStub.smState == TCP_CLOSED)
9d007674:	2414000d 	li	s4,13
		{
			continue;
		}
		else if(MyTCBStub.smState == TCP_LISTEN)
9d007678:	241e0004 	li	s8,4
		{// Ignore if the hash doesn't match
			continue;
		}

		SyncTCB();
		if(	h->DestPort == MyTCB.localPort.Val &&
9d00767c:	248448e0 	addiu	a0,a0,18656
	partialMatch = INVALID_SOCKET;
	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;

	// Loop through all sockets looking for a socket that is expecting this 
	// packet or can handle it.
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
9d007680:	0b401da8 	j	9d0076a0 <TCPProcess+0x168>
9d007684:	2417000a 	li	s7,10
				partialMatch = hTCP;
			#endif
			
			continue;
		}
		else if(MyTCBStub.remoteHash.Val != hash)
9d007688:	50a2014f 	beql	a1,v0,9d007bc8 <TCPProcess+0x690>
9d00768c:	afa20040 	sw	v0,64(sp)
	partialMatch = INVALID_SOCKET;
	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;

	// Loop through all sockets looking for a socket that is expecting this 
	// packet or can handle it.
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
9d007690:	26100001 	addiu	s0,s0,1
9d007694:	321000ff 	andi	s0,s0,0xff
9d007698:	1217000e 	beq	s0,s7,9d0076d4 <TCPProcess+0x19c>
9d00769c:	26310030 	addiu	s1,s1,48
	{
		SyncTCBStub(hTCP);

		if(MyTCBStub.smState == TCP_CLOSED)
9d0076a0:	8e25fffa 	lw	a1,-6(s1)
9d0076a4:	10b4fffa 	beq	a1,s4,9d007690 <TCPProcess+0x158>
9d0076a8:	a3908023 	sb	s0,-32733(gp)
		{
			continue;
		}
		else if(MyTCBStub.smState == TCP_LISTEN)
9d0076ac:	54befff6 	bnel	a1,s8,9d007688 <TCPProcess+0x150>
9d0076b0:	96250000 	lhu	a1,0(s1)
		{// For listening ports, check if this is the correct port
			if(MyTCBStub.remoteHash.Val == h->DestPort)
9d0076b4:	96260000 	lhu	a2,0(s1)
9d0076b8:	97a50026 	lhu	a1,38(sp)
9d0076bc:	00c52826 	xor	a1,a2,a1
9d0076c0:	0205180a 	movz	v1,s0,a1
	partialMatch = INVALID_SOCKET;
	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;

	// Loop through all sockets looking for a socket that is expecting this 
	// packet or can handle it.
	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
9d0076c4:	26100001 	addiu	s0,s0,1
9d0076c8:	321000ff 	andi	s0,s0,0xff
9d0076cc:	1617fff4 	bne	s0,s7,9d0076a0 <TCPProcess+0x168>
9d0076d0:	26310030 	addiu	s1,s1,48

	// If there is a partial match, then a listening socket is currently 
	// available.  Set up the extended TCB with the info needed 
	// to establish a connection and return this socket to the 
	// caller.
	if(partialMatch != INVALID_SOCKET)
9d0076d4:	240400fe 	li	a0,254
9d0076d8:	506400f1 	beql	v1,a0,9d007aa0 <TCPProcess+0x568>
9d0076dc:	8fa20030 	lw	v0,48(sp)
	{
		SyncTCBStub(partialMatch);
9d0076e0:	a3838023 	sb	v1,-32733(gp)
		SyncTCB();
9d0076e4:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d0076e8:	afa20040 	sw	v0,64(sp)
		// Make sure the above check didn't fail (this is unfortunately 
		// redundant for non-SSL sockets).  Otherwise, fall out to below
		// and add to the SYN queue.
		if(partialMatch != INVALID_SOCKET)
		{
			MyTCBStub.remoteHash.Val = hash;
9d0076ec:	93858023 	lbu	a1,-32733(gp)
9d0076f0:	8fa20040 	lw	v0,64(sp)
9d0076f4:	3c14a000 	lui	s4,0xa000
9d0076f8:	00053100 	sll	a2,a1,0x4
9d0076fc:	00053980 	sll	a3,a1,0x6
9d007700:	26944700 	addiu	s4,s4,18176
9d007704:	00e64023 	subu	t0,a3,a2
9d007708:	02884021 	addu	t0,s4,t0
9d00770c:	a502002a 	sh	v0,42(t0)
		
			memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
9d007710:	8ac40003 	lwl	a0,3(s6)
9d007714:	8ac30007 	lwl	v1,7(s6)
9d007718:	3c09a000 	lui	t1,0xa000
9d00771c:	9ac40000 	lwr	a0,0(s6)
9d007720:	9ac30004 	lwr	v1,4(s6)
9d007724:	252248f8 	addiu	v0,t1,18680
9d007728:	ad2448f8 	sw	a0,18680(t1)
9d00772c:	ac430004 	sw	v1,4(v0)
9d007730:	92c30008 	lbu	v1,8(s6)
			MyTCB.remotePort.Val = h->SourcePort;
9d007734:	3c15a000 	lui	s5,0xa000
9d007738:	26b548e0 	addiu	s5,s5,18656
		// and add to the SYN queue.
		if(partialMatch != INVALID_SOCKET)
		{
			MyTCBStub.remoteHash.Val = hash;
		
			memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
9d00773c:	a0430008 	sb	v1,8(v0)
9d007740:	92c40009 	lbu	a0,9(s6)
			MyTCB.remotePort.Val = h->SourcePort;
			MyTCB.localPort.Val = h->DestPort;
			MyTCB.txUnackedTail	= MyTCBStub.bufferTxStart;
9d007744:	8d030000 	lw	v1,0(t0)
		// and add to the SYN queue.
		if(partialMatch != INVALID_SOCKET)
		{
			MyTCBStub.remoteHash.Val = hash;
		
			memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
9d007748:	a0440009 	sb	a0,9(v0)
			MyTCB.remotePort.Val = h->SourcePort;
9d00774c:	97a20024 	lhu	v0,36(sp)
			MyTCB.localPort.Val = h->DestPort;
			MyTCB.txUnackedTail	= MyTCBStub.bufferTxStart;
9d007750:	aea3000c 	sw	v1,12(s5)
		if(partialMatch != INVALID_SOCKET)
		{
			MyTCBStub.remoteHash.Val = hash;
		
			memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
			MyTCB.remotePort.Val = h->SourcePort;
9d007754:	a6a20010 	sh	v0,16(s5)
			MyTCB.localPort.Val = h->DestPort;
9d007758:	97a20026 	lhu	v0,38(sp)
9d00775c:	a6a20012 	sh	v0,18(s5)
	localAckNumber = h->AckNumber;
	localSeqNumber = h->SeqNumber;

	// We received a packet, reset the keep alive timer and count
	#if defined(TCP_KEEP_ALIVE_TIMEOUT)
		MyTCBStub.Flags.vUnackedKeepalives = 0;
9d007760:	00e6b023 	subu	s6,a3,a2
9d007764:	0296b021 	addu	s6,s4,s6
9d007768:	8ec20028 	lw	v0,40(s6)


	// Cache a few variables in local RAM.  
	// PIC18s take a fair amount of code and execution time to 
	// dereference pointers frequently.
	localHeaderFlags = h->Flags.byte;
9d00776c:	93a40031 	lbu	a0,49(sp)
	localAckNumber = h->AckNumber;
9d007770:	8fb1002c 	lw	s1,44(sp)
	localSeqNumber = h->SeqNumber;

	// We received a packet, reset the keep alive timer and count
	#if defined(TCP_KEEP_ALIVE_TIMEOUT)
		MyTCBStub.Flags.vUnackedKeepalives = 0;
9d007774:	7c021004 	ins	v0,zero,0x0,0x3
		if(!MyTCBStub.Flags.bTimerEnabled)
9d007778:	7c430100 	ext	v1,v0,0x4,0x1
	// Cache a few variables in local RAM.  
	// PIC18s take a fair amount of code and execution time to 
	// dereference pointers frequently.
	localHeaderFlags = h->Flags.byte;
	localAckNumber = h->AckNumber;
	localSeqNumber = h->SeqNumber;
9d00777c:	8fb00028 	lw	s0,40(sp)

	// We received a packet, reset the keep alive timer and count
	#if defined(TCP_KEEP_ALIVE_TIMEOUT)
		MyTCBStub.Flags.vUnackedKeepalives = 0;
		if(!MyTCBStub.Flags.bTimerEnabled)
9d007780:	10600129 	beqz	v1,9d007c28 <TCPProcess+0x6f0>
9d007784:	aec20028 	sw	v0,40(s6)

	// Handle TCP_LISTEN and TCP_SYN_SENT states
	// Both of these states will return, so code following this 
	// state machine need not check explicitly for these two 
	// states.
	switch(MyTCBStub.smState)
9d007788:	00e61023 	subu	v0,a3,a2
9d00778c:	02821021 	addu	v0,s4,v0
9d007790:	8c420024 	lw	v0,36(v0)
9d007794:	24030004 	li	v1,4
9d007798:	1043013d 	beq	v0,v1,9d007c90 <TCPProcess+0x758>
9d00779c:	24030005 	li	v1,5
9d0077a0:	10430151 	beq	v0,v1,9d007ce8 <TCPProcess+0x7b0>
9d0077a4:	00131880 	sll	v1,s3,0x2
	MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
	SwapTCPHeader(&TCPHeader);


	// Skip over options to retrieve data bytes
	optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
9d0077a8:	2463ffec 	addiu	v1,v1,-20
		sizeof(TCPHeader));
	len = len - optionsSize - sizeof(TCPHeader);
9d0077ac:	2652ffec 	addiu	s2,s2,-20
9d0077b0:	306300ff 	andi	v1,v1,0xff
9d0077b4:	0243b823 	subu	s7,s2,v1
9d0077b8:	32f7ffff 	andi	s7,s7,0xffff

	//
	// First: check the sequence number
	//
	wSegmentLength = len;
	if(localHeaderFlags & FIN)
9d0077bc:	309e0001 	andi	s8,a0,0x1
9d0077c0:	17c00116 	bnez	s8,9d007c1c <TCPProcess+0x6e4>
9d0077c4:	02e0b021 	move	s6,s7
		wSegmentLength++;
	if(localHeaderFlags & SYN)
9d0077c8:	30830002 	andi	v1,a0,0x2
9d0077cc:	10600003 	beqz	v1,9d0077dc <TCPProcess+0x2a4>
9d0077d0:	00e61823 	subu	v1,a3,a2
		wSegmentLength++;
9d0077d4:	26d60001 	addiu	s6,s6,1
9d0077d8:	32d6ffff 	andi	s6,s6,0xffff

	// Calculate the RX FIFO space
	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9d0077dc:	02831821 	addu	v1,s4,v1
9d0077e0:	8c680014 	lw	t0,20(v1)
9d0077e4:	8c690018 	lw	t1,24(v1)
9d0077e8:	0109502b 	sltu	t2,t0,t1
9d0077ec:	15400170 	bnez	t2,9d007db0 <TCPProcess+0x878>
9d0077f0:	2533ffff 	addiu	s3,t1,-1
		wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9d0077f4:	8c730008 	lw	s3,8(v1)
9d0077f8:	8c630004 	lw	v1,4(v1)
9d0077fc:	01339821 	addu	s3,t1,s3
9d007800:	02639823 	subu	s3,s3,v1
9d007804:	02689823 	subu	s3,s3,t0
9d007808:	3273ffff 	andi	s3,s3,0xffff
	else
		wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;

	// Calculate the number of bytes ahead of our head pointer this segment skips
	lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ;
9d00780c:	8ea80008 	lw	t0,8(s5)
9d007810:	02084023 	subu	t0,s0,t0
	wMissingBytes = (WORD)lMissingBytes;
	
	// Run TCP acceptability tests to verify that this packet has a valid sequence number
	bSegmentAcceptable = FALSE;
	if(wSegmentLength)
9d007814:	12c00173 	beqz	s6,9d007de4 <TCPProcess+0x8ac>
9d007818:	3103ffff 	andi	v1,t0,0xffff
	{
		// Check to see if we have free space, and if so, if any of the data falls within the freespace
		if(wFreeSpace)
9d00781c:	5260016a 	beqzl	s3,9d007dc8 <TCPProcess+0x890>
9d007820:	30840004 	andi	a0,a0,0x4
		{
			// RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
9d007824:	05000003 	bltz	t0,9d007834 <TCPProcess+0x2fc>
9d007828:	0113502b 	sltu	t2,t0,s3
9d00782c:	15400008 	bnez	t2,9d007850 <TCPProcess+0x318>
9d007830:	24090001 	li	t1,1
				bSegmentAcceptable = TRUE;
			else
			{
				// RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
				if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength)))
9d007834:	02c85021 	addu	t2,s6,t0
9d007838:	19400005 	blez	t2,9d007850 <TCPProcess+0x318>
9d00783c:	00004821 	move	t1,zero
9d007840:	02764823 	subu	t1,s3,s6
9d007844:	7c094e20 	seh	t1,t1
		// Check to see if we have free space, and if so, if any of the data falls within the freespace
		if(wFreeSpace)
		{
			// RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
				bSegmentAcceptable = TRUE;
9d007848:	0128482a 	slt	t1,t1,t0
9d00784c:	39290001 	xori	t1,t1,0x1
				// RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
				if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength)))
					bSegmentAcceptable = TRUE;
			}
			
			if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0))
9d007850:	0113402a 	slt	t0,t0,s3
9d007854:	11000159 	beqz	t0,9d007dbc <TCPProcess+0x884>
9d007858:	7c165620 	seh	t2,s6
9d00785c:	7c034620 	seh	t0,v1
9d007860:	01484021 	addu	t0,t2,t0
9d007864:	19000155 	blez	t0,9d007dbc <TCPProcess+0x884>
9d007868:	30880006 	andi	t0,a0,0x6
	//
	// Fourth: check the SYN bit
	//
	// Note, that since the third step is not implemented, we can 
	// combine this second and fourth step into a single operation.
	if(localHeaderFlags & (RST | SYN))
9d00786c:	1500014c 	bnez	t0,9d007da0 <TCPProcess+0x868>
9d007870:	30880010 	andi	t0,a0,0x10
	// Feature not supported.  Let's process this segment.

	//
	// Fifth: check the ACK bit
	//
	if(!(localHeaderFlags & ACK))
9d007874:	1100ff53 	beqz	t0,9d0075c4 <TCPProcess+0x8c>
9d007878:	2c48000c 	sltiu	t0,v0,12
		return;

	switch(MyTCBStub.smState)
9d00787c:	5100016f 	beqzl	t0,9d007e3c <TCPProcess+0x904>
9d007880:	2406000c 	li	a2,12
9d007884:	2c480007 	sltiu	t0,v0,7
9d007888:	5100017a 	beqzl	t0,9d007e74 <TCPProcess+0x93c>
9d00788c:	00e64823 	subu	t1,a3,a2
9d007890:	24080006 	li	t0,6
9d007894:	50480170 	beql	v0,t0,9d007e58 <TCPProcess+0x920>
9d007898:	8eb20004 	lw	s2,4(s5)
	//
	// Sixth: Check the URG bit
	//
	// Urgent packets are not supported in this stack, so we
	// will throw them away instead
	if(localHeaderFlags & URG)
9d00789c:	30840020 	andi	a0,a0,0x20
9d0078a0:	1480ff48 	bnez	a0,9d0075c4 <TCPProcess+0x8c>
9d0078a4:	00051100 	sll	v0,a1,0x4

	//
	// Seventh: Process the segment text
	//
	// Throw data away if in a state that doesn't accept data
	if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9d0078a8:	00052980 	sll	a1,a1,0x6
9d0078ac:	00a21023 	subu	v0,a1,v0
9d0078b0:	02821021 	addu	v0,s4,v0
9d0078b4:	8c420024 	lw	v0,36(v0)
9d0078b8:	2404000b 	li	a0,11
9d0078bc:	1044ff41 	beq	v0,a0,9d0075c4 <TCPProcess+0x8c>
9d0078c0:	2404000a 	li	a0,10
		return;
	if(MyTCBStub.smState == TCP_CLOSING)
9d0078c4:	1044ff3f 	beq	v0,a0,9d0075c4 <TCPProcess+0x8c>
9d0078c8:	2404000c 	li	a0,12
		return;
	if(MyTCBStub.smState == TCP_LAST_ACK)
9d0078cc:	1044ff3d 	beq	v0,a0,9d0075c4 <TCPProcess+0x8c>
9d0078d0:	00000000 	nop
		return;
//	if(MyTCBStub.smState == TCP_TIME_WAIT)
//		return;

	// Copy any valid segment data into our RX FIFO, if any
	if(len)
9d0078d4:	12e00042 	beqz	s7,9d0079e0 <TCPProcess+0x4a8>
9d0078d8:	7c039620 	seh	s2,v1
	{
		// See if there are bytes we must skip
		if((SHORT)wMissingBytes <= 0)
9d0078dc:	1a400285 	blez	s2,9d0082f4 <TCPProcess+0xdbc>
9d0078e0:	02e31021 	addu	v0,s7,v1
			}
		} // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
		else if((SHORT)wMissingBytes > 0)
		{
			// Truncate packets that would overflow our TCP RX FIFO
			if(len + wMissingBytes > wFreeSpace)
9d0078e4:	0262102a 	slt	v0,s3,v0
9d0078e8:	10400003 	beqz	v0,9d0078f8 <TCPProcess+0x3c0>
9d0078ec:	8fa40030 	lw	a0,48(sp)
				len = wFreeSpace - wMissingBytes;
9d0078f0:	02639823 	subu	s3,s3,v1
9d0078f4:	3277ffff 	andi	s7,s3,0xffff
		
			// Position packet read pointer to start of useful data area.
			IPSetRxBuffer(h->DataOffset.Val << 2);
9d0078f8:	afa30038 	sw	v1,56(sp)
	
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd)
9d0078fc:	24130030 	li	s3,48
			// Truncate packets that would overflow our TCP RX FIFO
			if(len + wMissingBytes > wFreeSpace)
				len = wFreeSpace - wMissingBytes;
		
			// Position packet read pointer to start of useful data area.
			IPSetRxBuffer(h->DataOffset.Val << 2);
9d007900:	00042082 	srl	a0,a0,0x2
9d007904:	0f4024f1 	jal	9d0093c4 <IPSetRxBuffer>
9d007908:	3084003c 	andi	a0,a0,0x3c
	
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd)
9d00790c:	93858023 	lbu	a1,-32733(gp)
9d007910:	8fa30038 	lw	v1,56(sp)
9d007914:	70b31002 	mul	v0,a1,s3
9d007918:	00542821 	addu	a1,v0,s4
9d00791c:	8ca20014 	lw	v0,20(a1)
9d007920:	8ca70008 	lw	a3,8(a1)
9d007924:	00622021 	addu	a0,v1,v0
9d007928:	02e43021 	addu	a2,s7,a0
9d00792c:	00e6302b 	sltu	a2,a3,a2
9d007930:	10c00259 	beqz	a2,9d008298 <TCPProcess+0xd60>
9d007934:	24e60001 	addiu	a2,a3,1
			{
				// Calculate number of data bytes to copy before wraparound
				wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes;
9d007938:	00c21023 	subu	v0,a2,v0
9d00793c:	00431023 	subu	v0,v0,v1
				if((SHORT)wTemp >= 0)
9d007940:	7c023620 	seh	a2,v0
9d007944:	04c00264 	bltz	a2,9d0082d8 <TCPProcess+0xda0>
9d007948:	3042ffff 	andi	v0,v0,0xffff
				{
					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9d00794c:	90a5002c 	lbu	a1,44(a1)
9d007950:	2406ffff 	li	a2,-1
9d007954:	00003821 	move	a3,zero
9d007958:	afa20010 	sw	v0,16(sp)
9d00795c:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d007960:	afa20040 	sw	v0,64(sp)
					TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9d007964:	93848023 	lbu	a0,-32733(gp)
9d007968:	8fa20040 	lw	v0,64(sp)
9d00796c:	2406ffff 	li	a2,-1
9d007970:	70932802 	mul	a1,a0,s3
9d007974:	00003821 	move	a3,zero
9d007978:	02e21023 	subu	v0,s7,v0
9d00797c:	3042ffff 	andi	v0,v0,0xffff
9d007980:	afa20010 	sw	v0,16(sp)
9d007984:	00b49821 	addu	s3,a1,s4
9d007988:	8e640004 	lw	a0,4(s3)
9d00798c:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d007990:	9265002c 	lbu	a1,44(s3)
9d007994:	8fa30038 	lw	v1,56(sp)
			{
				TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
			}
		
			// Record the hole is here
			if(MyTCB.sHoleSize == -1)
9d007998:	86a20024 	lh	v0,36(s5)
9d00799c:	2404ffff 	li	a0,-1
9d0079a0:	1044023a 	beq	v0,a0,9d00828c <TCPProcess+0xd54>
9d0079a4:	3042ffff 	andi	v0,v0,0xffff
			}
			else
			{
				// We already have a hole, see if we can shrink the hole 
				// or extend the future data size
				if(wMissingBytes < (WORD)MyTCB.sHoleSize)
9d0079a8:	0062202b 	sltu	a0,v1,v0
9d0079ac:	1080022d 	beqz	a0,9d008264 <TCPProcess+0xd2c>
9d0079b0:	96a40016 	lhu	a0,22(s5)
				{
					if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize))
9d0079b4:	02e32821 	addu	a1,s7,v1
9d0079b8:	00442021 	addu	a0,v0,a0
9d0079bc:	0085302a 	slt	a2,a0,a1
9d0079c0:	54c0023d 	bnezl	a2,9d0082b8 <TCPProcess+0xd80>
9d0079c4:	a6b70016 	sh	s7,22(s5)
9d0079c8:	00a2102a 	slt	v0,a1,v0
9d0079cc:	5440023a 	bnezl	v0,9d0082b8 <TCPProcess+0xd80>
9d0079d0:	a6b70016 	sh	s7,22(s5)
						MyTCB.wFutureDataSize = len;
					else
						MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes;
9d0079d4:	00831823 	subu	v1,a0,v1
9d0079d8:	a6a30016 	sh	v1,22(s5)
					MyTCB.sHoleSize = wMissingBytes;
9d0079dc:	a6b20024 	sh	s2,36(s5)
	// Send back an ACK of the data (+SYN | FIN) we just received, 
	// if any.  To minimize bandwidth waste, we are implementing 
	// the delayed acknowledgement algorithm here, only sending 
	// back an immediate ACK if this is the second segment received.  
	// Otherwise, a 200ms timer will cause the ACK to be transmitted.
	if(wSegmentLength)
9d0079e0:	12c00015 	beqz	s6,9d007a38 <TCPProcess+0x500>
9d0079e4:	24020030 	li	v0,48
		// receiving data after calling TCPDisconnect(), which 
		// invalidates the application TCP handle.  By deleting all 
		// data, we'll ensure that the RX window is nonzero and 
		// the remote node will be able to send us a FIN response, 
		// which needs an RX window of at least 1.
		if(MyTCBStub.smState != TCP_ESTABLISHED)
9d0079e8:	93838023 	lbu	v1,-32733(gp)
9d0079ec:	70622002 	mul	a0,v1,v0
9d0079f0:	00941021 	addu	v0,a0,s4
9d0079f4:	8c450024 	lw	a1,36(v0)
9d0079f8:	24040007 	li	a0,7
9d0079fc:	10a40003 	beq	a1,a0,9d007a0c <TCPProcess+0x4d4>
9d007a00:	24120030 	li	s2,48
			MyTCBStub.rxTail = MyTCBStub.rxHead;
9d007a04:	8c440014 	lw	a0,20(v0)
9d007a08:	ac440018 	sw	a0,24(v0)

		if(MyTCBStub.Flags.bOneSegmentReceived)
9d007a0c:	70721002 	mul	v0,v1,s2
9d007a10:	00549021 	addu	s2,v0,s4
9d007a14:	8e420028 	lw	v0,40(s2)
9d007a18:	7c4301c0 	ext	v1,v0,0x7,0x1
9d007a1c:	14600206 	bnez	v1,9d008238 <TCPProcess+0xd00>
9d007a20:	24040010 	li	a0,16
			SyncTCB();
			// bOneSegmentReceived is cleared in SendTCP(), so no need here
		}
		else
		{
			MyTCBStub.Flags.bOneSegmentReceived = TRUE;	
9d007a24:	24030001 	li	v1,1
9d007a28:	7c6239c4 	ins	v0,v1,0x7,0x1
		
			// Do not send an ACK immediately back.  Instead, we will 
			// perform delayed acknowledgements.  To do this, we will 
			// just start a timer
			if(!MyTCBStub.Flags.bDelayedACKTimerEnabled)
9d007a2c:	7c440180 	ext	a0,v0,0x6,0x1
9d007a30:	108001ac 	beqz	a0,9d0080e4 <TCPProcess+0xbac>
9d007a34:	ae420028 	sw	v0,40(s2)
	}

	//
	// Eighth: check the FIN bit
	//
	if(localHeaderFlags & FIN)
9d007a38:	13c0fee2 	beqz	s8,9d0075c4 <TCPProcess+0x8c>
9d007a3c:	02d08021 	addu	s0,s6,s0
	{
		// Note: Since we don't have a good means of storing "FIN bytes" 
		// in our TCP RX FIFO, we must ensure that FINs are processed 
		// in-order.
		if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength)
9d007a40:	8ea20008 	lw	v0,8(s5)
9d007a44:	24420001 	addiu	v0,v0,1
9d007a48:	1450fede 	bne	v0,s0,9d0075c4 <TCPProcess+0x8c>
9d007a4c:	93848023 	lbu	a0,-32733(gp)
		{
			// FINs are treated as one byte of data for ACK sequencing
			MyTCB.RemoteSEQ++;
			
			switch(MyTCBStub.smState)
9d007a50:	24030030 	li	v1,48
		// in our TCP RX FIFO, we must ensure that FINs are processed 
		// in-order.
		if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength)
		{
			// FINs are treated as one byte of data for ACK sequencing
			MyTCB.RemoteSEQ++;
9d007a54:	aea20008 	sw	v0,8(s5)
			
			switch(MyTCBStub.smState)
9d007a58:	70832802 	mul	a1,a0,v1
9d007a5c:	24030007 	li	v1,7
9d007a60:	00b4a021 	addu	s4,a1,s4
9d007a64:	8e820024 	lw	v0,36(s4)
9d007a68:	10430215 	beq	v0,v1,9d0082c0 <TCPProcess+0xd88>
9d007a6c:	2c430008 	sltiu	v1,v0,8
9d007a70:	106000c5 	beqz	v1,9d007d88 <TCPProcess+0x850>
9d007a74:	24030008 	li	v1,8
9d007a78:	24030006 	li	v1,6
9d007a7c:	144300d5 	bne	v0,v1,9d007dd4 <TCPProcess+0x89c>
9d007a80:	24040010 	li	a0,16
					// RFC in exact: Our API has no need for the user 
					// to explicitly close a socket that never really 
					// got opened fully in the first place, so just 
					// transmit a FIN automatically and jump to 
					// TCP_LAST_ACK
					MyTCBStub.smState = TCP_LAST_ACK;
9d007a84:	2402000c 	li	v0,12
					SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9d007a88:	24040011 	li	a0,17
9d007a8c:	24050001 	li	a1,1
9d007a90:	0f401444 	jal	9d005110 <SendTCP>
9d007a94:	ae820024 	sw	v0,36(s4)
9d007a98:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007a9c:	00000000 	nop
	#if TCP_SYN_QUEUE_MAX_ENTRIES
	{
		WORD wQueueInsertPos;
		
		// See if this is a SYN packet
		if(!h->Flags.bits.flagSYN)
9d007aa0:	30420200 	andi	v0,v0,0x200
9d007aa4:	1040fec7 	beqz	v0,9d0075c4 <TCPProcess+0x8c>
9d007aa8:	3c10a000 	lui	s0,0xa000
			return FALSE;

		// See if there is space in our SYN queue
		if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort)
9d007aac:	2610490c 	addiu	s0,s0,18700
9d007ab0:	96020038 	lhu	v0,56(s0)
9d007ab4:	1440fec3 	bnez	v0,9d0075c4 <TCPProcess+0x8c>
9d007ab8:	97a50026 	lhu	a1,38(sp)
				break;

			// Check if this SYN packet is already in the SYN queue
			if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
				continue;
			if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort)
9d007abc:	97a70024 	lhu	a3,36(sp)
9d007ac0:	3c02a000 	lui	v0,0xa000
9d007ac4:	2442491c 	addiu	v0,v0,18716
9d007ac8:	00008821 	move	s1,zero
9d007acc:	00009821 	move	s3,zero
			return FALSE;
		
		// See if we have this SYN already in our SYN queue.
		// If not already in the queue, find out where we 
		// should insert this SYN to the queue
		for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++)
9d007ad0:	24060003 	li	a2,3
		{
			// Exit loop if we found a free record
			if(SYNQueue[wQueueInsertPos].wDestPort == 0u)
9d007ad4:	94430000 	lhu	v1,0(v0)
9d007ad8:	10600006 	beqz	v1,9d007af4 <TCPProcess+0x5bc>
9d007adc:	26640001 	addiu	a0,s3,1
				break;

			// Check if this SYN packet is already in the SYN queue
			if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
9d007ae0:	1065005c 	beq	v1,a1,9d007c54 <TCPProcess+0x71c>
9d007ae4:	3093ffff 	andi	s3,a0,0xffff
			return FALSE;
		
		// See if we have this SYN already in our SYN queue.
		// If not already in the queue, find out where we 
		// should insert this SYN to the queue
		for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++)
9d007ae8:	26310001 	addiu	s1,s1,1
9d007aec:	1666fff9 	bne	s3,a2,9d007ad4 <TCPProcess+0x59c>
9d007af0:	24420014 	addiu	v0,v0,20
				break;

			// Check if this SYN packet is already in the SYN queue
			if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
				continue;
			if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort)
9d007af4:	00009021 	move	s2,zero
		// are currently connected, but could handle this SYN 
		// request at a later time if the client disconnects.
		for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
		{
			SyncTCBStub(hTCP);
			if(!MyTCBStub.Flags.bServer)
9d007af8:	00121100 	sll	v0,s2,0x4
9d007afc:	00121980 	sll	v1,s2,0x6
9d007b00:	3c14a000 	lui	s4,0xa000
9d007b04:	26944700 	addiu	s4,s4,18176
9d007b08:	00621023 	subu	v0,v1,v0
9d007b0c:	02821021 	addu	v0,s4,v0
9d007b10:	8c420028 	lw	v0,40(v0)

			SyncTCB();
			#if defined(STACK_USE_SSL_SERVER)
			if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort))
			#else
			if(MyTCB.localPort.Val != h->DestPort)
9d007b14:	3c11a000 	lui	s1,0xa000
		// Check to see if we have any server sockets which 
		// are currently connected, but could handle this SYN 
		// request at a later time if the client disconnects.
		for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
		{
			SyncTCBStub(hTCP);
9d007b18:	a3928023 	sb	s2,-32733(gp)
			if(!MyTCBStub.Flags.bServer)
9d007b1c:	7c4200c0 	ext	v0,v0,0x3,0x1
		}
		
		// Check to see if we have any server sockets which 
		// are currently connected, but could handle this SYN 
		// request at a later time if the client disconnects.
		for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9d007b20:	2415000a 	li	s5,10
		{
			SyncTCBStub(hTCP);
			if(!MyTCBStub.Flags.bServer)
9d007b24:	1440000b 	bnez	v0,9d007b54 <TCPProcess+0x61c>
9d007b28:	26520001 	addiu	s2,s2,1
		}
		
		// Check to see if we have any server sockets which 
		// are currently connected, but could handle this SYN 
		// request at a later time if the client disconnects.
		for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9d007b2c:	1255fea5 	beq	s2,s5,9d0075c4 <TCPProcess+0x8c>
9d007b30:	00121100 	sll	v0,s2,0x4
		{
			SyncTCBStub(hTCP);
			if(!MyTCBStub.Flags.bServer)
9d007b34:	00121980 	sll	v1,s2,0x6
9d007b38:	00621023 	subu	v0,v1,v0
9d007b3c:	02821021 	addu	v0,s4,v0
9d007b40:	8c420028 	lw	v0,40(v0)
		// Check to see if we have any server sockets which 
		// are currently connected, but could handle this SYN 
		// request at a later time if the client disconnects.
		for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
		{
			SyncTCBStub(hTCP);
9d007b44:	a3928023 	sb	s2,-32733(gp)
			if(!MyTCBStub.Flags.bServer)
9d007b48:	7c4200c0 	ext	v0,v0,0x3,0x1
9d007b4c:	1040fff7 	beqz	v0,9d007b2c <TCPProcess+0x5f4>
9d007b50:	26520001 	addiu	s2,s2,1
				continue;

			SyncTCB();
9d007b54:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d007b58:	00000000 	nop
			#if defined(STACK_USE_SSL_SERVER)
			if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort))
			#else
			if(MyTCB.localPort.Val != h->DestPort)
9d007b5c:	262248e0 	addiu	v0,s1,18656
9d007b60:	97a30026 	lhu	v1,38(sp)
9d007b64:	94420012 	lhu	v0,18(v0)
9d007b68:	1443fff0 	bne	v0,v1,9d007b2c <TCPProcess+0x5f4>
9d007b6c:	00000000 	nop
			#endif
				continue;

			// Generate the SYN queue entry
			memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
9d007b70:	8ac40003 	lwl	a0,3(s6)
9d007b74:	8ac30007 	lwl	v1,7(s6)
9d007b78:	00132880 	sll	a1,s3,0x2
9d007b7c:	9ac40000 	lwr	a0,0(s6)
9d007b80:	9ac30004 	lwr	v1,4(s6)
9d007b84:	00139900 	sll	s3,s3,0x4
9d007b88:	00b39821 	addu	s3,a1,s3
9d007b8c:	02138021 	addu	s0,s0,s3
9d007b90:	ae040000 	sw	a0,0(s0)
9d007b94:	ae030004 	sw	v1,4(s0)
9d007b98:	92c30008 	lbu	v1,8(s6)
9d007b9c:	a2030008 	sb	v1,8(s0)
			SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
9d007ba0:	97a40024 	lhu	a0,36(sp)
			if(MyTCB.localPort.Val != h->DestPort)
			#endif
				continue;

			// Generate the SYN queue entry
			memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
9d007ba4:	92c30009 	lbu	v1,9(s6)
			SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
			SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber;
			SYNQueue[wQueueInsertPos].wDestPort = h->DestPort;
9d007ba8:	a6020010 	sh	v0,16(s0)
			#endif
				continue;

			// Generate the SYN queue entry
			memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
			SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
9d007bac:	a604000a 	sh	a0,10(s0)
			SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber;
9d007bb0:	8fa40028 	lw	a0,40(sp)
			if(MyTCB.localPort.Val != h->DestPort)
			#endif
				continue;

			// Generate the SYN queue entry
			memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
9d007bb4:	a2030009 	sb	v1,9(s0)
			SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
			SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber;
			SYNQueue[wQueueInsertPos].wDestPort = h->DestPort;
			SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9d007bb8:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d007bbc:	ae04000c 	sw	a0,12(s0)
9d007bc0:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007bc4:	a6020012 	sh	v0,18(s0)
		else if(MyTCBStub.remoteHash.Val != hash)
		{// Ignore if the hash doesn't match
			continue;
		}

		SyncTCB();
9d007bc8:	afa30038 	sw	v1,56(sp)
9d007bcc:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d007bd0:	afa4003c 	sw	a0,60(sp)
		if(	h->DestPort == MyTCB.localPort.Val &&
9d007bd4:	8fa4003c 	lw	a0,60(sp)
9d007bd8:	8fa60024 	lw	a2,36(sp)
9d007bdc:	8fa20040 	lw	v0,64(sp)
9d007be0:	8c850010 	lw	a1,16(a0)
9d007be4:	0080a821 	move	s5,a0
9d007be8:	14c5fea9 	bne	a2,a1,9d007690 <TCPProcess+0x158>
9d007bec:	8fa30038 	lw	v1,56(sp)
			h->SourcePort == MyTCB.remotePort.Val &&
			remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val)
9d007bf0:	8ac50003 	lwl	a1,3(s6)
			continue;
		}

		SyncTCB();
		if(	h->DestPort == MyTCB.localPort.Val &&
			h->SourcePort == MyTCB.remotePort.Val &&
9d007bf4:	8c860018 	lw	a2,24(a0)
			remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val)
9d007bf8:	9ac50000 	lwr	a1,0(s6)
			continue;
		}

		SyncTCB();
		if(	h->DestPort == MyTCB.localPort.Val &&
			h->SourcePort == MyTCB.remotePort.Val &&
9d007bfc:	14a6fea5 	bne	a1,a2,9d007694 <TCPProcess+0x15c>
9d007c00:	26100001 	addiu	s0,s0,1
//	}

	// Finished with this packet, discard it and free the Ethernet RAM for new packets
	MACDiscardRx();

	return TRUE;
9d007c04:	93858023 	lbu	a1,-32733(gp)
9d007c08:	3c14a000 	lui	s4,0xa000
9d007c0c:	26944700 	addiu	s4,s4,18176
9d007c10:	00053100 	sll	a2,a1,0x4
9d007c14:	0b401dd8 	j	9d007760 <TCPProcess+0x228>
9d007c18:	00053980 	sll	a3,a1,0x6
	//
	// First: check the sequence number
	//
	wSegmentLength = len;
	if(localHeaderFlags & FIN)
		wSegmentLength++;
9d007c1c:	26f60001 	addiu	s6,s7,1
9d007c20:	0b401df2 	j	9d0077c8 <TCPProcess+0x290>
9d007c24:	32d6ffff 	andi	s6,s6,0xffff

	// We received a packet, reset the keep alive timer and count
	#if defined(TCP_KEEP_ALIVE_TIMEOUT)
		MyTCBStub.Flags.vUnackedKeepalives = 0;
		if(!MyTCBStub.Flags.bTimerEnabled)
			MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d007c28:	0f400b53 	jal	9d002d4c <TickGet>
9d007c2c:	afa4003c 	sw	a0,60(sp)
9d007c30:	93858023 	lbu	a1,-32733(gp)
9d007c34:	3c03002f 	lui	v1,0x2f
9d007c38:	3463af08 	ori	v1,v1,0xaf08
9d007c3c:	00431021 	addu	v0,v0,v1
9d007c40:	aec2001c 	sw	v0,28(s6)
9d007c44:	00053100 	sll	a2,a1,0x4
9d007c48:	00053980 	sll	a3,a1,0x6
9d007c4c:	0b401de2 	j	9d007788 <TCPProcess+0x250>
9d007c50:	8fa4003c 	lw	a0,60(sp)
				break;

			// Check if this SYN packet is already in the SYN queue
			if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
				continue;
			if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort)
9d007c54:	9443fffa 	lhu	v1,-6(v0)
9d007c58:	5467ffa4 	bnel	v1,a3,9d007aec <TCPProcess+0x5b4>
9d007c5c:	26310001 	addiu	s1,s1,1
				continue;
			if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val)
9d007c60:	8ac30003 	lwl	v1,3(s6)
9d007c64:	8c44fff0 	lw	a0,-16(v0)
9d007c68:	9ac30000 	lwr	v1,0(s6)
9d007c6c:	5483ff9f 	bnel	a0,v1,9d007aec <TCPProcess+0x5b4>
9d007c70:	26310001 	addiu	s1,s1,1
				continue;

			// SYN matches SYN queue entry.  Update timestamp and do nothing.
			SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9d007c74:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d007c78:	00000000 	nop
9d007c7c:	24030014 	li	v1,20
9d007c80:	72232002 	mul	a0,s1,v1
9d007c84:	00908021 	addu	s0,a0,s0
9d007c88:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007c8c:	a6020012 	sh	v0,18(s0)
	// states.
	switch(MyTCBStub.smState)
	{
		case TCP_LISTEN:
			// First: check RST flag
			if(localHeaderFlags & RST)
9d007c90:	30820004 	andi	v0,a0,0x4
9d007c94:	14400042 	bnez	v0,9d007da0 <TCPProcess+0x868>
9d007c98:	30820010 	andi	v0,a0,0x10
				CloseSocket();	// Unbind remote IP address/port info
				return;
			}

			// Second: check ACK flag, which would be invalid
			if(localHeaderFlags & ACK)
9d007c9c:	14400059 	bnez	v0,9d007e04 <TCPProcess+0x8cc>
9d007ca0:	30840002 	andi	a0,a0,0x2
				CloseSocket();	// Unbind remote IP address/port info
				return;
			}

			// Third: check for SYN flag, which is what we're looking for
			if(localHeaderFlags & SYN)
9d007ca4:	1080003e 	beqz	a0,9d007da0 <TCPProcess+0x868>
9d007ca8:	26100001 	addiu	s0,s0,1
			{
				// We now have a sequence number for the remote node
				MyTCB.RemoteSEQ = localSeqNumber + 1;

				// Get MSS option
				MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9d007cac:	0f4015fc 	jal	9d0057f0 <GetMaxSegSizeOption>
9d007cb0:	aeb00008 	sw	s0,8(s5)
9d007cb4:	a6a20028 	sh	v0,40(s5)

				// Set Initial Send Sequence (ISS) number
				// Nothing to do on this step... ISS already set in CloseSocket()
				
				// Respond with SYN + ACK
				SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9d007cb8:	24040012 	li	a0,18
9d007cbc:	24050001 	li	a1,1
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
				}
				else
				{
					SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9d007cc0:	0f401444 	jal	9d005110 <SendTCP>
9d007cc4:	00000000 	nop
					MyTCBStub.smState = TCP_SYN_RECEIVED;
9d007cc8:	93828023 	lbu	v0,-32733(gp)
9d007ccc:	00021900 	sll	v1,v0,0x4
9d007cd0:	00021180 	sll	v0,v0,0x6
9d007cd4:	00431023 	subu	v0,v0,v1
9d007cd8:	0282a021 	addu	s4,s4,v0
9d007cdc:	24020006 	li	v0,6
9d007ce0:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007ce4:	ae820024 	sw	v0,36(s4)
			// Second: check the RST bit
			// This is out of order because this stack has no API for 
			// notifying the application that the connection seems to 
			// be failing.  Instead, the application must time out and 
			// the stack will just keep trying in the mean time.
			if(localHeaderFlags & RST)
9d007ce8:	30820004 	andi	v0,a0,0x4
9d007cec:	1440fe35 	bnez	v0,9d0075c4 <TCPProcess+0x8c>
9d007cf0:	30930010 	andi	s3,a0,0x10
				return;

			// First: check ACK bit
			if(localHeaderFlags & ACK)
9d007cf4:	12600004 	beqz	s3,9d007d08 <TCPProcess+0x7d0>
9d007cf8:	30840002 	andi	a0,a0,0x2
			{
				if(localAckNumber != MyTCB.MySEQ)
9d007cfc:	8eb20004 	lw	s2,4(s5)
9d007d00:	56320049 	bnel	s1,s2,9d007e28 <TCPProcess+0x8f0>
9d007d04:	24040004 	li	a0,4

			// Third: check the security and precedence
			// No such feature in this stack.  We want to accept all connections.

			// Fourth: check the SYN bit
			if(localHeaderFlags & SYN)
9d007d08:	1080fe2e 	beqz	a0,9d0075c4 <TCPProcess+0x8c>
9d007d0c:	97a20032 	lhu	v0,50(sp)
			{
				// We now have an initial sequence number and window size
				MyTCB.RemoteSEQ = localSeqNumber + 1;
9d007d10:	26100001 	addiu	s0,s0,1
9d007d14:	aeb00008 	sw	s0,8(s5)
				MyTCB.remoteWindow = h->Window;

				// Get MSS option
				MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9d007d18:	0f4015fc 	jal	9d0057f0 <GetMaxSegSizeOption>
9d007d1c:	a6a20014 	sh	v0,20(s5)

				if(localHeaderFlags & ACK)
9d007d20:	126000c8 	beqz	s3,9d008044 <TCPProcess+0xb0c>
9d007d24:	a6a20028 	sh	v0,40(s5)
				{
					SendTCP(ACK, SENDTCP_RESET_TIMERS);
9d007d28:	24040010 	li	a0,16
9d007d2c:	0f401444 	jal	9d005110 <SendTCP>
9d007d30:	24050001 	li	a1,1
					MyTCBStub.smState = TCP_ESTABLISHED;
9d007d34:	93828023 	lbu	v0,-32733(gp)
9d007d38:	00021900 	sll	v1,v0,0x4
9d007d3c:	00028180 	sll	s0,v0,0x6
9d007d40:	02038023 	subu	s0,s0,v1
9d007d44:	02908021 	addu	s0,s4,s0
9d007d48:	24020007 	li	v0,7
					// Set up keep-alive timer
					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d007d4c:	0f400b53 	jal	9d002d4c <TickGet>
9d007d50:	ae020024 	sw	v0,36(s0)
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
9d007d54:	93838023 	lbu	v1,-32733(gp)
				{
					SendTCP(ACK, SENDTCP_RESET_TIMERS);
					MyTCBStub.smState = TCP_ESTABLISHED;
					// Set up keep-alive timer
					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d007d58:	3c05002f 	lui	a1,0x2f
9d007d5c:	34a5af08 	ori	a1,a1,0xaf08
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
9d007d60:	00032100 	sll	a0,v1,0x4
9d007d64:	00031980 	sll	v1,v1,0x6
				{
					SendTCP(ACK, SENDTCP_RESET_TIMERS);
					MyTCBStub.smState = TCP_ESTABLISHED;
					// Set up keep-alive timer
					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d007d68:	00451021 	addu	v0,v0,a1
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
9d007d6c:	00641823 	subu	v1,v1,a0
				{
					SendTCP(ACK, SENDTCP_RESET_TIMERS);
					MyTCBStub.smState = TCP_ESTABLISHED;
					// Set up keep-alive timer
					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d007d70:	ae02001c 	sw	v0,28(s0)
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
9d007d74:	0283a021 	addu	s4,s4,v1
9d007d78:	8e820028 	lw	v0,40(s4)
9d007d7c:	7c022104 	ins	v0,zero,0x4,0x1
9d007d80:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007d84:	ae820028 	sw	v0,40(s4)
		if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength)
		{
			// FINs are treated as one byte of data for ACK sequencing
			MyTCB.RemoteSEQ++;
			
			switch(MyTCBStub.smState)
9d007d88:	104301bb 	beq	v0,v1,9d008478 <TCPProcess+0xf40>
9d007d8c:	24030009 	li	v1,9
9d007d90:	14430010 	bne	v0,v1,9d007dd4 <TCPProcess+0x89c>
9d007d94:	24040010 	li	a0,16
					// leave a socket waiting around doing nothing 
					// for a long time.  If the remote node does 
					// not recieve this ACK, it'll have to figure 
					// out on it's own that the connection is now 
					// closed.
					SendTCP(ACK, 0);
9d007d98:	0f401444 	jal	9d005110 <SendTCP>
9d007d9c:	00002821 	move	a1,zero
					CloseSocket();
9d007da0:	0f40164c 	jal	9d005930 <CloseSocket>
9d007da4:	00000000 	nop
9d007da8:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007dac:	00000000 	nop

	// Calculate the RX FIFO space
	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
		wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
	else
		wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9d007db0:	02689823 	subu	s3,s3,t0
9d007db4:	0b401e03 	j	9d00780c <TCPProcess+0x2d4>
9d007db8:	3273ffff 	andi	s3,s3,0xffff
			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
				bSegmentAcceptable = TRUE;
		}
	}
	
	if(!bSegmentAcceptable)
9d007dbc:	1520feab 	bnez	t1,9d00786c <TCPProcess+0x334>
9d007dc0:	30880006 	andi	t0,a0,0x6
	{
		// Unacceptable segment, drop it and respond appropriately
		if(!(localHeaderFlags & RST)) 
9d007dc4:	30840004 	andi	a0,a0,0x4
9d007dc8:	1480fdfe 	bnez	a0,9d0075c4 <TCPProcess+0x8c>
9d007dcc:	00000000 	nop
				default:
					break;
			}

			// Acknowledge receipt of FIN
			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9d007dd0:	24040010 	li	a0,16
9d007dd4:	0f401444 	jal	9d005110 <SendTCP>
9d007dd8:	24050001 	li	a1,1
9d007ddc:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007de0:	00000000 	nop
	}
	else
	{
		// Zero length packets are acceptable if they fall within our free space window
		// SEG.SEQ = RCV.NXT
		if(lMissingBytes == 0)
9d007de4:	5100fea1 	beqzl	t0,9d00786c <TCPProcess+0x334>
9d007de8:	30880006 	andi	t0,a0,0x6
			bSegmentAcceptable = TRUE;
		}
		else
		{
			// RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
9d007dec:	0500fff5 	bltz	t0,9d007dc4 <TCPProcess+0x88c>
9d007df0:	0113402b 	sltu	t0,t0,s3
9d007df4:	1500fe9d 	bnez	t0,9d00786c <TCPProcess+0x334>
9d007df8:	30880006 	andi	t0,a0,0x6
	}
	
	if(!bSegmentAcceptable)
	{
		// Unacceptable segment, drop it and respond appropriately
		if(!(localHeaderFlags & RST)) 
9d007dfc:	0b401f72 	j	9d007dc8 <TCPProcess+0x890>
9d007e00:	30840004 	andi	a0,a0,0x4
			// Second: check ACK flag, which would be invalid
			if(localHeaderFlags & ACK)
			{
				// Use a believable sequence number and reset the remote node
				MyTCB.MySEQ = localAckNumber;
				SendTCP(RST, 0);
9d007e04:	24040004 	li	a0,4
9d007e08:	00002821 	move	a1,zero
9d007e0c:	0f401444 	jal	9d005110 <SendTCP>
9d007e10:	aeb10004 	sw	s1,4(s5)
					// for a long time.  If the remote node does 
					// not recieve this ACK, it'll have to figure 
					// out on it's own that the connection is now 
					// closed.
					SendTCP(ACK, 0);
					CloseSocket();
9d007e14:	0f40164c 	jal	9d005930 <CloseSocket>
9d007e18:	00000000 	nop
9d007e1c:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007e20:	00000000 	nop
			{
				// Send a RST packet with SEQ = SEG.ACK, but retain our SEQ 
				// number for arivial of any other correct packets
				localSeqNumber = MyTCB.MySEQ;	// Save our original SEQ number
				MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
				SendTCP(RST, SENDTCP_RESET_TIMERS);		// Send the RST
9d007e24:	24040004 	li	a0,4
9d007e28:	24050001 	li	a1,1
9d007e2c:	0f401444 	jal	9d005110 <SendTCP>
9d007e30:	aeb10004 	sw	s1,4(s5)
				MyTCB.MySEQ = localSeqNumber;	// Restore original SEQ number
9d007e34:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d007e38:	aeb20004 	sw	s2,4(s5)
	// Fifth: check the ACK bit
	//
	if(!(localHeaderFlags & ACK))
		return;

	switch(MyTCBStub.smState)
9d007e3c:	1446fe98 	bne	v0,a2,9d0078a0 <TCPProcess+0x368>
9d007e40:	30840020 	andi	a0,a0,0x20

			break;

		case TCP_LAST_ACK:
			// Check to see if our FIN has been ACKnowledged
			if(MyTCB.MySEQ == localAckNumber)
9d007e44:	8ea20004 	lw	v0,4(s5)
9d007e48:	1622fdde 	bne	s1,v0,9d0075c4 <TCPProcess+0x8c>
9d007e4c:	00000000 	nop
9d007e50:	0b401f68 	j	9d007da0 <TCPProcess+0x868>
9d007e54:	00000000 	nop
		return;

	switch(MyTCBStub.smState)
	{
		case TCP_SYN_RECEIVED:
			if(localAckNumber != MyTCB.MySEQ)
9d007e58:	1632fff2 	bne	s1,s2,9d007e24 <TCPProcess+0x8ec>
9d007e5c:	24020030 	li	v0,48
				MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
				SendTCP(RST, SENDTCP_RESET_TIMERS);		// Send the RST
				MyTCB.MySEQ = localSeqNumber;	// Restore original SEQ number
				return;
			}
			MyTCBStub.smState = TCP_ESTABLISHED;
9d007e60:	70a24002 	mul	t0,a1,v0
9d007e64:	01141021 	addu	v0,t0,s4
9d007e68:	24080007 	li	t0,7
9d007e6c:	ac480024 	sw	t0,36(v0)
		case TCP_FIN_WAIT_1:
		case TCP_FIN_WAIT_2:
		case TCP_CLOSE_WAIT:
		case TCP_CLOSING:
			// Calculate what the highest possible SEQ number in our TX FIFO is
			wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail;
9d007e70:	00e64823 	subu	t1,a3,a2
9d007e74:	02894821 	addu	t1,s4,t1
9d007e78:	8ea8000c 	lw	t0,12(s5)
9d007e7c:	8d22000c 	lw	v0,12(t1)
9d007e80:	00481023 	subu	v0,v0,t0
			if((SHORT)wTemp < (SHORT)0)
9d007e84:	7c025620 	seh	t2,v0
9d007e88:	0542009c 	bltzl	t2,9d0080fc <TCPProcess+0xbc4>
9d007e8c:	8d2a0000 	lw	t2,0(t1)
				wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
			dwTemp = MyTCB.MySEQ + (DWORD)wTemp;
9d007e90:	8eab0004 	lw	t3,4(s5)
9d007e94:	01714823 	subu	t1,t3,s1

			// Drop the packet if it ACKs something we haven't sent
			if((LONG)(dwTemp - localAckNumber) < (LONG)0)
9d007e98:	01221021 	addu	v0,t1,v0
9d007e9c:	044000ec 	bltz	v0,9d008250 <TCPProcess+0xd18>
9d007ea0:	00e63023 	subu	a2,a3,a2
				return;
			}

			// Throw away all ACKnowledged TX data:
			// Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
			dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
9d007ea4:	02863021 	addu	a2,s4,a2
9d007ea8:	8cc90010 	lw	t1,16(a2)
9d007eac:	01095023 	subu	t2,t0,t1
9d007eb0:	7c0a5620 	seh	t2,t2
9d007eb4:	016a5023 	subu	t2,t3,t2
			if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9d007eb8:	0109382b 	sltu	a3,t0,t1
9d007ebc:	10e00005 	beqz	a3,9d007ed4 <TCPProcess+0x99c>
9d007ec0:	01401021 	move	v0,t2
				dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9d007ec4:	8ccc0000 	lw	t4,0(a2)
9d007ec8:	8cc20004 	lw	v0,4(a2)
9d007ecc:	01821023 	subu	v0,t4,v0
9d007ed0:	004a1021 	addu	v0,v0,t2
	
			// Calcluate how many bytes were ACKed with this packet
			dwTemp = localAckNumber - dwTemp;
9d007ed4:	02221023 	subu	v0,s1,v0
			if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
9d007ed8:	1840005d 	blez	v0,9d008050 <TCPProcess+0xb18>
9d007edc:	24060030 	li	a2,48
9d007ee0:	70a66002 	mul	t4,a1,a2
9d007ee4:	01943021 	addu	a2,t4,s4
9d007ee8:	8ccd0004 	lw	t5,4(a2)
9d007eec:	8ccc0000 	lw	t4,0(a2)
9d007ef0:	01ac7023 	subu	t6,t5,t4
9d007ef4:	01c2702b 	sltu	t6,t6,v0
9d007ef8:	15c00055 	bnez	t6,9d008050 <TCPProcess+0xb18>
9d007efc:	00000000 	nop
			{
				MyTCB.flags.bRXNoneACKed1 = 0;
9d007f00:	8ea90024 	lw	t1,36(s5)
				MyTCB.flags.bRXNoneACKed2 = 0;
				MyTCBStub.Flags.bHalfFullFlush = FALSE;
	
				// Bytes ACKed, free up the TX FIFO space
				wTemp = MyTCBStub.txTail;
9d007f04:	8cca0010 	lw	t2,16(a2)
			dwTemp = localAckNumber - dwTemp;
			if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
			{
				MyTCB.flags.bRXNoneACKed1 = 0;
				MyTCB.flags.bRXNoneACKed2 = 0;
				MyTCBStub.Flags.bHalfFullFlush = FALSE;
9d007f08:	8cc70028 	lw	a3,40(a2)
	
			// Calcluate how many bytes were ACKed with this packet
			dwTemp = localAckNumber - dwTemp;
			if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
			{
				MyTCB.flags.bRXNoneACKed1 = 0;
9d007f0c:	7c099cc4 	ins	t1,zero,0x13,0x1
				MyTCB.flags.bRXNoneACKed2 = 0;
				MyTCBStub.Flags.bHalfFullFlush = FALSE;
	
				// Bytes ACKed, free up the TX FIFO space
				wTemp = MyTCBStub.txTail;
				MyTCBStub.txTail += dwTemp;
9d007f10:	004a1021 	addu	v0,v0,t2
			// Calcluate how many bytes were ACKed with this packet
			dwTemp = localAckNumber - dwTemp;
			if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
			{
				MyTCB.flags.bRXNoneACKed1 = 0;
				MyTCB.flags.bRXNoneACKed2 = 0;
9d007f14:	7c09a504 	ins	t1,zero,0x14,0x1
				MyTCBStub.Flags.bHalfFullFlush = FALSE;
9d007f18:	7c074204 	ins	a3,zero,0x8,0x1
	
				// Bytes ACKed, free up the TX FIFO space
				wTemp = MyTCBStub.txTail;
				MyTCBStub.txTail += dwTemp;
				if(MyTCB.txUnackedTail >= wTemp)
9d007f1c:	010a502b 	sltu	t2,t0,t2
			// Calcluate how many bytes were ACKed with this packet
			dwTemp = localAckNumber - dwTemp;
			if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
			{
				MyTCB.flags.bRXNoneACKed1 = 0;
				MyTCB.flags.bRXNoneACKed2 = 0;
9d007f20:	aea90024 	sw	t1,36(s5)
				MyTCBStub.Flags.bHalfFullFlush = FALSE;
9d007f24:	acc70028 	sw	a3,40(a2)
	
				// Bytes ACKed, free up the TX FIFO space
				wTemp = MyTCBStub.txTail;
				MyTCBStub.txTail += dwTemp;
				if(MyTCB.txUnackedTail >= wTemp)
9d007f28:	154000ac 	bnez	t2,9d0081dc <TCPProcess+0xca4>
9d007f2c:	acc20010 	sw	v0,16(a2)
				{
					if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9d007f30:	0102302b 	sltu	a2,t0,v0
9d007f34:	10c00006 	beqz	a2,9d007f50 <TCPProcess+0xa18>
9d007f38:	24060030 	li	a2,48
				else
				{
					wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
					if(wTemp < MyTCBStub.txTail)
					{
						MyTCB.MySEQ += MyTCBStub.txTail - wTemp;
9d007f3c:	01684023 	subu	t0,t3,t0
9d007f40:	01024021 	addu	t0,t0,v0
9d007f44:	aea80004 	sw	t0,4(s5)
						MyTCB.txUnackedTail = MyTCBStub.txTail;
9d007f48:	aea2000c 	sw	v0,12(s5)
					}
				}
				if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart)
9d007f4c:	24060030 	li	a2,48
9d007f50:	70a63802 	mul	a3,a1,a2
9d007f54:	00f43021 	addu	a2,a3,s4
9d007f58:	8cc70004 	lw	a3,4(a2)
9d007f5c:	0047402b 	sltu	t0,v0,a3
9d007f60:	55000006 	bnezl	t0,9d007f7c <TCPProcess+0xa44>
9d007f64:	24070030 	li	a3,48
					MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9d007f68:	8cc80000 	lw	t0,0(a2)
9d007f6c:	01073823 	subu	a3,t0,a3
9d007f70:	00e21021 	addu	v0,a3,v0
9d007f74:	acc20010 	sw	v0,16(a2)
				if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9d007f78:	24070030 	li	a3,48
9d007f7c:	70a71002 	mul	v0,a1,a3
9d007f80:	8ea6000c 	lw	a2,12(s5)
9d007f84:	00543821 	addu	a3,v0,s4
9d007f88:	8ce20004 	lw	v0,4(a3)
9d007f8c:	00c2402b 	sltu	t0,a2,v0
9d007f90:	55000006 	bnezl	t0,9d007fac <TCPProcess+0xa74>
9d007f94:	00051100 	sll	v0,a1,0x4
					MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9d007f98:	8ce70000 	lw	a3,0(a3)
9d007f9c:	00c73021 	addu	a2,a2,a3
9d007fa0:	00c21023 	subu	v0,a2,v0
9d007fa4:	aea2000c 	sw	v0,12(s5)
					MyTCB.flags.bRXNoneACKed1 = 1;
				}
			}

			// No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
			if(MyTCBStub.txTail == MyTCBStub.txHead)
9d007fa8:	00051100 	sll	v0,a1,0x4
9d007fac:	00059180 	sll	s2,a1,0x6
9d007fb0:	02429023 	subu	s2,s2,v0
9d007fb4:	02929021 	addu	s2,s4,s2
9d007fb8:	8e460010 	lw	a2,16(s2)
9d007fbc:	8e42000c 	lw	v0,12(s2)
9d007fc0:	50c20052 	beql	a2,v0,9d00810c <TCPProcess+0xbd4>
9d007fc4:	8e420028 	lw	v0,40(s2)
			}

			// The window size advirtised in this packet is adjusted to account 
			// for any bytes that we have transmitted but haven't been ACKed yet 
			// by this segment.
			wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber));
9d007fc8:	97a60032 	lhu	a2,50(sp)
9d007fcc:	8ea70004 	lw	a3,4(s5)

			// Update the local stored copy of the RemoteWindow.
			// If previously we had a zero window, and now we don't, then 
			// immediately send whatever was pending.
			if((MyTCB.remoteWindow == 0u) && wNewWindow)
9d007fd0:	96a20014 	lhu	v0,20(s5)
			}

			// The window size advirtised in this packet is adjusted to account 
			// for any bytes that we have transmitted but haven't been ACKed yet 
			// by this segment.
			wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber));
9d007fd4:	02263021 	addu	a2,s1,a2
9d007fd8:	00c73023 	subu	a2,a2,a3

			// Update the local stored copy of the RemoteWindow.
			// If previously we had a zero window, and now we don't, then 
			// immediately send whatever was pending.
			if((MyTCB.remoteWindow == 0u) && wNewWindow)
9d007fdc:	1440000a 	bnez	v0,9d008008 <TCPProcess+0xad0>
9d007fe0:	30c6ffff 	andi	a2,a2,0xffff
9d007fe4:	10c00009 	beqz	a2,9d00800c <TCPProcess+0xad4>
9d007fe8:	00051100 	sll	v0,a1,0x4
				MyTCBStub.Flags.bTXASAP = 1;
9d007fec:	24020030 	li	v0,48
9d007ff0:	70a23802 	mul	a3,a1,v0
9d007ff4:	24080001 	li	t0,1
9d007ff8:	00f41021 	addu	v0,a3,s4
9d007ffc:	8c470028 	lw	a3,40(v0)
9d008000:	7d074a44 	ins	a3,t0,0x9,0x1
9d008004:	ac470028 	sw	a3,40(v0)
			MyTCB.remoteWindow = wNewWindow;

			// A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more
			if(MyTCBStub.smState == TCP_FIN_WAIT_1)
9d008008:	00051100 	sll	v0,a1,0x4
9d00800c:	00059180 	sll	s2,a1,0x6
9d008010:	02429023 	subu	s2,s2,v0
9d008014:	02929021 	addu	s2,s4,s2
9d008018:	8e420024 	lw	v0,36(s2)
			// Update the local stored copy of the RemoteWindow.
			// If previously we had a zero window, and now we don't, then 
			// immediately send whatever was pending.
			if((MyTCB.remoteWindow == 0u) && wNewWindow)
				MyTCBStub.Flags.bTXASAP = 1;
			MyTCB.remoteWindow = wNewWindow;
9d00801c:	a6a60014 	sh	a2,20(s5)

			// A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more
			if(MyTCBStub.smState == TCP_FIN_WAIT_1)
9d008020:	24060008 	li	a2,8
9d008024:	10460048 	beq	v0,a2,9d008148 <TCPProcess+0xc10>
9d008028:	24060009 	li	a2,9
					MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
					MyTCBStub.Flags.bTimerEnabled = 1;
					MyTCBStub.smState = TCP_FIN_WAIT_2;
				}
			}
			else if(MyTCBStub.smState == TCP_FIN_WAIT_2)
9d00802c:	10460061 	beq	v0,a2,9d0081b4 <TCPProcess+0xc7c>
9d008030:	2406000a 	li	a2,10
					SendTCP(RST | ACK, 0);
					CloseSocket();
					return;
				}
			}
			else if(MyTCBStub.smState == TCP_CLOSING)
9d008034:	1446fe1a 	bne	v0,a2,9d0078a0 <TCPProcess+0x368>
9d008038:	30840020 	andi	a0,a0,0x20

			break;

		case TCP_LAST_ACK:
			// Check to see if our FIN has been ACKnowledged
			if(MyTCB.MySEQ == localAckNumber)
9d00803c:	0b401f92 	j	9d007e48 <TCPProcess+0x910>
9d008040:	8ea20004 	lw	v0,4(s5)
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
				}
				else
				{
					SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9d008044:	24040012 	li	a0,18
9d008048:	0b401f30 	j	9d007cc0 <TCPProcess+0x788>
9d00804c:	24050001 	li	a1,1
					MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
			}
			else
			{
				// See if we have outstanding TX data that is waiting for an ACK
				if(MyTCBStub.txTail != MyTCB.txUnackedTail)
9d008050:	1109ffd6 	beq	t0,t1,9d007fac <TCPProcess+0xa74>
9d008054:	00051100 	sll	v0,a1,0x4
				{
					if(MyTCB.flags.bRXNoneACKed1)
9d008058:	8ea20024 	lw	v0,36(s5)
9d00805c:	7c4604c0 	ext	a2,v0,0x13,0x1
9d008060:	50c0001d 	beqzl	a2,9d0080d8 <TCPProcess+0xba0>
9d008064:	24060001 	li	a2,1
					{
						if(MyTCB.flags.bRXNoneACKed2)
9d008068:	7c420500 	ext	v0,v0,0x14,0x1
9d00806c:	50400015 	beqzl	v0,9d0080c4 <TCPProcess+0xb8c>
9d008070:	8ea20024 	lw	v0,36(s5)
						{
							// Set up to perform a fast retransmission
							// Roll back unacknowledged TX tail pointer to cause retransmit to occur
							MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
							if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9d008074:	10e0000a 	beqz	a3,9d0080a0 <TCPProcess+0xb68>
9d008078:	aeaa0004 	sw	t2,4(s5)
								MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9d00807c:	24020030 	li	v0,48
9d008080:	70a23002 	mul	a2,a1,v0
9d008084:	00d41021 	addu	v0,a2,s4
9d008088:	8c460004 	lw	a2,4(v0)
9d00808c:	8c420000 	lw	v0,0(v0)
9d008090:	00c21023 	subu	v0,a2,v0
9d008094:	7c021620 	seh	v0,v0
9d008098:	01425023 	subu	t2,t2,v0
9d00809c:	aeaa0004 	sw	t2,4(s5)
							MyTCB.txUnackedTail = MyTCBStub.txTail;
							MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9d0080a0:	24020030 	li	v0,48
9d0080a4:	70a23002 	mul	a2,a1,v0
							// Set up to perform a fast retransmission
							// Roll back unacknowledged TX tail pointer to cause retransmit to occur
							MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
							if(MyTCB.txUnackedTail < MyTCBStub.txTail)
								MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
							MyTCB.txUnackedTail = MyTCBStub.txTail;
9d0080a8:	aea9000c 	sw	t1,12(s5)
							MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9d0080ac:	24070001 	li	a3,1
9d0080b0:	00d41021 	addu	v0,a2,s4
9d0080b4:	8c460028 	lw	a2,40(v0)
9d0080b8:	7ce65284 	ins	a2,a3,0xa,0x1
9d0080bc:	ac460028 	sw	a2,40(v0)
						}
						MyTCB.flags.bRXNoneACKed2 = 1;
9d0080c0:	8ea20024 	lw	v0,36(s5)
9d0080c4:	24060001 	li	a2,1
9d0080c8:	7cc2a504 	ins	v0,a2,0x14,0x1
9d0080cc:	aea20024 	sw	v0,36(s5)
					}
					MyTCB.flags.bRXNoneACKed1 = 1;
9d0080d0:	8ea20024 	lw	v0,36(s5)
9d0080d4:	24060001 	li	a2,1
9d0080d8:	7cc29cc4 	ins	v0,a2,0x13,0x1
9d0080dc:	0b401fea 	j	9d007fa8 <TCPProcess+0xa70>
9d0080e0:	aea20024 	sw	v0,36(s5)
			// Do not send an ACK immediately back.  Instead, we will 
			// perform delayed acknowledgements.  To do this, we will 
			// just start a timer
			if(!MyTCBStub.Flags.bDelayedACKTimerEnabled)
			{
				MyTCBStub.Flags.bDelayedACKTimerEnabled = 1;
9d0080e4:	7c623184 	ins	v0,v1,0x6,0x1
				MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8);
9d0080e8:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d0080ec:	ae420028 	sw	v0,40(s2)
9d0080f0:	2442007a 	addiu	v0,v0,122
9d0080f4:	0b401e8e 	j	9d007a38 <TCPProcess+0x500>
9d0080f8:	a6420022 	sh	v0,34(s2)
		case TCP_CLOSE_WAIT:
		case TCP_CLOSING:
			// Calculate what the highest possible SEQ number in our TX FIFO is
			wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail;
			if((SHORT)wTemp < (SHORT)0)
				wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9d0080fc:	8d290004 	lw	t1,4(t1)
9d008100:	004a1023 	subu	v0,v0,t2
9d008104:	0b401fa4 	j	9d007e90 <TCPProcess+0x958>
9d008108:	00491021 	addu	v0,v0,t1

			// No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
			if(MyTCBStub.txTail == MyTCBStub.txHead)
			{
				// Make sure there isn't a "FIN byte in our TX FIFO"
				if(MyTCBStub.Flags.bTXFIN == 0u)
9d00810c:	7c4602c0 	ext	a2,v0,0xb,0x1
9d008110:	50c00039 	beqzl	a2,9d0081f8 <TCPProcess+0xcc0>
9d008114:	afa30038 	sw	v1,56(sp)
					MyTCBStub.Flags.bTimerEnabled = 0;
				}
				else
				{
					// "Throw away" FIN byte from our TX FIFO if it has been ACKed
					if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9d008118:	8ea60004 	lw	a2,4(s5)
9d00811c:	1626ffab 	bne	s1,a2,9d007fcc <TCPProcess+0xa94>
9d008120:	97a60032 	lhu	a2,50(sp)
9d008124:	8ea60024 	lw	a2,36(s5)
9d008128:	7cc60400 	ext	a2,a2,0x10,0x1
9d00812c:	50c0ffa7 	beqzl	a2,9d007fcc <TCPProcess+0xa94>
9d008130:	97a60032 	lhu	a2,50(sp)
					{
						MyTCBStub.Flags.bTimerEnabled = 0;
9d008134:	2406ffef 	li	a2,-17
						MyTCBStub.Flags.bTXFIN = 0;
9d008138:	00461024 	and	v0,v0,a2
9d00813c:	7c025ac4 	ins	v0,zero,0xb,0x1
9d008140:	0b401ff2 	j	9d007fc8 <TCPProcess+0xa90>
9d008144:	ae420028 	sw	v0,40(s2)

			// A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more
			if(MyTCBStub.smState == TCP_FIN_WAIT_1)
			{
				// Check to see if our FIN has been ACKnowledged
				if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9d008148:	8ea20004 	lw	v0,4(s5)
9d00814c:	5622fdd4 	bnel	s1,v0,9d0078a0 <TCPProcess+0x368>
9d008150:	30840020 	andi	a0,a0,0x20
9d008154:	8ea20024 	lw	v0,36(s5)
9d008158:	7c420400 	ext	v0,v0,0x10,0x1
9d00815c:	5040fdd0 	beqzl	v0,9d0078a0 <TCPProcess+0x368>
9d008160:	30840020 	andi	a0,a0,0x20
				{
					// Reset our timer for forced closure if the remote node 
					// doesn't send us a FIN in a timely manner.
					MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
9d008164:	afa30038 	sw	v1,56(sp)
9d008168:	0f400b53 	jal	9d002d4c <TickGet>
9d00816c:	afa4003c 	sw	a0,60(sp)
					MyTCBStub.Flags.bTimerEnabled = 1;
9d008170:	93858023 	lbu	a1,-32733(gp)
				// Check to see if our FIN has been ACKnowledged
				if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
				{
					// Reset our timer for forced closure if the remote node 
					// doesn't send us a FIN in a timely manner.
					MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
9d008174:	24060030 	li	a2,48
					MyTCBStub.Flags.bTimerEnabled = 1;
9d008178:	70a63802 	mul	a3,a1,a2
9d00817c:	00f43021 	addu	a2,a3,s4
				// Check to see if our FIN has been ACKnowledged
				if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
				{
					// Reset our timer for forced closure if the remote node 
					// doesn't send us a FIN in a timely manner.
					MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
9d008180:	3c070017 	lui	a3,0x17
9d008184:	34e7d784 	ori	a3,a3,0xd784
9d008188:	00471021 	addu	v0,v0,a3
9d00818c:	ae42001c 	sw	v0,28(s2)
					MyTCBStub.Flags.bTimerEnabled = 1;
9d008190:	8cc20028 	lw	v0,40(a2)
					MyTCBStub.smState = TCP_FIN_WAIT_2;
9d008194:	24070009 	li	a3,9
9d008198:	acc70024 	sw	a3,36(a2)
				if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
				{
					// Reset our timer for forced closure if the remote node 
					// doesn't send us a FIN in a timely manner.
					MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
					MyTCBStub.Flags.bTimerEnabled = 1;
9d00819c:	24070001 	li	a3,1
9d0081a0:	7ce22104 	ins	v0,a3,0x4,0x1
9d0081a4:	acc20028 	sw	v0,40(a2)
9d0081a8:	8fa30038 	lw	v1,56(sp)
9d0081ac:	0b401e27 	j	9d00789c <TCPProcess+0x364>
9d0081b0:	8fa4003c 	lw	a0,60(sp)
				// However, some bad stacks may still keep sending 
				// us data indefinitely after ACKing our FIN.  To 
				// prevent this from locking up our socket, let's 
				// send a RST right now and close forcefully on 
				// our side.
				if(!(localHeaderFlags & FIN))
9d0081b4:	17c0fdba 	bnez	s8,9d0078a0 <TCPProcess+0x368>
9d0081b8:	30840020 	andi	a0,a0,0x20
				{
					MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
					SendTCP(RST | ACK, 0);
9d0081bc:	24040014 	li	a0,20
9d0081c0:	00002821 	move	a1,zero
9d0081c4:	0f401444 	jal	9d005110 <SendTCP>
9d0081c8:	aeb10004 	sw	s1,4(s5)
					CloseSocket();
9d0081cc:	0f40164c 	jal	9d005930 <CloseSocket>
9d0081d0:	00000000 	nop
9d0081d4:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d0081d8:	00000000 	nop
						MyTCB.txUnackedTail = MyTCBStub.txTail;
					}
				}
				else
				{
					wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9d0081dc:	010d4021 	addu	t0,t0,t5
9d0081e0:	010c4023 	subu	t0,t0,t4
					if(wTemp < MyTCBStub.txTail)
9d0081e4:	0102302b 	sltu	a2,t0,v0
9d0081e8:	10c0ff59 	beqz	a2,9d007f50 <TCPProcess+0xa18>
9d0081ec:	24060030 	li	a2,48
					{
						MyTCB.MySEQ += MyTCBStub.txTail - wTemp;
9d0081f0:	0b401fd0 	j	9d007f40 <TCPProcess+0xa08>
9d0081f4:	01684023 	subu	t0,t3,t0
				// Make sure there isn't a "FIN byte in our TX FIFO"
				if(MyTCBStub.Flags.bTXFIN == 0u)
				{
					// Convert retransmission timer to keep-alive timer
					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d0081f8:	0f400b53 	jal	9d002d4c <TickGet>
9d0081fc:	afa4003c 	sw	a0,60(sp)
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
9d008200:	93858023 	lbu	a1,-32733(gp)
9d008204:	24060030 	li	a2,48
9d008208:	70a63802 	mul	a3,a1,a2
9d00820c:	00f43021 	addu	a2,a3,s4
				// Make sure there isn't a "FIN byte in our TX FIFO"
				if(MyTCBStub.Flags.bTXFIN == 0u)
				{
					// Convert retransmission timer to keep-alive timer
					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9d008210:	3c07002f 	lui	a3,0x2f
9d008214:	34e7af08 	ori	a3,a3,0xaf08
9d008218:	00471021 	addu	v0,v0,a3
9d00821c:	ae42001c 	sw	v0,28(s2)
					#endif
					MyTCBStub.Flags.bTimerEnabled = 0;
9d008220:	8cc20028 	lw	v0,40(a2)
9d008224:	7c022104 	ins	v0,zero,0x4,0x1
9d008228:	acc20028 	sw	v0,40(a2)
9d00822c:	8fa30038 	lw	v1,56(sp)
9d008230:	0b401ff2 	j	9d007fc8 <TCPProcess+0xa90>
9d008234:	8fa4003c 	lw	a0,60(sp)
		if(MyTCBStub.smState != TCP_ESTABLISHED)
			MyTCBStub.rxTail = MyTCBStub.rxHead;

		if(MyTCBStub.Flags.bOneSegmentReceived)
		{
			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9d008238:	0f401444 	jal	9d005110 <SendTCP>
9d00823c:	24050001 	li	a1,1
			SyncTCB();
9d008240:	0f4013f5 	jal	9d004fd4 <SyncTCB>
9d008244:	00000000 	nop
9d008248:	0b401e8e 	j	9d007a38 <TCPProcess+0x500>
9d00824c:	00000000 	nop
			dwTemp = MyTCB.MySEQ + (DWORD)wTemp;

			// Drop the packet if it ACKs something we haven't sent
			if((LONG)(dwTemp - localAckNumber) < (LONG)0)
			{
				SendTCP(ACK, 0);
9d008250:	24040010 	li	a0,16
9d008254:	0f401444 	jal	9d005110 <SendTCP>
9d008258:	00002821 	move	a1,zero
9d00825c:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d008260:	00000000 	nop
						MyTCB.wFutureDataSize = len;
					else
						MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes;
					MyTCB.sHoleSize = wMissingBytes;
				}
				else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9d008264:	02e32821 	addu	a1,s7,v1
9d008268:	00442021 	addu	a0,v0,a0
9d00826c:	0085282a 	slt	a1,a0,a1
9d008270:	10a0fddb 	beqz	a1,9d0079e0 <TCPProcess+0x4a8>
9d008274:	0083202a 	slt	a0,a0,v1
				{
					// Make sure that there isn't a second hole between 
					// our future data and this TCP segment's future data
					if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9d008278:	1480fdd9 	bnez	a0,9d0079e0 <TCPProcess+0x4a8>
9d00827c:	00621023 	subu	v0,v1,v0
						MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize;
9d008280:	02e2b821 	addu	s7,s7,v0
9d008284:	0b401e78 	j	9d0079e0 <TCPProcess+0x4a8>
9d008288:	a6b70016 	sh	s7,22(s5)
			}
		
			// Record the hole is here
			if(MyTCB.sHoleSize == -1)
			{
				MyTCB.sHoleSize = wMissingBytes;
9d00828c:	a6b20024 	sh	s2,36(s5)
				MyTCB.wFutureDataSize = len;
9d008290:	0b401e78 	j	9d0079e0 <TCPProcess+0x4a8>
9d008294:	a6b70016 	sh	s7,22(s5)
					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
				}
			}
			else
			{
				TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9d008298:	90a5002c 	lbu	a1,44(a1)
9d00829c:	2406ffff 	li	a2,-1
9d0082a0:	00003821 	move	a3,zero
9d0082a4:	afa30038 	sw	v1,56(sp)
9d0082a8:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d0082ac:	afb70010 	sw	s7,16(sp)
9d0082b0:	0b401e66 	j	9d007998 <TCPProcess+0x460>
9d0082b4:	8fa30038 	lw	v1,56(sp)
				{
					if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize))
						MyTCB.wFutureDataSize = len;
					else
						MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes;
					MyTCB.sHoleSize = wMissingBytes;
9d0082b8:	0b401e78 	j	9d0079e0 <TCPProcess+0x4a8>
9d0082bc:	a6b20024 	sh	s2,36(s5)
					SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
					return;

				case TCP_ESTABLISHED:
					// Go to TCP_CLOSE_WAIT state
					MyTCBStub.smState = TCP_CLOSE_WAIT;
9d0082c0:	2402000b 	li	v0,11
					// For legacy applications that don't call 
					// TCPDisconnect() as needed and expect the TCP/IP 
					// Stack to automatically close sockets when the 
					// remote node sends a FIN, let's start a timer so 
					// that we will eventually close the socket automatically
					MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8);
9d0082c4:	0f400b5b 	jal	9d002d6c <TickGetDiv256>
9d0082c8:	ae820024 	sw	v0,36(s4)
9d0082cc:	244200f4 	addiu	v0,v0,244
9d0082d0:	0b401f74 	j	9d007dd0 <TCPProcess+0x898>
9d0082d4:	a6820022 	sh	v0,34(s4)
					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
					TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
				}
				else
				{
					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9d0082d8:	8ca20004 	lw	v0,4(a1)
9d0082dc:	2406ffff 	li	a2,-1
9d0082e0:	90a5002c 	lbu	a1,44(a1)
9d0082e4:	00e23823 	subu	a3,a3,v0
9d0082e8:	00073827 	nor	a3,zero,a3
9d0082ec:	0b4020a8 	j	9d0082a0 <TCPProcess+0xd68>
9d0082f0:	00872021 	addu	a0,a0,a3
	{
		// See if there are bytes we must skip
		if((SHORT)wMissingBytes <= 0)
		{
			// Position packet read pointer to start of useful data area.
			IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
9d0082f4:	8fa40030 	lw	a0,48(sp)
9d0082f8:	afa30038 	sw	v1,56(sp)
	
			MyTCB.RemoteSEQ += (DWORD)len;
		
			// Copy the application data from the packet into the socket RX FIFO
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9d0082fc:	24120030 	li	s2,48
	{
		// See if there are bytes we must skip
		if((SHORT)wMissingBytes <= 0)
		{
			// Position packet read pointer to start of useful data area.
			IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
9d008300:	7c841900 	ext	a0,a0,0x4,0x4
9d008304:	00042080 	sll	a0,a0,0x2
9d008308:	00832023 	subu	a0,a0,v1
9d00830c:	0f4024f1 	jal	9d0093c4 <IPSetRxBuffer>
9d008310:	3084ffff 	andi	a0,a0,0xffff
	
			MyTCB.RemoteSEQ += (DWORD)len;
		
			// Copy the application data from the packet into the socket RX FIFO
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9d008314:	93828023 	lbu	v0,-32733(gp)
		// See if there are bytes we must skip
		if((SHORT)wMissingBytes <= 0)
		{
			// Position packet read pointer to start of useful data area.
			IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
			len += wMissingBytes;		
9d008318:	8fa30038 	lw	v1,56(sp)
	
			MyTCB.RemoteSEQ += (DWORD)len;
		
			// Copy the application data from the packet into the socket RX FIFO
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9d00831c:	70522002 	mul	a0,v0,s2
		// See if there are bytes we must skip
		if((SHORT)wMissingBytes <= 0)
		{
			// Position packet read pointer to start of useful data area.
			IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
			len += wMissingBytes;		
9d008320:	02e31821 	addu	v1,s7,v1
9d008324:	3063ffff 	andi	v1,v1,0xffff
9d008328:	0073282b 	sltu	a1,v1,s3
9d00832c:	0065980b 	movn	s3,v1,a1
	
			MyTCB.RemoteSEQ += (DWORD)len;
		
			// Copy the application data from the packet into the socket RX FIFO
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9d008330:	00941021 	addu	v0,a0,s4
			// Truncate packets that would overflow our TCP RX FIFO
			// and request a retransmit by sending a duplicate ACK
			if(len > wFreeSpace)
				len = wFreeSpace;
	
			MyTCB.RemoteSEQ += (DWORD)len;
9d008334:	8ea40008 	lw	a0,8(s5)
		
			// Copy the application data from the packet into the socket RX FIFO
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9d008338:	8c570008 	lw	s7,8(v0)
			// Truncate packets that would overflow our TCP RX FIFO
			// and request a retransmit by sending a duplicate ACK
			if(len > wFreeSpace)
				len = wFreeSpace;
	
			MyTCB.RemoteSEQ += (DWORD)len;
9d00833c:	02641821 	addu	v1,s3,a0
		
			// Copy the application data from the packet into the socket RX FIFO
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9d008340:	8c440014 	lw	a0,20(v0)
			// Truncate packets that would overflow our TCP RX FIFO
			// and request a retransmit by sending a duplicate ACK
			if(len > wFreeSpace)
				len = wFreeSpace;
	
			MyTCB.RemoteSEQ += (DWORD)len;
9d008344:	aea30008 	sw	v1,8(s5)
		
			// Copy the application data from the packet into the socket RX FIFO
			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9d008348:	02641821 	addu	v1,s3,a0
9d00834c:	02e3182b 	sltu	v1,s7,v1
9d008350:	1060003e 	beqz	v1,9d00844c <TCPProcess+0xf14>
9d008354:	9045002c 	lbu	a1,44(v0)
			{
				wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1;
9d008358:	26f70001 	addiu	s7,s7,1
9d00835c:	02e4b823 	subu	s7,s7,a0
				TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9d008360:	32e2ffff 	andi	v0,s7,0xffff
9d008364:	2406ffff 	li	a2,-1
9d008368:	00003821 	move	a3,zero
9d00836c:	afa20010 	sw	v0,16(sp)
9d008370:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d008374:	afa20040 	sw	v0,64(sp)
				TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9d008378:	93838023 	lbu	v1,-32733(gp)
9d00837c:	8fa20040 	lw	v0,64(sp)
9d008380:	2406ffff 	li	a2,-1
9d008384:	70722002 	mul	a0,v1,s2
9d008388:	00003821 	move	a3,zero
9d00838c:	02621023 	subu	v0,s3,v0
9d008390:	3042ffff 	andi	v0,v0,0xffff
9d008394:	afa20010 	sw	v0,16(sp)
9d008398:	00941821 	addu	v1,a0,s4
9d00839c:	9065002c 	lbu	a1,44(v1)
9d0083a0:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d0083a4:	8c640004 	lw	a0,4(v1)
				MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp);
9d0083a8:	93858023 	lbu	a1,-32733(gp)
9d0083ac:	70b21002 	mul	v0,a1,s2
9d0083b0:	00549021 	addu	s2,v0,s4
9d0083b4:	8e420004 	lw	v0,4(s2)
9d0083b8:	0057b823 	subu	s7,v0,s7
9d0083bc:	02f3b821 	addu	s7,s7,s3
9d0083c0:	ae570014 	sw	s7,20(s2)
				TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
				MyTCBStub.rxHead += len;
			}
		
			// See if we have a hole and other data waiting already in the RX FIFO
			if(MyTCB.sHoleSize != -1)
9d0083c4:	86a40024 	lh	a0,36(s5)
9d0083c8:	2403ffff 	li	v1,-1
9d0083cc:	1083fd84 	beq	a0,v1,9d0079e0 <TCPProcess+0x4a8>
9d0083d0:	00000000 	nop
			{
				MyTCB.sHoleSize -= len;
				wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize;
9d0083d4:	96a20016 	lhu	v0,22(s5)
			}
		
			// See if we have a hole and other data waiting already in the RX FIFO
			if(MyTCB.sHoleSize != -1)
			{
				MyTCB.sHoleSize -= len;
9d0083d8:	00939823 	subu	s3,a0,s3
9d0083dc:	7c139e20 	seh	s3,s3
				wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize;
9d0083e0:	02621021 	addu	v0,s3,v0
		
				// See if we just closed up a hole, and if so, advance head pointer
				if((SHORT)wTemp < (SHORT)0)
9d0083e4:	7c022620 	seh	a0,v0
9d0083e8:	04800016 	bltz	a0,9d008444 <TCPProcess+0xf0c>
9d0083ec:	a6b30024 	sh	s3,36(s5)
				{
					MyTCB.sHoleSize = -1;
				}
				else if(MyTCB.sHoleSize <= 0)
9d0083f0:	1e60fd7b 	bgtz	s3,9d0079e0 <TCPProcess+0x4a8>
9d0083f4:	24030030 	li	v1,48
				{
					MyTCB.RemoteSEQ += wTemp;
					MyTCBStub.rxHead += wTemp;
9d0083f8:	70a32002 	mul	a0,a1,v1
				{
					MyTCB.sHoleSize = -1;
				}
				else if(MyTCB.sHoleSize <= 0)
				{
					MyTCB.RemoteSEQ += wTemp;
9d0083fc:	8ea30008 	lw	v1,8(s5)
9d008400:	00431821 	addu	v1,v0,v1
9d008404:	aea30008 	sw	v1,8(s5)
					MyTCBStub.rxHead += wTemp;
9d008408:	00942821 	addu	a1,a0,s4
9d00840c:	8ca40014 	lw	a0,20(a1)
					if(MyTCBStub.rxHead > MyTCBStub.bufferEnd)
9d008410:	8ca30008 	lw	v1,8(a1)
					MyTCB.sHoleSize = -1;
				}
				else if(MyTCB.sHoleSize <= 0)
				{
					MyTCB.RemoteSEQ += wTemp;
					MyTCBStub.rxHead += wTemp;
9d008414:	00441021 	addu	v0,v0,a0
					if(MyTCBStub.rxHead > MyTCBStub.bufferEnd)
9d008418:	0062202b 	sltu	a0,v1,v0
9d00841c:	10800006 	beqz	a0,9d008438 <TCPProcess+0xf00>
9d008420:	aca20014 	sw	v0,20(a1)
						MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;							
9d008424:	8ca40004 	lw	a0,4(a1)
9d008428:	00641823 	subu	v1,v1,a0
9d00842c:	00031827 	nor	v1,zero,v1
9d008430:	00431021 	addu	v0,v0,v1
9d008434:	aca20014 	sw	v0,20(a1)
					MyTCB.sHoleSize = -1;
9d008438:	2402ffff 	li	v0,-1
9d00843c:	0b401e78 	j	9d0079e0 <TCPProcess+0x4a8>
9d008440:	a6a20024 	sh	v0,36(s5)
				wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize;
		
				// See if we just closed up a hole, and if so, advance head pointer
				if((SHORT)wTemp < (SHORT)0)
				{
					MyTCB.sHoleSize = -1;
9d008444:	0b401e78 	j	9d0079e0 <TCPProcess+0x4a8>
9d008448:	a6a30024 	sh	v1,36(s5)
				TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
				MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp);
			}
			else
			{
				TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9d00844c:	2406ffff 	li	a2,-1
9d008450:	00003821 	move	a3,zero
9d008454:	0f4013ba 	jal	9d004ee8 <TCPRAMCopy>
9d008458:	afb30010 	sw	s3,16(sp)
				MyTCBStub.rxHead += len;
9d00845c:	93858023 	lbu	a1,-32733(gp)
9d008460:	70b21002 	mul	v0,a1,s2
9d008464:	00549021 	addu	s2,v0,s4
9d008468:	8e420014 	lw	v0,20(s2)
9d00846c:	02621021 	addu	v0,s3,v0
9d008470:	0b4020f1 	j	9d0083c4 <TCPProcess+0xe8c>
9d008474:	ae420014 	sw	v0,20(s2)
					// that we will eventually close the socket automatically
					MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8);
					break;
	
				case TCP_FIN_WAIT_1:
					if(MyTCB.MySEQ == localAckNumber)
9d008478:	8ea20004 	lw	v0,4(s5)
9d00847c:	12220003 	beq	s1,v0,9d00848c <TCPProcess+0xf54>
9d008480:	2402000a 	li	v0,10
						CloseSocket();
						return;
					}
					else
					{
						MyTCBStub.smState = TCP_CLOSING;
9d008484:	0b401f74 	j	9d007dd0 <TCPProcess+0x898>
9d008488:	ae820024 	sw	v0,36(s4)
						// leave a socket waiting around doing nothing 
						// for a long time.  If the remote node does 
						// not recieve this ACK, it'll have to figure 
						// out on it's own that the connection is now 
						// closed.
						SendTCP(ACK, 0);
9d00848c:	24040010 	li	a0,16
9d008490:	0f401444 	jal	9d005110 <SendTCP>
9d008494:	00002821 	move	a1,zero
						CloseSocket();
9d008498:	0f40164c 	jal	9d005930 <CloseSocket>
9d00849c:	00000000 	nop
9d0084a0:	0b401d71 	j	9d0075c4 <TCPProcess+0x8c>
9d0084a4:	00000000 	nop

9d0084a8 <_DHCPSend>:

  Returns:
	None
***************************************************************************/
static void _DHCPSend(BYTE messageType, BOOL bRenewing)
{
9d0084a8:	27bdffd8 	addiu	sp,sp,-40
9d0084ac:	afb00010 	sw	s0,16(sp)
9d0084b0:	00808021 	move	s0,a0
	BYTE i;
	IP_ADDR	MyIP;


	UDPPut(BOOT_REQUEST);                       // op
9d0084b4:	24040001 	li	a0,1

  Returns:
	None
***************************************************************************/
static void _DHCPSend(BYTE messageType, BOOL bRenewing)
{
9d0084b8:	afbf0024 	sw	ra,36(sp)
9d0084bc:	afb20018 	sw	s2,24(sp)
9d0084c0:	afb10014 	sw	s1,20(sp)
9d0084c4:	afb40020 	sw	s4,32(sp)
9d0084c8:	00a08821 	move	s1,a1
	BYTE i;
	IP_ADDR	MyIP;


	UDPPut(BOOT_REQUEST);                       // op
9d0084cc:	0f40125d 	jal	9d004974 <UDPPut>
9d0084d0:	afb3001c 	sw	s3,28(sp)
	UDPPut(BOOT_HW_TYPE);                       // htype
9d0084d4:	0f40125d 	jal	9d004974 <UDPPut>
9d0084d8:	24040001 	li	a0,1
	UDPPut(BOOT_LEN_OF_HW_TYPE);                // hlen
9d0084dc:	0f40125d 	jal	9d004974 <UDPPut>
9d0084e0:	24040006 	li	a0,6
	UDPPut(0);                                  // hops
9d0084e4:	0f40125d 	jal	9d004974 <UDPPut>
9d0084e8:	00002021 	move	a0,zero
	UDPPut(0x12);                               // xid[0]
9d0084ec:	0f40125d 	jal	9d004974 <UDPPut>
9d0084f0:	24040012 	li	a0,18
	UDPPut(0x23);                               // xid[1]
9d0084f4:	0f40125d 	jal	9d004974 <UDPPut>
9d0084f8:	24040023 	li	a0,35
	UDPPut(0x34);                               // xid[2]
9d0084fc:	0f40125d 	jal	9d004974 <UDPPut>
9d008500:	24040034 	li	a0,52
	UDPPut(0x56);                               // xid[3]
9d008504:	0f40125d 	jal	9d004974 <UDPPut>
9d008508:	24040056 	li	a0,86
	UDPPut(0);                                  // secs[0]
	UDPPut(0);                                  // secs[1]
	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
9d00850c:	3c12a001 	lui	s2,0xa001
	UDPPut(0);                                  // hops
	UDPPut(0x12);                               // xid[0]
	UDPPut(0x23);                               // xid[1]
	UDPPut(0x34);                               // xid[2]
	UDPPut(0x56);                               // xid[3]
	UDPPut(0);                                  // secs[0]
9d008510:	0f40125d 	jal	9d004974 <UDPPut>
9d008514:	00002021 	move	a0,zero
	UDPPut(0);                                  // secs[1]
	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
9d008518:	26529948 	addiu	s2,s2,-26296
	UDPPut(0x12);                               // xid[0]
	UDPPut(0x23);                               // xid[1]
	UDPPut(0x34);                               // xid[2]
	UDPPut(0x56);                               // xid[3]
	UDPPut(0);                                  // secs[0]
	UDPPut(0);                                  // secs[1]
9d00851c:	0f40125d 	jal	9d004974 <UDPPut>
9d008520:	00002021 	move	a0,zero
	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
9d008524:	8e440008 	lw	a0,8(s2)
9d008528:	24020080 	li	v0,128
9d00852c:	30840010 	andi	a0,a0,0x10
9d008530:	0004100b 	movn	v0,zero,a0
9d008534:	0f40125d 	jal	9d004974 <UDPPut>
9d008538:	00402021 	move	a0,v0
	UDPPut(0);                                  // flags[1]
9d00853c:	0f40125d 	jal	9d004974 <UDPPut>
9d008540:	00002021 	move	a0,zero

	// If this is DHCP REQUEST message, use previously allocated IP address.
	if((messageType == DHCP_REQUEST_MESSAGE) && bRenewing)
9d008544:	24020003 	li	v0,3
9d008548:	1202007f 	beq	s0,v0,9d008748 <_DHCPSend+0x2a0>
9d00854c:	00000000 	nop
	{
		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress));
	}
	else
	{
		UDPPut(0x00);
9d008550:	0f40125d 	jal	9d004974 <UDPPut>
9d008554:	00002021 	move	a0,zero
		UDPPut(0x00);
9d008558:	0f40125d 	jal	9d004974 <UDPPut>
9d00855c:	00002021 	move	a0,zero
		UDPPut(0x00);
9d008560:	0f40125d 	jal	9d004974 <UDPPut>
9d008564:	00002021 	move	a0,zero
		UDPPut(0x00);
9d008568:	0f40125d 	jal	9d004974 <UDPPut>
9d00856c:	00002021 	move	a0,zero
	UDPPut(0x23);                               // xid[1]
	UDPPut(0x34);                               // xid[2]
	UDPPut(0x56);                               // xid[3]
	UDPPut(0);                                  // secs[0]
	UDPPut(0);                                  // secs[1]
	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
9d008570:	0000a021 	move	s4,zero
		UDPPut(0x00);
		UDPPut(0x00);
	}

	// Set yiaddr, siaddr, giaddr as zeros,
	for ( i = 0; i < 12u; i++ )
9d008574:	2413000c 	li	s3,12
9d008578:	26940001 	addiu	s4,s4,1
		UDPPut(0x00);
9d00857c:	00002021 	move	a0,zero
9d008580:	0f40125d 	jal	9d004974 <UDPPut>
9d008584:	329400ff 	andi	s4,s4,0xff
		UDPPut(0x00);
		UDPPut(0x00);
	}

	// Set yiaddr, siaddr, giaddr as zeros,
	for ( i = 0; i < 12u; i++ )
9d008588:	5693fffc 	bnel	s4,s3,9d00857c <_DHCPSend+0xd4>
9d00858c:	26940001 	addiu	s4,s4,1
		UDPPut(0x00);

	// Load chaddr - Client hardware address.
	UDPPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9d008590:	3c04a001 	lui	a0,0xa001
9d008594:	24849a89 	addiu	a0,a0,-25975
9d008598:	0f401275 	jal	9d0049d4 <UDPPutArray>
9d00859c:	24050006 	li	a1,6

	// Set chaddr[6..15], sname and file as zeros.
	for ( i = 0; i < 202u; i++ )
9d0085a0:	0000a021 	move	s4,zero
9d0085a4:	241300ca 	li	s3,202
9d0085a8:	26940001 	addiu	s4,s4,1
		UDPPut(0);
9d0085ac:	00002021 	move	a0,zero
9d0085b0:	0f40125d 	jal	9d004974 <UDPPut>
9d0085b4:	329400ff 	andi	s4,s4,0xff

	// Load chaddr - Client hardware address.
	UDPPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));

	// Set chaddr[6..15], sname and file as zeros.
	for ( i = 0; i < 202u; i++ )
9d0085b8:	5693fffc 	bnel	s4,s3,9d0085ac <_DHCPSend+0x104>
9d0085bc:	26940001 	addiu	s4,s4,1
		UDPPut(0);

	// Load magic cookie as per RFC 1533.
	UDPPut(99);
9d0085c0:	0f40125d 	jal	9d004974 <UDPPut>
9d0085c4:	24040063 	li	a0,99
	UDPPut(130);
9d0085c8:	0f40125d 	jal	9d004974 <UDPPut>
9d0085cc:	24040082 	li	a0,130
	UDPPut(83);
9d0085d0:	0f40125d 	jal	9d004974 <UDPPut>
9d0085d4:	24040053 	li	a0,83
	UDPPut(99);
9d0085d8:	0f40125d 	jal	9d004974 <UDPPut>
9d0085dc:	24040063 	li	a0,99

	// Load message type.
	UDPPut(DHCP_MESSAGE_TYPE);
9d0085e0:	0f40125d 	jal	9d004974 <UDPPut>
9d0085e4:	24040035 	li	a0,53
	UDPPut(DHCP_MESSAGE_TYPE_LEN);
9d0085e8:	0f40125d 	jal	9d004974 <UDPPut>
9d0085ec:	24040001 	li	a0,1
	UDPPut(messageType);
9d0085f0:	0f40125d 	jal	9d004974 <UDPPut>
9d0085f4:	02002021 	move	a0,s0

	if(messageType == DHCP_DISCOVER_MESSAGE)
9d0085f8:	24020001 	li	v0,1
9d0085fc:	12020059 	beq	s0,v0,9d008764 <_DHCPSend+0x2bc>
9d008600:	24020003 	li	v0,3
		// Reset offered flag so we know to act upon the next valid offer
		DHCPClient.flags.bits.bOfferReceived = FALSE;
	}


	if((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing)
9d008604:	1202002b 	beq	s0,v0,9d0086b4 <_DHCPSend+0x20c>
9d008608:	00000000 	nop
	}

	// Load our interested parameters
	// This is hardcoded list.  If any new parameters are desired,
	// new lines must be added here.
	UDPPut(DHCP_PARAM_REQUEST_LIST);
9d00860c:	0f40125d 	jal	9d004974 <UDPPut>
9d008610:	24040037 	li	a0,55
	UDPPut(DHCP_PARAM_REQUEST_LIST_LEN);
9d008614:	0f40125d 	jal	9d004974 <UDPPut>
9d008618:	24040004 	li	a0,4
	UDPPut(DHCP_SUBNET_MASK);
9d00861c:	0f40125d 	jal	9d004974 <UDPPut>
9d008620:	24040001 	li	a0,1
	UDPPut(DHCP_ROUTER);
9d008624:	0f40125d 	jal	9d004974 <UDPPut>
9d008628:	24040003 	li	a0,3
	UDPPut(DHCP_DNS);
9d00862c:	0f40125d 	jal	9d004974 <UDPPut>
9d008630:	24040006 	li	a0,6
	UDPPut(DHCP_HOST_NAME);
9d008634:	0f40125d 	jal	9d004974 <UDPPut>
9d008638:	2404000c 	li	a0,12
	}

	// Add any new paramter request here.

	// End of Options.
	UDPPut(DHCP_END_OPTION);
9d00863c:	0f40125d 	jal	9d004974 <UDPPut>
9d008640:	240400ff 	li	a0,255

	// Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets)
	while(UDPTxCount < 300u)
9d008644:	97828166 	lhu	v0,-32410(gp)
9d008648:	2c42012c 	sltiu	v0,v0,300
9d00864c:	10400007 	beqz	v0,9d00866c <_DHCPSend+0x1c4>
9d008650:	3c10a001 	lui	s0,0xa001
		UDPPut(0); 
9d008654:	0f40125d 	jal	9d004974 <UDPPut>
9d008658:	00002021 	move	a0,zero

	// End of Options.
	UDPPut(DHCP_END_OPTION);

	// Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets)
	while(UDPTxCount < 300u)
9d00865c:	97828166 	lhu	v0,-32410(gp)
9d008660:	2c42012c 	sltiu	v0,v0,300
9d008664:	1440fffb 	bnez	v0,9d008654 <_DHCPSend+0x1ac>
9d008668:	3c10a001 	lui	s0,0xa001
		UDPPut(0); 

	// Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages.
	MyIP.Val = AppConfig.MyIPAddr.Val;
9d00866c:	26139a5c 	addiu	s3,s0,-26020
9d008670:	8a720003 	lwl	s2,3(s3)
	if(!bRenewing)
9d008674:	16200003 	bnez	s1,9d008684 <_DHCPSend+0x1dc>
9d008678:	9a129a5c 	lwr	s2,-26020(s0)
		AppConfig.MyIPAddr.Val = 0x00000000;
9d00867c:	aa600003 	swl	zero,3(s3)
9d008680:	ba009a5c 	swr	zero,-26020(s0)
	UDPFlush();
9d008684:	0f40128c 	jal	9d004a30 <UDPFlush>
9d008688:	00000000 	nop
	AppConfig.MyIPAddr.Val = MyIP.Val;

}
9d00868c:	8fbf0024 	lw	ra,36(sp)
	// Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages.
	MyIP.Val = AppConfig.MyIPAddr.Val;
	if(!bRenewing)
		AppConfig.MyIPAddr.Val = 0x00000000;
	UDPFlush();
	AppConfig.MyIPAddr.Val = MyIP.Val;
9d008690:	aa720003 	swl	s2,3(s3)
9d008694:	ba129a5c 	swr	s2,-26020(s0)

}
9d008698:	8fb40020 	lw	s4,32(sp)
9d00869c:	8fb3001c 	lw	s3,28(sp)
9d0086a0:	8fb20018 	lw	s2,24(sp)
9d0086a4:	8fb10014 	lw	s1,20(sp)
9d0086a8:	8fb00010 	lw	s0,16(sp)
9d0086ac:	03e00008 	jr	ra
9d0086b0:	27bd0028 	addiu	sp,sp,40
		// Reset offered flag so we know to act upon the next valid offer
		DHCPClient.flags.bits.bOfferReceived = FALSE;
	}


	if((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing)
9d0086b4:	1620ffd5 	bnez	s1,9d00860c <_DHCPSend+0x164>
9d0086b8:	24040036 	li	a0,54
		// receives DHCP OFFER message. We will simply use that
		// when we are replying to server.
		// If this is a renwal request, we must not include server id.
		UDPPut(DHCP_SERVER_IDENTIFIER);
		UDPPut(DHCP_SERVER_IDENTIFIER_LEN);
		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[3]);
9d0086bc:	3c12a001 	lui	s2,0xa001
		// to identify the server we are talking to.
		// _DHCPReceive() would populate "serverID" when it
		// receives DHCP OFFER message. We will simply use that
		// when we are replying to server.
		// If this is a renwal request, we must not include server id.
		UDPPut(DHCP_SERVER_IDENTIFIER);
9d0086c0:	0f40125d 	jal	9d004974 <UDPPut>
9d0086c4:	2650995c 	addiu	s0,s2,-26276
		UDPPut(DHCP_SERVER_IDENTIFIER_LEN);
9d0086c8:	0f40125d 	jal	9d004974 <UDPPut>
9d0086cc:	24040004 	li	a0,4
		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[3]);
9d0086d0:	0f40125d 	jal	9d004974 <UDPPut>
9d0086d4:	92040003 	lbu	a0,3(s0)
		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[2]);
9d0086d8:	0f40125d 	jal	9d004974 <UDPPut>
9d0086dc:	92040002 	lbu	a0,2(s0)
		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[1]);
9d0086e0:	0f40125d 	jal	9d004974 <UDPPut>
9d0086e4:	92040001 	lbu	a0,1(s0)
		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[0]);
9d0086e8:	0f40125d 	jal	9d004974 <UDPPut>
9d0086ec:	9244995c 	lbu	a0,-26276(s2)
	}

	// Load our interested parameters
	// This is hardcoded list.  If any new parameters are desired,
	// new lines must be added here.
	UDPPut(DHCP_PARAM_REQUEST_LIST);
9d0086f0:	0f40125d 	jal	9d004974 <UDPPut>
9d0086f4:	24040037 	li	a0,55
	UDPPut(DHCP_PARAM_REQUEST_LIST_LEN);
9d0086f8:	0f40125d 	jal	9d004974 <UDPPut>
9d0086fc:	24040004 	li	a0,4
	UDPPut(DHCP_SUBNET_MASK);
9d008700:	0f40125d 	jal	9d004974 <UDPPut>
9d008704:	24040001 	li	a0,1
	UDPPut(DHCP_ROUTER);
9d008708:	0f40125d 	jal	9d004974 <UDPPut>
9d00870c:	24040003 	li	a0,3
	UDPPut(DHCP_DNS);
9d008710:	0f40125d 	jal	9d004974 <UDPPut>
9d008714:	24040006 	li	a0,6
	UDPPut(DHCP_HOST_NAME);
9d008718:	0f40125d 	jal	9d004974 <UDPPut>
9d00871c:	2404000c 	li	a0,12

	// Add requested IP address to DHCP Request Message
	if( ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) || 
		((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val))
	{
		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS);
9d008720:	0f40125d 	jal	9d004974 <UDPPut>
9d008724:	24040032 	li	a0,50
		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9d008728:	0f40125d 	jal	9d004974 <UDPPut>
9d00872c:	24040004 	li	a0,4
		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9d008730:	3c04a001 	lui	a0,0xa001
9d008734:	24849960 	addiu	a0,a0,-26272
9d008738:	0f401275 	jal	9d0049d4 <UDPPutArray>
9d00873c:	24050004 	li	a1,4
9d008740:	0b40218f 	j	9d00863c <_DHCPSend+0x194>
9d008744:	00000000 	nop
	UDPPut(0);                                  // secs[1]
	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
	UDPPut(0);                                  // flags[1]

	// If this is DHCP REQUEST message, use previously allocated IP address.
	if((messageType == DHCP_REQUEST_MESSAGE) && bRenewing)
9d008748:	1220ff81 	beqz	s1,9d008550 <_DHCPSend+0xa8>
9d00874c:	3c04a001 	lui	a0,0xa001
	{
		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress));
9d008750:	24849960 	addiu	a0,a0,-26272
9d008754:	0f401275 	jal	9d0049d4 <UDPPutArray>
9d008758:	24050004 	li	a1,4
9d00875c:	0b40215d 	j	9d008574 <_DHCPSend+0xcc>
9d008760:	0000a021 	move	s4,zero
	UDPPut(messageType);

	if(messageType == DHCP_DISCOVER_MESSAGE)
	{
		// Reset offered flag so we know to act upon the next valid offer
		DHCPClient.flags.bits.bOfferReceived = FALSE;
9d008764:	8e420008 	lw	v0,8(s2)
	}

	// Load our interested parameters
	// This is hardcoded list.  If any new parameters are desired,
	// new lines must be added here.
	UDPPut(DHCP_PARAM_REQUEST_LIST);
9d008768:	24040037 	li	a0,55
	UDPPut(messageType);

	if(messageType == DHCP_DISCOVER_MESSAGE)
	{
		// Reset offered flag so we know to act upon the next valid offer
		DHCPClient.flags.bits.bOfferReceived = FALSE;
9d00876c:	7c021084 	ins	v0,zero,0x2,0x1
	}

	// Load our interested parameters
	// This is hardcoded list.  If any new parameters are desired,
	// new lines must be added here.
	UDPPut(DHCP_PARAM_REQUEST_LIST);
9d008770:	0f40125d 	jal	9d004974 <UDPPut>
9d008774:	ae420008 	sw	v0,8(s2)
	UDPPut(DHCP_PARAM_REQUEST_LIST_LEN);
9d008778:	0f40125d 	jal	9d004974 <UDPPut>
9d00877c:	24040004 	li	a0,4
	UDPPut(DHCP_SUBNET_MASK);
9d008780:	0f40125d 	jal	9d004974 <UDPPut>
9d008784:	24040001 	li	a0,1
	UDPPut(DHCP_ROUTER);
9d008788:	0f40125d 	jal	9d004974 <UDPPut>
9d00878c:	24040003 	li	a0,3
	UDPPut(DHCP_DNS);
9d008790:	0f40125d 	jal	9d004974 <UDPPut>
9d008794:	24040006 	li	a0,6
	UDPPut(DHCP_HOST_NAME);
9d008798:	0f40125d 	jal	9d004974 <UDPPut>
9d00879c:	2404000c 	li	a0,12

	// Add requested IP address to DHCP Request Message
	if( ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) || 
		((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val))
9d0087a0:	8e420018 	lw	v0,24(s2)
9d0087a4:	1040ffa5 	beqz	v0,9d00863c <_DHCPSend+0x194>
9d0087a8:	00000000 	nop
	{
		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS);
9d0087ac:	0f40125d 	jal	9d004974 <UDPPut>
9d0087b0:	24040032 	li	a0,50
		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9d0087b4:	0f40125d 	jal	9d004974 <UDPPut>
9d0087b8:	24040004 	li	a0,4
		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9d0087bc:	3c04a001 	lui	a0,0xa001
9d0087c0:	24849960 	addiu	a0,a0,-26272
9d0087c4:	0f401275 	jal	9d0049d4 <UDPPutArray>
9d0087c8:	24050004 	li	a1,4
9d0087cc:	0b40218f 	j	9d00863c <_DHCPSend+0x194>
9d0087d0:	00000000 	nop

9d0087d4 <_DHCPReceive>:

Returns:
  One of the DCHP_TYPE* contants.
***************************************************************************/
static BYTE _DHCPReceive(void)
{
9d0087d4:	27bdffc8 	addiu	sp,sp,-56


	// Assume unknown message until proven otherwise.
	type = DHCP_UNKNOWN_MESSAGE;

	UDPGet(&v);                             // op
9d0087d8:	27a40010 	addiu	a0,sp,16

Returns:
  One of the DCHP_TYPE* contants.
***************************************************************************/
static BYTE _DHCPReceive(void)
{
9d0087dc:	afbf0034 	sw	ra,52(sp)
9d0087e0:	afb60030 	sw	s6,48(sp)
9d0087e4:	afb5002c 	sw	s5,44(sp)
9d0087e8:	afb40028 	sw	s4,40(sp)
9d0087ec:	afb30024 	sw	s3,36(sp)
9d0087f0:	afb20020 	sw	s2,32(sp)
9d0087f4:	afb1001c 	sw	s1,28(sp)
9d0087f8:	afb00018 	sw	s0,24(sp)


	// Assume unknown message until proven otherwise.
	type = DHCP_UNKNOWN_MESSAGE;

	UDPGet(&v);                             // op
9d0087fc:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008800:	a3a00012 	sb	zero,18(sp)

	// Make sure this is BOOT_REPLY.
	if ( v == BOOT_REPLY )
9d008804:	93a30010 	lbu	v1,16(sp)
9d008808:	24020002 	li	v0,2
9d00880c:	1062001d 	beq	v1,v0,9d008884 <_DHCPReceive+0xb0>
9d008810:	3c10a001 	lui	s0,0xa001
9d008814:	26109948 	addiu	s0,s0,-26296
			}
		} while( !lbDone );
	}

	// If this is an OFFER message, remember current server id.
	if ( type == DHCP_OFFER_MESSAGE )
9d008818:	93a30012 	lbu	v1,18(sp)
9d00881c:	24020002 	li	v0,2
9d008820:	10620011 	beq	v1,v0,9d008868 <_DHCPReceive+0x94>
9d008824:	8fa20014 	lw	v0,20(sp)
	}
	else
	{
		// For other types of messages, make sure that received
		// server id matches with our previous one.
		if ( DHCPClient.dwServerID != tempServerID )
9d008828:	8e030014 	lw	v1,20(s0)
9d00882c:	54620001 	bnel	v1,v0,9d008834 <_DHCPReceive+0x60>
9d008830:	a3a00012 	sb	zero,18(sp)
			type = DHCP_UNKNOWN_MESSAGE;
	}

	UDPDiscard();                             // We are done with this packet
9d008834:	0f40132c 	jal	9d004cb0 <UDPDiscard>
9d008838:	00000000 	nop
	return type;
9d00883c:	93a20012 	lbu	v0,18(sp)

UDPInvalid:
	UDPDiscard();
	return DHCP_UNKNOWN_MESSAGE;
}
9d008840:	8fbf0034 	lw	ra,52(sp)
9d008844:	8fb60030 	lw	s6,48(sp)
9d008848:	8fb5002c 	lw	s5,44(sp)
9d00884c:	8fb40028 	lw	s4,40(sp)
9d008850:	8fb30024 	lw	s3,36(sp)
9d008854:	8fb20020 	lw	s2,32(sp)
9d008858:	8fb1001c 	lw	s1,28(sp)
9d00885c:	8fb00018 	lw	s0,24(sp)
9d008860:	03e00008 	jr	ra
9d008864:	27bd0038 	addiu	sp,sp,56

	// If this is an OFFER message, remember current server id.
	if ( type == DHCP_OFFER_MESSAGE )
	{
		DHCPClient.dwServerID = tempServerID;
		DHCPClient.flags.bits.bOfferReceived = TRUE;
9d008868:	8e020008 	lw	v0,8(s0)
9d00886c:	24030001 	li	v1,1
9d008870:	7c621084 	ins	v0,v1,0x2,0x1
	}

	// If this is an OFFER message, remember current server id.
	if ( type == DHCP_OFFER_MESSAGE )
	{
		DHCPClient.dwServerID = tempServerID;
9d008874:	8fa30014 	lw	v1,20(sp)
		DHCPClient.flags.bits.bOfferReceived = TRUE;
9d008878:	ae020008 	sw	v0,8(s0)
	}

	// If this is an OFFER message, remember current server id.
	if ( type == DHCP_OFFER_MESSAGE )
	{
		DHCPClient.dwServerID = tempServerID;
9d00887c:	0b40220d 	j	9d008834 <_DHCPReceive+0x60>
9d008880:	ae030014 	sw	v1,20(s0)
	if ( v == BOOT_REPLY )
	{
		// Jump to chaddr field (Client Hardware Address -- our MAC address for 
		// Ethernet and WiFi networks) and verify that this message is directed 
		// to us before doing any other processing.
		UDPSetRxBuffer(28);		// chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above
9d008884:	2404001c 	li	a0,28
9d008888:	3c11a001 	lui	s1,0xa001
9d00888c:	0f40123a 	jal	9d0048e8 <UDPSetRxBuffer>
9d008890:	3c10a001 	lui	s0,0xa001
9d008894:	26319a89 	addiu	s1,s1,-25975
  None

Returns:
  One of the DCHP_TYPE* contants.
***************************************************************************/
static BYTE _DHCPReceive(void)
9d008898:	26109a8f 	addiu	s0,s0,-25969
		// Ethernet and WiFi networks) and verify that this message is directed 
		// to us before doing any other processing.
		UDPSetRxBuffer(28);		// chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above
		for ( i = 0; i < 6u; i++ )
		{
			UDPGet(&v);
9d00889c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0088a0:	27a40010 	addiu	a0,sp,16
			if ( v != AppConfig.MyMACAddr.v[i])
9d0088a4:	92230000 	lbu	v1,0(s1)
9d0088a8:	93a20010 	lbu	v0,16(sp)
9d0088ac:	14620055 	bne	v1,v0,9d008a04 <_DHCPReceive+0x230>
9d0088b0:	26310001 	addiu	s1,s1,1
	{
		// Jump to chaddr field (Client Hardware Address -- our MAC address for 
		// Ethernet and WiFi networks) and verify that this message is directed 
		// to us before doing any other processing.
		UDPSetRxBuffer(28);		// chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above
		for ( i = 0; i < 6u; i++ )
9d0088b4:	1630fff9 	bne	s1,s0,9d00889c <_DHCPReceive+0xc8>
9d0088b8:	00000000 	nop
		}

		// Check to see if this is the first offer.  If it is, record its 
		// yiaddr value ("Your (client) IP address") so that we can REQUEST to 
		// use it later.
		if(!DHCPClient.flags.bits.bOfferReceived)
9d0088bc:	3c10a001 	lui	s0,0xa001
9d0088c0:	26109948 	addiu	s0,s0,-26296
9d0088c4:	8e020008 	lw	v0,8(s0)
9d0088c8:	30420004 	andi	v0,v0,0x4
9d0088cc:	104000a7 	beqz	v0,9d008b6c <_DHCPReceive+0x398>
9d0088d0:	00000000 	nop
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3]));
9d0088d4:	3c11a001 	lui	s1,0xa001
		}

		// Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags, 
		// ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic 
		// cookie fields)
		UDPSetRxBuffer(240);
9d0088d8:	240400f0 	li	a0,240
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3]));
9d0088dc:	26319958 	addiu	s1,s1,-26280
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway));
9d0088e0:	3c13a001 	lui	s3,0xa001
		}

		// Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags, 
		// ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic 
		// cookie fields)
		UDPSetRxBuffer(240);
9d0088e4:	0f40123a 	jal	9d0048e8 <UDPSetRxBuffer>
9d0088e8:	3c14a001 	lui	s4,0xa001
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3]));
9d0088ec:	26320003 	addiu	s2,s1,3
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway));
9d0088f0:	26739964 	addiu	s3,s3,-26268
						goto UDPInvalid;

					// Check to see if this is the first offer
					if(!DHCPClient.flags.bits.bOfferReceived)
					{
						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS));
9d0088f4:	2694996c 	addiu	s4,s4,-26260
					if(j >= 4u)
					{
						// Check to see if this is the first offer
						if(!DHCPClient.flags.bits.bOfferReceived)
						{
							UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2));
9d0088f8:	3c15a001 	lui	s5,0xa001
		do
		{
			// Get the Option number
			// Break out eventually in case if this is a malformed 
			// DHCP message, ie: missing DHCP_END_OPTION marker
			if(!UDPGet(&v))
9d0088fc:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008900:	27a40010 	addiu	a0,sp,16
9d008904:	1040ffc4 	beqz	v0,9d008818 <_DHCPReceive+0x44>
9d008908:	93a20010 	lbu	v0,16(sp)
			{
				lbDone = TRUE;
				break;
			}

			switch(v)
9d00890c:	24030033 	li	v1,51
9d008910:	10430050 	beq	v0,v1,9d008a54 <_DHCPReceive+0x280>
9d008914:	2c430034 	sltiu	v1,v0,52
9d008918:	10600025 	beqz	v1,9d0089b0 <_DHCPReceive+0x1dc>
9d00891c:	24030036 	li	v1,54
9d008920:	24030003 	li	v1,3
9d008924:	10430072 	beq	v0,v1,9d008af0 <_DHCPReceive+0x31c>
9d008928:	24030006 	li	v1,6
9d00892c:	1043005b 	beq	v0,v1,9d008a9c <_DHCPReceive+0x2c8>
9d008930:	24030001 	li	v1,1
9d008934:	1043000c 	beq	v0,v1,9d008968 <_DHCPReceive+0x194>
9d008938:	27a40011 	addiu	a0,sp,17
9d00893c:	0b402252 	j	9d008948 <_DHCPReceive+0x174>
9d008940:	00000000 	nop

				default:
					// Ignore all unsupport tags.
					UDPGet(&j);                     // Get option len
					while( j-- )                    // Ignore option values
						UDPGet(&v);
9d008944:	27a40010 	addiu	a0,sp,16
						goto UDPInvalid;
					break;

				default:
					// Ignore all unsupport tags.
					UDPGet(&j);                     // Get option len
9d008948:	0f4012fa 	jal	9d004be8 <UDPGet>
9d00894c:	00000000 	nop
					while( j-- )                    // Ignore option values
9d008950:	93a20011 	lbu	v0,17(sp)
9d008954:	2443ffff 	addiu	v1,v0,-1
9d008958:	1440fffa 	bnez	v0,9d008944 <_DHCPReceive+0x170>
9d00895c:	a3a30011 	sb	v1,17(sp)
9d008960:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d008964:	00000000 	nop
					else
						goto UDPInvalid;
					break;

				case DHCP_SUBNET_MASK:
					UDPGet(&v);                     // Skip len
9d008968:	0f4012fa 	jal	9d004be8 <UDPGet>
9d00896c:	27a40010 	addiu	a0,sp,16
					// Len must be 4.
					if ( v == 4u )
9d008970:	93a30010 	lbu	v1,16(sp)
9d008974:	24020004 	li	v0,4
9d008978:	14620022 	bne	v1,v0,9d008a04 <_DHCPReceive+0x230>
9d00897c:	00000000 	nop
					{
						// Check to see if this is the first offer
						if(DHCPClient.flags.bits.bOfferReceived)
9d008980:	8e020008 	lw	v0,8(s0)
9d008984:	30420004 	andi	v0,v0,0x4
9d008988:	1040008a 	beqz	v0,9d008bb4 <_DHCPReceive+0x3e0>
9d00898c:	24160004 	li	s6,4
						{
							// Discard offered IP mask, we already have an offer
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
9d008990:	26d6ffff 	addiu	s6,s6,-1
9d008994:	27a40010 	addiu	a0,sp,16
9d008998:	0f4012fa 	jal	9d004be8 <UDPGet>
9d00899c:	32d600ff 	andi	s6,s6,0xff
					{
						// Check to see if this is the first offer
						if(DHCPClient.flags.bits.bOfferReceived)
						{
							// Discard offered IP mask, we already have an offer
							for ( i = 0; i < 4u; i++ )
9d0089a0:	56c0fffc 	bnezl	s6,9d008994 <_DHCPReceive+0x1c0>
9d0089a4:	26d6ffff 	addiu	s6,s6,-1
9d0089a8:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d0089ac:	00000000 	nop
			{
				lbDone = TRUE;
				break;
			}

			switch(v)
9d0089b0:	10430018 	beq	v0,v1,9d008a14 <_DHCPReceive+0x240>
9d0089b4:	240300ff 	li	v1,255
9d0089b8:	1043ff97 	beq	v0,v1,9d008818 <_DHCPReceive+0x44>
9d0089bc:	24030035 	li	v1,53
9d0089c0:	1443ffe1 	bne	v0,v1,9d008948 <_DHCPReceive+0x174>
9d0089c4:	27a40011 	addiu	a0,sp,17
			{
				case DHCP_MESSAGE_TYPE:
					UDPGet(&v);                         // Skip len
9d0089c8:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0089cc:	27a40010 	addiu	a0,sp,16
					// Len must be 1.
					if ( v == 1u )
9d0089d0:	93a30010 	lbu	v1,16(sp)
9d0089d4:	24020001 	li	v0,1
9d0089d8:	1462000a 	bne	v1,v0,9d008a04 <_DHCPReceive+0x230>
9d0089dc:	00000000 	nop
					{
						UDPGet(&type);                  // Get type
9d0089e0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d0089e4:	27a40012 	addiu	a0,sp,18

						// Throw away the packet if we know we don't need it (ie: another offer when we already have one)
						if(DHCPClient.flags.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE))
9d0089e8:	8e020008 	lw	v0,8(s0)
9d0089ec:	30420004 	andi	v0,v0,0x4
9d0089f0:	1040ffc2 	beqz	v0,9d0088fc <_DHCPReceive+0x128>
9d0089f4:	93a30012 	lbu	v1,18(sp)
9d0089f8:	24020002 	li	v0,2
9d0089fc:	1462ffbf 	bne	v1,v0,9d0088fc <_DHCPReceive+0x128>
9d008a00:	00000000 	nop

	UDPDiscard();                             // We are done with this packet
	return type;

UDPInvalid:
	UDPDiscard();
9d008a04:	0f40132c 	jal	9d004cb0 <UDPDiscard>
9d008a08:	00000000 	nop
	return DHCP_UNKNOWN_MESSAGE;
9d008a0c:	0b402210 	j	9d008840 <_DHCPReceive+0x6c>
9d008a10:	00001021 	move	v0,zero
					//				}
					//
					//                break;

				case DHCP_SERVER_IDENTIFIER:
					UDPGet(&v);                         // Get len
9d008a14:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008a18:	27a40010 	addiu	a0,sp,16
					// Len must be 4.
					if ( v == 4u )
9d008a1c:	93a30010 	lbu	v1,16(sp)
9d008a20:	24020004 	li	v0,4
9d008a24:	1462fff7 	bne	v1,v0,9d008a04 <_DHCPReceive+0x230>
9d008a28:	00000000 	nop
					{
						UDPGet(&(((BYTE*)&tempServerID)[3]));   // Get the id
9d008a2c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008a30:	27a40017 	addiu	a0,sp,23
						UDPGet(&(((BYTE*)&tempServerID)[2]));
9d008a34:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008a38:	27a40016 	addiu	a0,sp,22
						UDPGet(&(((BYTE*)&tempServerID)[1]));
9d008a3c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008a40:	27a40015 	addiu	a0,sp,21
						UDPGet(&(((BYTE*)&tempServerID)[0]));
9d008a44:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008a48:	27a40014 	addiu	a0,sp,20
					}
					else
						goto UDPInvalid;
					break;
9d008a4c:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d008a50:	00000000 	nop
				case DHCP_END_OPTION:
					lbDone = TRUE;
					break;

				case DHCP_IP_LEASE_TIME:
					UDPGet(&v);                         // Get len
9d008a54:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008a58:	27a40010 	addiu	a0,sp,16
					// Len must be 4.
					if ( v == 4u )
9d008a5c:	93a30010 	lbu	v1,16(sp)
9d008a60:	24020004 	li	v0,4
9d008a64:	1462ffe7 	bne	v1,v0,9d008a04 <_DHCPReceive+0x230>
9d008a68:	00000000 	nop
					{
						// Check to see if this is the first offer
						if(DHCPClient.flags.bits.bOfferReceived)
9d008a6c:	8e020008 	lw	v0,8(s0)
9d008a70:	30420004 	andi	v0,v0,0x4
9d008a74:	10400071 	beqz	v0,9d008c3c <_DHCPReceive+0x468>
9d008a78:	24160004 	li	s6,4
						{
							// Discard offered lease time, we already have an offer
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
9d008a7c:	26d6ffff 	addiu	s6,s6,-1
9d008a80:	27a40010 	addiu	a0,sp,16
9d008a84:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008a88:	32d600ff 	andi	s6,s6,0xff
					{
						// Check to see if this is the first offer
						if(DHCPClient.flags.bits.bOfferReceived)
						{
							// Discard offered lease time, we already have an offer
							for ( i = 0; i < 4u; i++ )
9d008a8c:	56c0fffc 	bnezl	s6,9d008a80 <_DHCPReceive+0x2ac>
9d008a90:	26d6ffff 	addiu	s6,s6,-1
9d008a94:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d008a98:	00000000 	nop
						UDPGet(&v);
					break;

				#if defined(STACK_USE_DNS)
				case DHCP_DNS:
					UDPGet(&j);
9d008a9c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008aa0:	27a40011 	addiu	a0,sp,17
					// Len must be >= 4.
					if(j < 4u)
9d008aa4:	93a20011 	lbu	v0,17(sp)
9d008aa8:	2c430004 	sltiu	v1,v0,4
9d008aac:	1460ffd5 	bnez	v1,9d008a04 <_DHCPReceive+0x230>
9d008ab0:	00000000 	nop
						goto UDPInvalid;

					// Check to see if this is the first offer
					if(!DHCPClient.flags.bits.bOfferReceived)
9d008ab4:	8e030008 	lw	v1,8(s0)
9d008ab8:	30630004 	andi	v1,v1,0x4
9d008abc:	10600046 	beqz	v1,9d008bd8 <_DHCPReceive+0x404>
9d008ac0:	02802021 	move	a0,s4
							j -= 4;
						}
					}

					// Discard any other DNS server addresses
					while(j--)
9d008ac4:	2443ffff 	addiu	v1,v0,-1
9d008ac8:	1040ff8c 	beqz	v0,9d0088fc <_DHCPReceive+0x128>
9d008acc:	a3a30011 	sb	v1,17(sp)
						UDPGet(&v);
9d008ad0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008ad4:	27a40010 	addiu	a0,sp,16
							j -= 4;
						}
					}

					// Discard any other DNS server addresses
					while(j--)
9d008ad8:	93a20011 	lbu	v0,17(sp)
9d008adc:	2443ffff 	addiu	v1,v0,-1
9d008ae0:	1440fffb 	bnez	v0,9d008ad0 <_DHCPReceive+0x2fc>
9d008ae4:	a3a30011 	sb	v1,17(sp)
9d008ae8:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d008aec:	00000000 	nop
					else
						goto UDPInvalid;
					break;

				case DHCP_ROUTER:
					UDPGet(&j);
9d008af0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008af4:	27a40011 	addiu	a0,sp,17
					// Len must be >= 4.
					if ( j >= 4u )
9d008af8:	93a20011 	lbu	v0,17(sp)
9d008afc:	2c420004 	sltiu	v0,v0,4
9d008b00:	1440ffc0 	bnez	v0,9d008a04 <_DHCPReceive+0x230>
9d008b04:	00000000 	nop
					{
						// Check to see if this is the first offer
						if(DHCPClient.flags.bits.bOfferReceived)
9d008b08:	8e020008 	lw	v0,8(s0)
9d008b0c:	30420004 	andi	v0,v0,0x4
9d008b10:	10400021 	beqz	v0,9d008b98 <_DHCPReceive+0x3c4>
9d008b14:	02602021 	move	a0,s3
9d008b18:	24160004 	li	s6,4
						{
							// Discard offered Gateway address, we already have an offer
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
9d008b1c:	26d6ffff 	addiu	s6,s6,-1
9d008b20:	27a40010 	addiu	a0,sp,16
9d008b24:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008b28:	32d600ff 	andi	s6,s6,0xff
					{
						// Check to see if this is the first offer
						if(DHCPClient.flags.bits.bOfferReceived)
						{
							// Discard offered Gateway address, we already have an offer
							for ( i = 0; i < 4u; i++ )
9d008b2c:	56c0fffc 	bnezl	s6,9d008b20 <_DHCPReceive+0x34c>
9d008b30:	26d6ffff 	addiu	s6,s6,-1
					}
					else
						goto UDPInvalid;

					// Discard any other router addresses.
					j -= 4;
9d008b34:	93a20011 	lbu	v0,17(sp)
9d008b38:	2442fffc 	addiu	v0,v0,-4
9d008b3c:	304200ff 	andi	v0,v0,0xff
					while(j--)
9d008b40:	2443ffff 	addiu	v1,v0,-1
9d008b44:	1040ff6d 	beqz	v0,9d0088fc <_DHCPReceive+0x128>
9d008b48:	a3a30011 	sb	v1,17(sp)
						UDPGet(&v);
9d008b4c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008b50:	27a40010 	addiu	a0,sp,16
					else
						goto UDPInvalid;

					// Discard any other router addresses.
					j -= 4;
					while(j--)
9d008b54:	93a20011 	lbu	v0,17(sp)
9d008b58:	2443ffff 	addiu	v1,v0,-1
9d008b5c:	1440fffb 	bnez	v0,9d008b4c <_DHCPReceive+0x378>
9d008b60:	a3a30011 	sb	v1,17(sp)
9d008b64:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d008b68:	00000000 	nop
		// Check to see if this is the first offer.  If it is, record its 
		// yiaddr value ("Your (client) IP address") so that we can REQUEST to 
		// use it later.
		if(!DHCPClient.flags.bits.bOfferReceived)
		{
			UDPSetRxBuffer(16);
9d008b6c:	0f40123a 	jal	9d0048e8 <UDPSetRxBuffer>
9d008b70:	24040010 	li	a0,16
			UDPGetArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress));
9d008b74:	3c04a001 	lui	a0,0xa001
9d008b78:	24849960 	addiu	a0,a0,-26272
9d008b7c:	0f401313 	jal	9d004c4c <UDPGetArray>
9d008b80:	24050004 	li	a1,4
			DHCPClient.validValues.bits.IPAddress = 1;
9d008b84:	8e02002c 	lw	v0,44(s0)
9d008b88:	2403ffff 	li	v1,-1
9d008b8c:	7c620004 	ins	v0,v1,0x0,0x1
9d008b90:	0b402235 	j	9d0088d4 <_DHCPReceive+0x100>
9d008b94:	ae02002c 	sw	v0,44(s0)
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway));
9d008b98:	0f401313 	jal	9d004c4c <UDPGetArray>
9d008b9c:	24050004 	li	a1,4
							DHCPClient.validValues.bits.Gateway = 1;
9d008ba0:	8e02002c 	lw	v0,44(s0)
9d008ba4:	2403ffff 	li	v1,-1
9d008ba8:	7c620844 	ins	v0,v1,0x1,0x1
9d008bac:	0b4022cd 	j	9d008b34 <_DHCPReceive+0x360>
9d008bb0:	ae02002c 	sw	v0,44(s0)
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGetArray((BYTE*)&DHCPClient.tempMask, sizeof(DHCPClient.tempMask));
9d008bb4:	3c04a001 	lui	a0,0xa001
9d008bb8:	24849968 	addiu	a0,a0,-26264
9d008bbc:	0f401313 	jal	9d004c4c <UDPGetArray>
9d008bc0:	24050004 	li	a1,4
							DHCPClient.validValues.bits.Mask = 1;
9d008bc4:	8e02002c 	lw	v0,44(s0)
9d008bc8:	2403ffff 	li	v1,-1
9d008bcc:	7c621084 	ins	v0,v1,0x2,0x1
9d008bd0:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d008bd4:	ae02002c 	sw	v0,44(s0)
						goto UDPInvalid;

					// Check to see if this is the first offer
					if(!DHCPClient.flags.bits.bOfferReceived)
					{
						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS));
9d008bd8:	0f401313 	jal	9d004c4c <UDPGetArray>
9d008bdc:	24050004 	li	a1,4
						DHCPClient.validValues.bits.DNS = 1;
						j -= 4;
9d008be0:	93a20011 	lbu	v0,17(sp)

					// Check to see if this is the first offer
					if(!DHCPClient.flags.bits.bOfferReceived)
					{
						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS));
						DHCPClient.validValues.bits.DNS = 1;
9d008be4:	8e03002c 	lw	v1,44(s0)
9d008be8:	2416ffff 	li	s6,-1
						j -= 4;
9d008bec:	2442fffc 	addiu	v0,v0,-4
9d008bf0:	304200ff 	andi	v0,v0,0xff

					// Check to see if this is the first offer
					if(!DHCPClient.flags.bits.bOfferReceived)
					{
						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS));
						DHCPClient.validValues.bits.DNS = 1;
9d008bf4:	7ec318c4 	ins	v1,s6,0x3,0x1
						j -= 4;
					}

					// Len must be >= 4 for a secondary DNS server address
					if(j >= 4u)
9d008bf8:	2c440004 	sltiu	a0,v0,4

					// Check to see if this is the first offer
					if(!DHCPClient.flags.bits.bOfferReceived)
					{
						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS));
						DHCPClient.validValues.bits.DNS = 1;
9d008bfc:	ae03002c 	sw	v1,44(s0)
						j -= 4;
					}

					// Len must be >= 4 for a secondary DNS server address
					if(j >= 4u)
9d008c00:	1480ffb0 	bnez	a0,9d008ac4 <_DHCPReceive+0x2f0>
9d008c04:	a3a20011 	sb	v0,17(sp)
9d008c08:	8e020008 	lw	v0,8(s0)
					{
						// Check to see if this is the first offer
						if(!DHCPClient.flags.bits.bOfferReceived)
9d008c0c:	30420004 	andi	v0,v0,0x4
9d008c10:	14400017 	bnez	v0,9d008c70 <_DHCPReceive+0x49c>
9d008c14:	26a49970 	addiu	a0,s5,-26256
						{
							UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2));
9d008c18:	0f401313 	jal	9d004c4c <UDPGetArray>
9d008c1c:	24050004 	li	a1,4
							DHCPClient.validValues.bits.DNS2 = 1;
9d008c20:	8e03002c 	lw	v1,44(s0)
							j -= 4;
9d008c24:	93a20011 	lbu	v0,17(sp)
					{
						// Check to see if this is the first offer
						if(!DHCPClient.flags.bits.bOfferReceived)
						{
							UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2));
							DHCPClient.validValues.bits.DNS2 = 1;
9d008c28:	7ec32104 	ins	v1,s6,0x4,0x1
							j -= 4;
9d008c2c:	2442fffc 	addiu	v0,v0,-4
					{
						// Check to see if this is the first offer
						if(!DHCPClient.flags.bits.bOfferReceived)
						{
							UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2));
							DHCPClient.validValues.bits.DNS2 = 1;
9d008c30:	ae03002c 	sw	v1,44(s0)
							j -= 4;
9d008c34:	0b4022b1 	j	9d008ac4 <_DHCPReceive+0x2f0>
9d008c38:	304200ff 	andi	v0,v0,0xff
							for ( i = 0; i < 4u; i++ )
								UDPGet(&v);
						}
						else
						{
							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3]));
9d008c3c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008c40:	02402021 	move	a0,s2
							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[2]));
9d008c44:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008c48:	26240002 	addiu	a0,s1,2
							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[1]));
9d008c4c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008c50:	26240001 	addiu	a0,s1,1
							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[0]));
9d008c54:	0f4012fa 	jal	9d004be8 <UDPGet>
9d008c58:	02202021 	move	a0,s1

							// In case if our clock is not as accurate as the remote 
							// DHCP server's clock, let's treat the lease time as only 
							// 96.875% of the value given
							DHCPClient.dwLeaseTime -= DHCPClient.dwLeaseTime>>5;
9d008c5c:	8e020010 	lw	v0,16(s0)
9d008c60:	00021942 	srl	v1,v0,0x5
9d008c64:	00431023 	subu	v0,v0,v1
9d008c68:	0b40223f 	j	9d0088fc <_DHCPReceive+0x128>
9d008c6c:	ae020010 	sw	v0,16(s0)
9d008c70:	0b4022b1 	j	9d008ac4 <_DHCPReceive+0x2f0>
9d008c74:	93a20011 	lbu	v0,17(sp)

9d008c78 <DHCPInit>:
{
	BYTE i;
	
	// Upon the first call after POR, we must reset all handles to invalid so 
	// that we don't inadvertently close someone else's handle.
	if(!DHCPClientInitializedOnce)
9d008c78:	8f8280fc 	lw	v0,-32516(gp)
  Remarks:
	This function may be called multiple times throughout the life of the 
	application, if desired.  
***************************************************************************/
void DHCPInit(BYTE vInterface)
{
9d008c7c:	27bdffe8 	addiu	sp,sp,-24
9d008c80:	afbf0014 	sw	ra,20(sp)
	BYTE i;
	
	// Upon the first call after POR, we must reset all handles to invalid so 
	// that we don't inadvertently close someone else's handle.
	if(!DHCPClientInitializedOnce)
9d008c84:	14400012 	bnez	v0,9d008cd0 <DHCPInit+0x58>
9d008c88:	afb00010 	sw	s0,16(sp)
	{
		DHCPClientInitializedOnce = TRUE;
9d008c8c:	24020001 	li	v0,1
		for(i = 0; i < NETWORK_INTERFACES; i++)
		{
			LoadState(i);
			DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9d008c90:	3c10a001 	lui	s0,0xa001
	
	// Upon the first call after POR, we must reset all handles to invalid so 
	// that we don't inadvertently close someone else's handle.
	if(!DHCPClientInitializedOnce)
	{
		DHCPClientInitializedOnce = TRUE;
9d008c94:	af8280fc 	sw	v0,-32516(gp)
		for(i = 0; i < NETWORK_INTERFACES; i++)
		{
			LoadState(i);
			DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9d008c98:	2402ffff 	li	v0,-1
9d008c9c:	a2029948 	sb	v0,-26296(s0)
		UDPClose(DHCPClient.hDHCPSocket);
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
	}

	// Reset state machine and flags to default values
	DHCPClient.smState = SM_DHCP_GET_SOCKET;
9d008ca0:	26109948 	addiu	s0,s0,-26296
	DHCPClient.flags.val = 0;
9d008ca4:	a2000008 	sb	zero,8(s0)
	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode.
9d008ca8:	8e020008 	lw	v0,8(s0)
	DHCPClient.flags.bits.bEvent = TRUE;
}
9d008cac:	8fbf0014 	lw	ra,20(sp)
		UDPClose(DHCPClient.hDHCPSocket);
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
	}

	// Reset state machine and flags to default values
	DHCPClient.smState = SM_DHCP_GET_SOCKET;
9d008cb0:	24030001 	li	v1,1
	DHCPClient.flags.val = 0;
	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode.
	DHCPClient.flags.bits.bEvent = TRUE;
9d008cb4:	34420010 	ori	v0,v0,0x10
9d008cb8:	7c620844 	ins	v0,v1,0x1,0x1
		UDPClose(DHCPClient.hDHCPSocket);
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
	}

	// Reset state machine and flags to default values
	DHCPClient.smState = SM_DHCP_GET_SOCKET;
9d008cbc:	ae030004 	sw	v1,4(s0)
	DHCPClient.flags.val = 0;
	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode.
	DHCPClient.flags.bits.bEvent = TRUE;
9d008cc0:	ae020008 	sw	v0,8(s0)
}
9d008cc4:	8fb00010 	lw	s0,16(sp)
9d008cc8:	03e00008 	jr	ra
9d008ccc:	27bd0018 	addiu	sp,sp,24
	}
	
	
	LoadState(vInterface);
	
	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET)
9d008cd0:	3c10a001 	lui	s0,0xa001
9d008cd4:	92049948 	lbu	a0,-26296(s0)
9d008cd8:	240200ff 	li	v0,255
9d008cdc:	5082fff1 	beql	a0,v0,9d008ca4 <DHCPInit+0x2c>
9d008ce0:	26109948 	addiu	s0,s0,-26296
	{
		UDPClose(DHCPClient.hDHCPSocket);
9d008ce4:	0f40121f 	jal	9d00487c <UDPClose>
9d008ce8:	00000000 	nop
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9d008cec:	2402ffff 	li	v0,-1
9d008cf0:	a2029948 	sb	v0,-26296(s0)
	}

	// Reset state machine and flags to default values
	DHCPClient.smState = SM_DHCP_GET_SOCKET;
9d008cf4:	26109948 	addiu	s0,s0,-26296
	DHCPClient.flags.val = 0;
9d008cf8:	a2000008 	sb	zero,8(s0)
	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode.
9d008cfc:	8e020008 	lw	v0,8(s0)
	DHCPClient.flags.bits.bEvent = TRUE;
}
9d008d00:	8fbf0014 	lw	ra,20(sp)
		UDPClose(DHCPClient.hDHCPSocket);
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
	}

	// Reset state machine and flags to default values
	DHCPClient.smState = SM_DHCP_GET_SOCKET;
9d008d04:	24030001 	li	v1,1
	DHCPClient.flags.val = 0;
	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode.
	DHCPClient.flags.bits.bEvent = TRUE;
9d008d08:	34420010 	ori	v0,v0,0x10
9d008d0c:	7c620844 	ins	v0,v1,0x1,0x1
		UDPClose(DHCPClient.hDHCPSocket);
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
	}

	// Reset state machine and flags to default values
	DHCPClient.smState = SM_DHCP_GET_SOCKET;
9d008d10:	ae030004 	sw	v1,4(s0)
	DHCPClient.flags.val = 0;
	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode.
	DHCPClient.flags.bits.bEvent = TRUE;
9d008d14:	ae020008 	sw	v0,8(s0)
}
9d008d18:	8fb00010 	lw	s0,16(sp)
9d008d1c:	03e00008 	jr	ra
9d008d20:	27bd0018 	addiu	sp,sp,24

9d008d24 <DHCPDisable>:
	that the lease may expire and the DHCP server provide the IP to another
	client.  The application should replace the current IP address and other
	configuration with static information following a call to this function.
***************************************************************************/
void DHCPDisable(BYTE vInterface)
{
9d008d24:	27bdffe8 	addiu	sp,sp,-24
9d008d28:	afb00010 	sw	s0,16(sp)
	LoadState(vInterface);

	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET)
9d008d2c:	3c10a001 	lui	s0,0xa001
9d008d30:	92049948 	lbu	a0,-26296(s0)
9d008d34:	240200ff 	li	v0,255
9d008d38:	10820005 	beq	a0,v0,9d008d50 <DHCPDisable+0x2c>
9d008d3c:	afbf0014 	sw	ra,20(sp)
	{
		UDPClose(DHCPClient.hDHCPSocket);
9d008d40:	0f40121f 	jal	9d00487c <UDPClose>
9d008d44:	00000000 	nop
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9d008d48:	2402ffff 	li	v0,-1
9d008d4c:	a2029948 	sb	v0,-26296(s0)
	}

	DHCPClient.smState = SM_DHCP_DISABLED;
}
9d008d50:	8fbf0014 	lw	ra,20(sp)
	{
		UDPClose(DHCPClient.hDHCPSocket);
		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
	}

	DHCPClient.smState = SM_DHCP_DISABLED;
9d008d54:	26109948 	addiu	s0,s0,-26296
9d008d58:	ae000004 	sw	zero,4(s0)
}
9d008d5c:	8fb00010 	lw	s0,16(sp)
9d008d60:	03e00008 	jr	ra
9d008d64:	27bd0018 	addiu	sp,sp,24

9d008d68 <DHCPIsBound>:
	FALSE - No IP address is currently leased
***************************************************************************/
BOOL DHCPIsBound(BYTE vInterface)
{
	LoadState(vInterface);
	return DHCPClient.flags.bits.bIsBound;
9d008d68:	3c02a001 	lui	v0,0xa001
9d008d6c:	8c429950 	lw	v0,-26288(v0)
}
9d008d70:	03e00008 	jr	ra
9d008d74:	30420001 	andi	v0,v0,0x1

9d008d78 <DHCPTask>:

  Returns:
	None
***************************************************************************/
void DHCPTask(void)
{
9d008d78:	27bdffe0 	addiu	sp,sp,-32
9d008d7c:	afb00014 	sw	s0,20(sp)
	BYTE i;
	
	for(i = 0; i < NETWORK_INTERFACES; i++)
	{
		LoadState(i);
		switch(DHCPClient.smState)
9d008d80:	3c10a001 	lui	s0,0xa001

  Returns:
	None
***************************************************************************/
void DHCPTask(void)
{
9d008d84:	afb10018 	sw	s1,24(sp)
	BYTE i;
	
	for(i = 0; i < NETWORK_INTERFACES; i++)
	{
		LoadState(i);
		switch(DHCPClient.smState)
9d008d88:	26119948 	addiu	s1,s0,-26296
9d008d8c:	8e220004 	lw	v0,4(s1)
9d008d90:	2c43000d 	sltiu	v1,v0,13
9d008d94:	1060003e 	beqz	v1,9d008e90 <DHCPTask+0x118>
9d008d98:	afbf001c 	sw	ra,28(sp)
9d008d9c:	3c039d01 	lui	v1,0x9d01
9d008da0:	00021080 	sll	v0,v0,0x2
9d008da4:	2463dd00 	addiu	v1,v1,-8960
9d008da8:	00621021 	addu	v0,v1,v0
9d008dac:	8c420000 	lw	v0,0(v0)
9d008db0:	00400008 	jr	v0
9d008db4:	00000000 	nop
				DHCPClient.smState = SM_DHCP_GET_REQUEST_ACK;
				break;
	
			case SM_DHCP_GET_REQUEST_ACK:
				// Check to see if a packet has arrived
				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
9d008db8:	92049948 	lbu	a0,-26296(s0)
9d008dbc:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d008dc0:	3c10a001 	lui	s0,0xa001
9d008dc4:	2c4200fa 	sltiu	v0,v0,250
9d008dc8:	144000db 	bnez	v0,9d009138 <DHCPTask+0x3c0>
9d008dcc:	00000000 	nop
						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
					break;
				}
	
				// Check to see if we received an offer
				switch(_DHCPReceive())
9d008dd0:	0f4021f5 	jal	9d0087d4 <_DHCPReceive>
9d008dd4:	00000000 	nop
9d008dd8:	24030005 	li	v1,5
9d008ddc:	144300d2 	bne	v0,v1,9d009128 <DHCPTask+0x3b0>
9d008de0:	24030006 	li	v1,6
				{
					case DHCP_ACK_MESSAGE:
						UDPClose(DHCPClient.hDHCPSocket);
9d008de4:	0f40121f 	jal	9d00487c <UDPClose>
9d008de8:	92049948 	lbu	a0,-26296(s0)
						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9d008dec:	2402ffff 	li	v0,-1
						DHCPClient.dwTimer = TickGet();
9d008df0:	0f400b53 	jal	9d002d4c <TickGet>
9d008df4:	a2029948 	sb	v0,-26296(s0)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
9d008df8:	8e240008 	lw	a0,8(s1)
						DHCPClient.flags.bits.bIsBound = TRUE;	

						if(DHCPClient.validValues.bits.IPAddress)
9d008dfc:	8e23002c 	lw	v1,44(s1)
						UDPClose(DHCPClient.hDHCPSocket);
						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
						DHCPClient.dwTimer = TickGet();
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
						DHCPClient.flags.bits.bIsBound = TRUE;	
9d008e00:	24050001 	li	a1,1
9d008e04:	34840002 	ori	a0,a0,0x2
9d008e08:	7ca40004 	ins	a0,a1,0x0,0x1
				switch(_DHCPReceive())
				{
					case DHCP_ACK_MESSAGE:
						UDPClose(DHCPClient.hDHCPSocket);
						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
						DHCPClient.dwTimer = TickGet();
9d008e0c:	ae22000c 	sw	v0,12(s1)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
						DHCPClient.flags.bits.bIsBound = TRUE;	

						if(DHCPClient.validValues.bits.IPAddress)
9d008e10:	30650001 	andi	a1,v1,0x1
				{
					case DHCP_ACK_MESSAGE:
						UDPClose(DHCPClient.hDHCPSocket);
						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
						DHCPClient.dwTimer = TickGet();
						DHCPClient.smState = SM_DHCP_BOUND;
9d008e14:	24020006 	li	v0,6
9d008e18:	ae220004 	sw	v0,4(s1)
						DHCPClient.flags.bits.bEvent = 1;
						DHCPClient.flags.bits.bIsBound = TRUE;	

						if(DHCPClient.validValues.bits.IPAddress)
9d008e1c:	14a000eb 	bnez	a1,9d0091cc <DHCPTask+0x454>
9d008e20:	ae240008 	sw	a0,8(s1)
9d008e24:	3c02a001 	lui	v0,0xa001
9d008e28:	24429a5c 	addiu	v0,v0,-26020
							AppConfig.MyIPAddr = DHCPClient.tempIPAddress;
						if(DHCPClient.validValues.bits.Mask)
9d008e2c:	30640004 	andi	a0,v1,0x4
9d008e30:	10800005 	beqz	a0,9d008e48 <DHCPTask+0xd0>
9d008e34:	30640002 	andi	a0,v1,0x2
							AppConfig.MyMask = DHCPClient.tempMask;
9d008e38:	8e240020 	lw	a0,32(s1)
9d008e3c:	a8440007 	swl	a0,7(v0)
9d008e40:	b8440004 	swr	a0,4(v0)
						if(DHCPClient.validValues.bits.Gateway)
9d008e44:	30640002 	andi	a0,v1,0x2
9d008e48:	10800005 	beqz	a0,9d008e60 <DHCPTask+0xe8>
9d008e4c:	30640008 	andi	a0,v1,0x8
							AppConfig.MyGateway = DHCPClient.tempGateway;
9d008e50:	8e24001c 	lw	a0,28(s1)
9d008e54:	a844000b 	swl	a0,11(v0)
9d008e58:	b8440008 	swr	a0,8(v0)
						#if defined(STACK_USE_DNS)
							if(DHCPClient.validValues.bits.DNS)
9d008e5c:	30640008 	andi	a0,v1,0x8
9d008e60:	50800005 	beqzl	a0,9d008e78 <DHCPTask+0x100>
9d008e64:	a8400013 	swl	zero,19(v0)
								AppConfig.PrimaryDNSServer.Val = DHCPClient.tempDNS.Val;
9d008e68:	8e240024 	lw	a0,36(s1)
9d008e6c:	a844000f 	swl	a0,15(v0)
9d008e70:	b844000c 	swr	a0,12(v0)
							AppConfig.SecondaryDNSServer.Val = 0x00000000ul;
9d008e74:	a8400013 	swl	zero,19(v0)
							if(DHCPClient.validValues.bits.DNS2)
9d008e78:	30630010 	andi	v1,v1,0x10
9d008e7c:	10600004 	beqz	v1,9d008e90 <DHCPTask+0x118>
9d008e80:	b8400010 	swr	zero,16(v0)
								AppConfig.SecondaryDNSServer.Val = DHCPClient.tempDNS2.Val;
9d008e84:	8e230028 	lw	v1,40(s1)
9d008e88:	a8430013 	swl	v1,19(v0)
9d008e8c:	b8430010 	swr	v1,16(v0)
						break;
				}
				break;
		}
	}
}
9d008e90:	8fbf001c 	lw	ra,28(sp)
9d008e94:	8fb10018 	lw	s1,24(sp)
9d008e98:	8fb00014 	lw	s0,20(sp)
9d008e9c:	03e00008 	jr	ra
9d008ea0:	27bd0020 	addiu	sp,sp,32
				// When the module is disabled, do absolutely nothing
				break;
			
			case SM_DHCP_GET_SOCKET:
				// Open a socket to send and receive broadcast messages on
				DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
9d008ea4:	24040044 	li	a0,68
9d008ea8:	00002821 	move	a1,zero
9d008eac:	0f4011e9 	jal	9d0047a4 <UDPOpen>
9d008eb0:	24060043 	li	a2,67
				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
9d008eb4:	240300ff 	li	v1,255
9d008eb8:	1043fff5 	beq	v0,v1,9d008e90 <DHCPTask+0x118>
9d008ebc:	a2029948 	sb	v0,-26296(s0)
					break;
	
				DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9d008ec0:	24020002 	li	v0,2
9d008ec4:	ae220004 	sw	v0,4(s1)
				// This should be minimum possible to make sure that if the
				// server did not specify lease time, we try again after this 
				// minimum time.
				DHCPClient.dwLeaseTime = 60;
				DHCPClient.validValues.val = 0x00;
				DHCPClient.flags.bits.bIsBound = FALSE;	
9d008ec8:	8e220008 	lw	v0,8(s1)
			case SM_DHCP_SEND_DISCOVERY:
				// Assume default IP Lease time of 60 seconds.
				// This should be minimum possible to make sure that if the
				// server did not specify lease time, we try again after this 
				// minimum time.
				DHCPClient.dwLeaseTime = 60;
9d008ecc:	2403003c 	li	v1,60
9d008ed0:	3c10a001 	lui	s0,0xa001
				DHCPClient.validValues.val = 0x00;
				DHCPClient.flags.bits.bIsBound = FALSE;	
9d008ed4:	7c020004 	ins	v0,zero,0x0,0x1
				DHCPClient.flags.bits.bOfferReceived = FALSE;
9d008ed8:	7c021084 	ins	v0,zero,0x2,0x1
			case SM_DHCP_SEND_DISCOVERY:
				// Assume default IP Lease time of 60 seconds.
				// This should be minimum possible to make sure that if the
				// server did not specify lease time, we try again after this 
				// minimum time.
				DHCPClient.dwLeaseTime = 60;
9d008edc:	ae230010 	sw	v1,16(s1)
				DHCPClient.validValues.val = 0x00;
9d008ee0:	a220002c 	sb	zero,44(s1)
				DHCPClient.flags.bits.bIsBound = FALSE;	
				DHCPClient.flags.bits.bOfferReceived = FALSE;
	
				// No point in wasting time transmitting a discovery if we are 
				// unlinked.  No one will see it.  
				if(!MACIsLinked())
9d008ee4:	0f400ce6 	jal	9d003398 <MACIsLinked>
9d008ee8:	ae220008 	sw	v0,8(s1)
9d008eec:	1040ffe9 	beqz	v0,9d008e94 <DHCPTask+0x11c>
9d008ef0:	8fbf001c 	lw	ra,28(sp)
					break;
	
				// Ensure transmitter is ready to accept data
				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 300u)
9d008ef4:	0f401246 	jal	9d004918 <UDPIsPutReady>
9d008ef8:	92049948 	lbu	a0,-26296(s0)
9d008efc:	2c42012c 	sltiu	v0,v0,300
9d008f00:	1440ffe4 	bnez	v0,9d008e94 <DHCPTask+0x11c>
9d008f04:	8fbf001c 	lw	ra,28(sp)
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
	
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008f08:	92039948 	lbu	v1,-26296(s0)

				// Toggle the BOOTP Broadcast flag to ensure compatibility with 
				// bad DHCP servers that don't know how to handle broadcast 
				// responses.  This results in the next discovery attempt to be 
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
9d008f0c:	8e260008 	lw	a2,8(s1)
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
	
				// Send the DHCP Discover broadcast
				_DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE);
9d008f10:	00002821 	move	a1,zero
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
	
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008f14:	00031040 	sll	v0,v1,0x1
9d008f18:	00031900 	sll	v1,v1,0x4
9d008f1c:	00621823 	subu	v1,v1,v0

				// Toggle the BOOTP Broadcast flag to ensure compatibility with 
				// bad DHCP servers that don't know how to handle broadcast 
				// responses.  This results in the next discovery attempt to be 
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
9d008f20:	7cc40100 	ext	a0,a2,0x4,0x1
	
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008f24:	3c02a001 	lui	v0,0xa001

				// Toggle the BOOTP Broadcast flag to ensure compatibility with 
				// bad DHCP servers that don't know how to handle broadcast 
				// responses.  This results in the next discovery attempt to be 
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
9d008f28:	38840001 	xori	a0,a0,0x1
	
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008f2c:	24429a9c 	addiu	v0,v0,-25956
9d008f30:	00431021 	addu	v0,v0,v1

				// Toggle the BOOTP Broadcast flag to ensure compatibility with 
				// bad DHCP servers that don't know how to handle broadcast 
				// responses.  This results in the next discovery attempt to be 
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
9d008f34:	7c862104 	ins	a2,a0,0x4,0x1
	
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008f38:	2403ffff 	li	v1,-1

				// Toggle the BOOTP Broadcast flag to ensure compatibility with 
				// bad DHCP servers that don't know how to handle broadcast 
				// responses.  This results in the next discovery attempt to be 
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
9d008f3c:	ae260008 	sw	a2,8(s1)
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
	
				// Send the DHCP Discover broadcast
				_DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE);
9d008f40:	24040001 	li	a0,1
				// made using the opposite mode.
				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
	
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008f44:	a4430000 	sh	v1,0(v0)
9d008f48:	a4430002 	sh	v1,2(v0)
9d008f4c:	a4430004 	sh	v1,4(v0)
9d008f50:	a4430006 	sh	v1,6(v0)
	
				// Send the DHCP Discover broadcast
				_DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE);
9d008f54:	0f40212a 	jal	9d0084a8 <_DHCPSend>
9d008f58:	a4430008 	sh	v1,8(v0)
	
				// Start a timer and begin looking for a response
				DHCPClient.dwTimer = TickGet();
9d008f5c:	0f400b53 	jal	9d002d4c <TickGet>
9d008f60:	00000000 	nop
9d008f64:	ae22000c 	sw	v0,12(s1)
				DHCPClient.smState = SM_DHCP_GET_OFFER;
9d008f68:	24020003 	li	v0,3
				break;
9d008f6c:	0b4023a4 	j	9d008e90 <DHCPTask+0x118>
9d008f70:	ae220004 	sw	v0,4(s1)
	
			case SM_DHCP_GET_OFFER:
				// Check to see if a packet has arrived
				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
9d008f74:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d008f78:	92049948 	lbu	a0,-26296(s0)
9d008f7c:	2c4200fa 	sltiu	v0,v0,250
9d008f80:	1440006d 	bnez	v0,9d009138 <DHCPTask+0x3c0>
9d008f84:	24030001 	li	v1,1
					break;
				}
	
				// Let the DHCP server module know that there is a DHCP server 
				// on this network
				DHCPClient.flags.bits.bDHCPServerDetected = TRUE;
9d008f88:	8e220008 	lw	v0,8(s1)
9d008f8c:	7c6218c4 	ins	v0,v1,0x3,0x1
	
				// Check to see if we received an offer
				if(_DHCPReceive() != DHCP_OFFER_MESSAGE)
9d008f90:	0f4021f5 	jal	9d0087d4 <_DHCPReceive>
9d008f94:	ae220008 	sw	v0,8(s1)
9d008f98:	24030002 	li	v1,2
9d008f9c:	1443ffbd 	bne	v0,v1,9d008e94 <DHCPTask+0x11c>
9d008fa0:	8fbf001c 	lw	ra,28(sp)
					break;
	
				DHCPClient.smState = SM_DHCP_SEND_REQUEST;
9d008fa4:	24020004 	li	v0,4
9d008fa8:	ae220004 	sw	v0,4(s1)
				// No break
	
			case SM_DHCP_SEND_REQUEST:
				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
9d008fac:	0f401246 	jal	9d004918 <UDPIsPutReady>
9d008fb0:	92049948 	lbu	a0,-26296(s0)
9d008fb4:	2c420102 	sltiu	v0,v0,258
9d008fb8:	1440ffb6 	bnez	v0,9d008e94 <DHCPTask+0x11c>
9d008fbc:	8fbf001c 	lw	ra,28(sp)
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to, so 
				// we must set this back to the broadcast address since the 
				// current socket values are the unicast addresses of the DHCP 
				// server.
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008fc0:	3c02a001 	lui	v0,0xa001
9d008fc4:	90439948 	lbu	v1,-26296(v0)
	
				// Send the DHCP request message
				_DHCPSend(DHCP_REQUEST_MESSAGE, FALSE);
9d008fc8:	24040003 	li	a0,3
9d008fcc:	00002821 	move	a1,zero
				// Ensure that we transmit to the broadcast IP and MAC addresses
				// The UDP Socket remembers who it was last talking to, so 
				// we must set this back to the broadcast address since the 
				// current socket values are the unicast addresses of the DHCP 
				// server.
				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remoteNode));
9d008fd0:	00031040 	sll	v0,v1,0x1
9d008fd4:	00031900 	sll	v1,v1,0x4
9d008fd8:	00621823 	subu	v1,v1,v0
9d008fdc:	3c02a001 	lui	v0,0xa001
9d008fe0:	24429a9c 	addiu	v0,v0,-25956
9d008fe4:	00431021 	addu	v0,v0,v1
9d008fe8:	2403ffff 	li	v1,-1
9d008fec:	a4430000 	sh	v1,0(v0)
9d008ff0:	a4430002 	sh	v1,2(v0)
9d008ff4:	a4430004 	sh	v1,4(v0)
9d008ff8:	a4430006 	sh	v1,6(v0)
	
				// Send the DHCP request message
				_DHCPSend(DHCP_REQUEST_MESSAGE, FALSE);
9d008ffc:	0f40212a 	jal	9d0084a8 <_DHCPSend>
9d009000:	a4430008 	sh	v1,8(v0)
	
				// Start a timer and begin looking for a response
				DHCPClient.dwTimer = TickGet();
9d009004:	0f400b53 	jal	9d002d4c <TickGet>
9d009008:	00000000 	nop
9d00900c:	ae22000c 	sw	v0,12(s1)
				DHCPClient.smState = SM_DHCP_GET_REQUEST_ACK;
9d009010:	24020005 	li	v0,5
				break;
9d009014:	0b4023a4 	j	9d008e90 <DHCPTask+0x118>
9d009018:	ae220004 	sw	v0,4(s1)
	BYTE i;
	
	for(i = 0; i < NETWORK_INTERFACES; i++)
	{
		LoadState(i);
		switch(DHCPClient.smState)
9d00901c:	92049948 	lbu	a0,-26296(s0)
				// No break
	
			case SM_DHCP_SEND_RENEW:
			case SM_DHCP_SEND_RENEW2:
			case SM_DHCP_SEND_RENEW3:
				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
9d009020:	0f401246 	jal	9d004918 <UDPIsPutReady>
9d009024:	00000000 	nop
9d009028:	2c420102 	sltiu	v0,v0,258
9d00902c:	1440ff99 	bnez	v0,9d008e94 <DHCPTask+0x11c>
9d009030:	8fbf001c 	lw	ra,28(sp)
					break;
	
				// Send the DHCP request message
				_DHCPSend(DHCP_REQUEST_MESSAGE, TRUE);
9d009034:	24040003 	li	a0,3
9d009038:	0f40212a 	jal	9d0084a8 <_DHCPSend>
9d00903c:	24050001 	li	a1,1
				DHCPClient.flags.bits.bOfferReceived = FALSE;
9d009040:	8e220008 	lw	v0,8(s1)
9d009044:	7c021084 	ins	v0,zero,0x2,0x1
	
				// Start a timer and begin looking for a response
				DHCPClient.dwTimer = TickGet();
9d009048:	0f400b53 	jal	9d002d4c <TickGet>
9d00904c:	ae220008 	sw	v0,8(s1)
				DHCPClient.smState++;
9d009050:	8e230004 	lw	v1,4(s1)
				// Send the DHCP request message
				_DHCPSend(DHCP_REQUEST_MESSAGE, TRUE);
				DHCPClient.flags.bits.bOfferReceived = FALSE;
	
				// Start a timer and begin looking for a response
				DHCPClient.dwTimer = TickGet();
9d009054:	ae22000c 	sw	v0,12(s1)
				DHCPClient.smState++;
9d009058:	24630001 	addiu	v1,v1,1
				break;
9d00905c:	0b4023a4 	j	9d008e90 <DHCPTask+0x118>
9d009060:	ae230004 	sw	v1,4(s1)
						break;
				}
				break;
	
			case SM_DHCP_BOUND:
				if(TickGet() - DHCPClient.dwTimer < TICK_SECOND)
9d009064:	0f400b53 	jal	9d002d4c <TickGet>
9d009068:	00000000 	nop
9d00906c:	8e24000c 	lw	a0,12(s1)
9d009070:	3c030004 	lui	v1,0x4
9d009074:	3463c4b4 	ori	v1,v1,0xc4b4
9d009078:	00441023 	subu	v0,v0,a0
9d00907c:	0043102b 	sltu	v0,v0,v1
9d009080:	1440ff84 	bnez	v0,9d008e94 <DHCPTask+0x11c>
9d009084:	8fbf001c 	lw	ra,28(sp)
					break;
	
				// Check to see if our lease is still valid, if so, decrement lease 
				// time
				if(DHCPClient.dwLeaseTime >= 2ul)
9d009088:	8e220010 	lw	v0,16(s1)
9d00908c:	2c450002 	sltiu	a1,v0,2
9d009090:	14a00042 	bnez	a1,9d00919c <DHCPTask+0x424>
9d009094:	00831821 	addu	v1,a0,v1
				{
					DHCPClient.dwTimer += TICK_SECOND;
					DHCPClient.dwLeaseTime--;
9d009098:	2442ffff 	addiu	v0,v0,-1
	
				// Check to see if our lease is still valid, if so, decrement lease 
				// time
				if(DHCPClient.dwLeaseTime >= 2ul)
				{
					DHCPClient.dwTimer += TICK_SECOND;
9d00909c:	ae23000c 	sw	v1,12(s1)
					DHCPClient.dwLeaseTime--;
					break;
9d0090a0:	0b4023a4 	j	9d008e90 <DHCPTask+0x118>
9d0090a4:	ae220010 	sw	v0,16(s1)
	
			case SM_DHCP_GET_RENEW_ACK:
			case SM_DHCP_GET_RENEW_ACK2:
			case SM_DHCP_GET_RENEW_ACK3:
				// Check to see if a packet has arrived
				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
9d0090a8:	92049948 	lbu	a0,-26296(s0)
9d0090ac:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d0090b0:	3c10a001 	lui	s0,0xa001
9d0090b4:	2c4200fa 	sltiu	v0,v0,250
9d0090b8:	10400016 	beqz	v0,9d009114 <DHCPTask+0x39c>
9d0090bc:	00000000 	nop
				{
					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds
					if(TickGet() - DHCPClient.dwTimer >=  DHCP_TIMEOUT)
9d0090c0:	0f400b53 	jal	9d002d4c <TickGet>
9d0090c4:	00000000 	nop
9d0090c8:	8e23000c 	lw	v1,12(s1)
9d0090cc:	3c040009 	lui	a0,0x9
9d0090d0:	34848968 	ori	a0,a0,0x8968
9d0090d4:	00431823 	subu	v1,v0,v1
9d0090d8:	0064182b 	sltu	v1,v1,a0
9d0090dc:	1460ff6d 	bnez	v1,9d008e94 <DHCPTask+0x11c>
9d0090e0:	8fbf001c 	lw	ra,28(sp)
					{
						if(++DHCPClient.smState > SM_DHCP_GET_RENEW_ACK3)
9d0090e4:	8e220004 	lw	v0,4(s1)
9d0090e8:	24420001 	addiu	v0,v0,1
9d0090ec:	2c43000d 	sltiu	v1,v0,13
9d0090f0:	1460ff67 	bnez	v1,9d008e90 <DHCPTask+0x118>
9d0090f4:	ae220004 	sw	v0,4(s1)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
						break;
		
					case DHCP_NAK_MESSAGE:
						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9d0090f8:	24020002 	li	v0,2
9d0090fc:	ae220004 	sw	v0,4(s1)
						break;
				}
				break;
		}
	}
}
9d009100:	8fbf001c 	lw	ra,28(sp)
9d009104:	8fb10018 	lw	s1,24(sp)
9d009108:	8fb00014 	lw	s0,20(sp)
9d00910c:	03e00008 	jr	ra
9d009110:	27bd0020 	addiu	sp,sp,32
					}
					break;
				}
	
				// Check to see if we received an offer
				switch(_DHCPReceive())
9d009114:	0f4021f5 	jal	9d0087d4 <_DHCPReceive>
9d009118:	00000000 	nop
9d00911c:	24030005 	li	v1,5
9d009120:	10430011 	beq	v0,v1,9d009168 <DHCPTask+0x3f0>
9d009124:	24030006 	li	v1,6
9d009128:	1443ff5a 	bne	v0,v1,9d008e94 <DHCPTask+0x11c>
9d00912c:	8fbf001c 	lw	ra,28(sp)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
						break;
		
					case DHCP_NAK_MESSAGE:
						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9d009130:	0b40243f 	j	9d0090fc <DHCPTask+0x384>
9d009134:	24020002 	li	v0,2
			case SM_DHCP_GET_REQUEST_ACK:
				// Check to see if a packet has arrived
				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
				{
					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds
					if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT)
9d009138:	0f400b53 	jal	9d002d4c <TickGet>
9d00913c:	00000000 	nop
9d009140:	8e23000c 	lw	v1,12(s1)
9d009144:	3c040009 	lui	a0,0x9
9d009148:	34848968 	ori	a0,a0,0x8968
9d00914c:	00431823 	subu	v1,v0,v1
9d009150:	0064182b 	sltu	v1,v1,a0
9d009154:	1460ff4f 	bnez	v1,9d008e94 <DHCPTask+0x11c>
9d009158:	8fbf001c 	lw	ra,28(sp)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
						break;
		
					case DHCP_NAK_MESSAGE:
						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9d00915c:	24020002 	li	v0,2
9d009160:	0b402440 	j	9d009100 <DHCPTask+0x388>
9d009164:	ae220004 	sw	v0,4(s1)
	
				// Check to see if we received an offer
				switch(_DHCPReceive())
				{
					case DHCP_ACK_MESSAGE:
						UDPClose(DHCPClient.hDHCPSocket);
9d009168:	0f40121f 	jal	9d00487c <UDPClose>
9d00916c:	92049948 	lbu	a0,-26296(s0)
						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9d009170:	2402ffff 	li	v0,-1
						DHCPClient.dwTimer = TickGet();
9d009174:	0f400b53 	jal	9d002d4c <TickGet>
9d009178:	a2029948 	sb	v0,-26296(s0)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
9d00917c:	8e230008 	lw	v1,8(s1)
9d009180:	24040001 	li	a0,1
				switch(_DHCPReceive())
				{
					case DHCP_ACK_MESSAGE:
						UDPClose(DHCPClient.hDHCPSocket);
						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
						DHCPClient.dwTimer = TickGet();
9d009184:	ae22000c 	sw	v0,12(s1)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
9d009188:	7c830844 	ins	v1,a0,0x1,0x1
				{
					case DHCP_ACK_MESSAGE:
						UDPClose(DHCPClient.hDHCPSocket);
						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
						DHCPClient.dwTimer = TickGet();
						DHCPClient.smState = SM_DHCP_BOUND;
9d00918c:	24020006 	li	v0,6
9d009190:	ae220004 	sw	v0,4(s1)
						DHCPClient.flags.bits.bEvent = 1;
						break;
9d009194:	0b4023a4 	j	9d008e90 <DHCPTask+0x118>
9d009198:	ae230008 	sw	v1,8(s1)
					DHCPClient.dwLeaseTime--;
					break;
				}
	
				// Open a socket to send and receive DHCP messages on
				DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
9d00919c:	24040044 	li	a0,68
9d0091a0:	00002821 	move	a1,zero
9d0091a4:	0f4011e9 	jal	9d0047a4 <UDPOpen>
9d0091a8:	24060043 	li	a2,67
9d0091ac:	00402021 	move	a0,v0
9d0091b0:	3c02a001 	lui	v0,0xa001
9d0091b4:	a0449948 	sb	a0,-26296(v0)
				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
9d0091b8:	240200ff 	li	v0,255
9d0091bc:	1082ff34 	beq	a0,v0,9d008e90 <DHCPTask+0x118>
9d0091c0:	24020007 	li	v0,7
					break;
	
				DHCPClient.smState = SM_DHCP_SEND_RENEW;
9d0091c4:	0b402408 	j	9d009020 <DHCPTask+0x2a8>
9d0091c8:	ae220004 	sw	v0,4(s1)
						DHCPClient.smState = SM_DHCP_BOUND;
						DHCPClient.flags.bits.bEvent = 1;
						DHCPClient.flags.bits.bIsBound = TRUE;	

						if(DHCPClient.validValues.bits.IPAddress)
							AppConfig.MyIPAddr = DHCPClient.tempIPAddress;
9d0091cc:	8e250018 	lw	a1,24(s1)
9d0091d0:	3c04a001 	lui	a0,0xa001
9d0091d4:	24829a5c 	addiu	v0,a0,-26020
9d0091d8:	a8450003 	swl	a1,3(v0)
9d0091dc:	0b40238b 	j	9d008e2c <DHCPTask+0xb4>
9d0091e0:	b8859a5c 	swr	a1,-26020(a0)

9d0091e4 <IPGetHeader>:
 ********************************************************************/
BOOL IPGetHeader(IP_ADDR *localIP,
                 NODE_INFO *remote,
                 BYTE *protocol,
                 WORD *len)
{
9d0091e4:	27bdffb8 	addiu	sp,sp,-72
9d0091e8:	afb10038 	sw	s1,56(sp)
9d0091ec:	afb00034 	sw	s0,52(sp)
9d0091f0:	00808821 	move	s1,a0
9d0091f4:	00a08021 	move	s0,a1
	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791.
    BYTE        options[MAX_OPTIONS_LEN];
#endif

    // Read IP header.
    MACGetArray((BYTE*)&header, sizeof(header));
9d0091f8:	27a40010 	addiu	a0,sp,16
9d0091fc:	24050014 	li	a1,20
 ********************************************************************/
BOOL IPGetHeader(IP_ADDR *localIP,
                 NODE_INFO *remote,
                 BYTE *protocol,
                 WORD *len)
{
9d009200:	afbf0044 	sw	ra,68(sp)
9d009204:	afb30040 	sw	s3,64(sp)
9d009208:	afb2003c 	sw	s2,60(sp)
	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791.
    BYTE        options[MAX_OPTIONS_LEN];
#endif

    // Read IP header.
    MACGetArray((BYTE*)&header, sizeof(header));
9d00920c:	afa60028 	sw	a2,40(sp)
9d009210:	0f400e15 	jal	9d003854 <MACGetArray>
9d009214:	afa7002c 	sw	a3,44(sp)

    // Make sure that this is an IPv4 packet.
    if((header.VersionIHL & 0xf0) != IP_VERSION)
9d009218:	93a30010 	lbu	v1,16(sp)
9d00921c:	24040040 	li	a0,64
9d009220:	306500f0 	andi	a1,v1,0xf0
9d009224:	10a40008 	beq	a1,a0,9d009248 <IPGetHeader+0x64>
9d009228:	00001021 	move	v0,zero
    remote->IPAddr.Val  = header.SourceAddress.Val;
    *protocol           = header.Protocol;
    *len 				= header.TotalLength - IPHeaderLen;

    return TRUE;
}
9d00922c:	8fbf0044 	lw	ra,68(sp)
9d009230:	8fb30040 	lw	s3,64(sp)
9d009234:	8fb2003c 	lw	s2,60(sp)
9d009238:	8fb10038 	lw	s1,56(sp)
9d00923c:	8fb00034 	lw	s0,52(sp)
9d009240:	03e00008 	jr	ra
9d009244:	27bd0048 	addiu	sp,sp,72
    if((header.VersionIHL & 0xf0) != IP_VERSION)
    	return FALSE;

	// Throw this packet away if it is a fragment.  
	// We don't have enough RAM for IP fragment reconstruction.
	if(header.FragmentInfo & 0xFF1F)
9d009248:	97b20016 	lhu	s2,22(sp)
9d00924c:	3252ff1f 	andi	s2,s2,0xff1f
9d009250:	1640fff7 	bnez	s2,9d009230 <IPGetHeader+0x4c>
9d009254:	8fbf0044 	lw	ra,68(sp)
		return FALSE;

	IPHeaderLen = (header.VersionIHL & 0x0f) << 2;
9d009258:	3062000f 	andi	v0,v1,0xf
9d00925c:	00021080 	sll	v0,v0,0x2
#if !defined(NON_MCHP_MAC)
	// Validate the IP header.  If it is correct, the checksum 
	// will come out to 0x0000 (because the header contains a 
	// precomputed checksum).  A corrupt header will have a 
	// nonzero checksum.
	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen);
9d009260:	00002021 	move	a0,zero
9d009264:	00402821 	move	a1,v0
9d009268:	0f400e46 	jal	9d003918 <MACCalcRxChecksum>
9d00926c:	a3828100 	sb	v0,-32512(gp)

	// Seek to the end of the IP header
	MACSetReadPtrInRx(IPHeaderLen);
9d009270:	93848100 	lbu	a0,-32512(gp)
9d009274:	0f400e07 	jal	9d00381c <MACSetReadPtrInRx>
9d009278:	00409821 	move	s3,v0

    if(CalcChecksum.Val)
9d00927c:	1660ffeb 	bnez	s3,9d00922c <IPGetHeader+0x48>
9d009280:	02401021 	move	v0,s2



static void SwapIPHeader(IP_HEADER* h)
{
    h->TotalLength      = swaps(h->TotalLength);
9d009284:	0f402604 	jal	9d009810 <swaps>
9d009288:	97a40012 	lhu	a0,18(sp)
    h->Identification   = swaps(h->Identification);
9d00928c:	97a40014 	lhu	a0,20(sp)
9d009290:	0f402604 	jal	9d009810 <swaps>
9d009294:	a7a20012 	sh	v0,18(sp)
    h->HeaderChecksum   = swaps(h->HeaderChecksum);
9d009298:	97a4001a 	lhu	a0,26(sp)
9d00929c:	0f402604 	jal	9d009810 <swaps>
9d0092a0:	a7a20014 	sh	v0,20(sp)
    // Network to host conversion.
    SwapIPHeader(&header);

    // If caller is intrested, return destination IP address
    // as seen in this IP header.
    if ( localIP )
9d0092a4:	8fa60028 	lw	a2,40(sp)
9d0092a8:	12200003 	beqz	s1,9d0092b8 <IPGetHeader+0xd4>
9d0092ac:	8fa7002c 	lw	a3,44(sp)
        localIP->Val    = header.DestAddress.Val;
9d0092b0:	8fa20020 	lw	v0,32(sp)
9d0092b4:	ae220000 	sw	v0,0(s1)

    remote->IPAddr.Val  = header.SourceAddress.Val;
9d0092b8:	8fa2001c 	lw	v0,28(sp)
    *protocol           = header.Protocol;
9d0092bc:	93a30019 	lbu	v1,25(sp)
    *len 				= header.TotalLength - IPHeaderLen;
9d0092c0:	97a40012 	lhu	a0,18(sp)
    // If caller is intrested, return destination IP address
    // as seen in this IP header.
    if ( localIP )
        localIP->Val    = header.DestAddress.Val;

    remote->IPAddr.Val  = header.SourceAddress.Val;
9d0092c4:	aa020003 	swl	v0,3(s0)
9d0092c8:	ba020000 	swr	v0,0(s0)
    *protocol           = header.Protocol;
9d0092cc:	a0c30000 	sb	v1,0(a2)
    *len 				= header.TotalLength - IPHeaderLen;
9d0092d0:	93838100 	lbu	v1,-32512(gp)

    return TRUE;
9d0092d4:	24020001 	li	v0,1
    if ( localIP )
        localIP->Val    = header.DestAddress.Val;

    remote->IPAddr.Val  = header.SourceAddress.Val;
    *protocol           = header.Protocol;
    *len 				= header.TotalLength - IPHeaderLen;
9d0092d8:	00831823 	subu	v1,a0,v1

    return TRUE;
9d0092dc:	0b40248b 	j	9d00922c <IPGetHeader+0x48>
9d0092e0:	a4e30000 	sh	v1,0(a3)

9d0092e4 <IPPutHeader>:
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
    header.Identification   = ++_Identifier;
9d0092e4:	97888102 	lhu	t0,-32510(gp)
 *                  time.
 ********************************************************************/
WORD IPPutHeader(NODE_INFO *remote,
                 BYTE protocol,
                 WORD len)
{
9d0092e8:	27bdffc8 	addiu	sp,sp,-56
    header.Identification   = ++_Identifier;
    header.FragmentInfo     = 0;
    header.TimeToLive       = MY_IP_TTL;
    header.Protocol         = protocol;
    header.HeaderChecksum   = 0;
	header.SourceAddress 	= AppConfig.MyIPAddr;
9d0092ec:	3c02a001 	lui	v0,0xa001
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
    header.Identification   = ++_Identifier;
9d0092f0:	25080001 	addiu	t0,t0,1
9d0092f4:	3108ffff 	andi	t0,t0,0xffff
                 BYTE protocol,
                 WORD len)
{
    IP_HEADER   header;
    
    IPHeaderLen = sizeof(IP_HEADER);
9d0092f8:	24030014 	li	v1,20
 *                  time.
 ********************************************************************/
WORD IPPutHeader(NODE_INFO *remote,
                 BYTE protocol,
                 WORD len)
{
9d0092fc:	afbf0034 	sw	ra,52(sp)
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
    header.Identification   = ++_Identifier;
9d009300:	a7888102 	sh	t0,-32510(gp)
 *                  time.
 ********************************************************************/
WORD IPPutHeader(NODE_INFO *remote,
                 BYTE protocol,
                 WORD len)
{
9d009304:	afb00030 	sw	s0,48(sp)
    IP_HEADER   header;
    
    IPHeaderLen = sizeof(IP_HEADER);
9d009308:	a3838100 	sb	v1,-32512(gp)
    header.Identification   = ++_Identifier;
    header.FragmentInfo     = 0;
    header.TimeToLive       = MY_IP_TTL;
    header.Protocol         = protocol;
    header.HeaderChecksum   = 0;
	header.SourceAddress 	= AppConfig.MyIPAddr;
9d00930c:	24439a5c 	addiu	v1,v0,-26020
9d009310:	88670003 	lwl	a3,3(v1)

    header.DestAddress.Val = remote->IPAddr.Val;
9d009314:	88830003 	lwl	v1,3(a0)
    
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
9d009318:	24c60014 	addiu	a2,a2,20
    header.Identification   = ++_Identifier;
    header.FragmentInfo     = 0;
    header.TimeToLive       = MY_IP_TTL;
    header.Protocol         = protocol;
    header.HeaderChecksum   = 0;
	header.SourceAddress 	= AppConfig.MyIPAddr;
9d00931c:	98479a5c 	lwr	a3,-26020(v0)

    header.DestAddress.Val = remote->IPAddr.Val;
9d009320:	98830000 	lwr	v1,0(a0)
    
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
9d009324:	30c6ffff 	andi	a2,a2,0xffff
{
    IP_HEADER   header;
    
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
9d009328:	24020045 	li	v0,69
 *                  time.
 ********************************************************************/
WORD IPPutHeader(NODE_INFO *remote,
                 BYTE protocol,
                 WORD len)
{
9d00932c:	00808021 	move	s0,a0
    IP_HEADER   header;
    
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
9d009330:	a3a20010 	sb	v0,16(sp)



static void SwapIPHeader(IP_HEADER* h)
{
    h->TotalLength      = swaps(h->TotalLength);
9d009334:	00c02021 	move	a0,a2
    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
    header.Identification   = ++_Identifier;
    header.FragmentInfo     = 0;
    header.TimeToLive       = MY_IP_TTL;
9d009338:	24020064 	li	v0,100
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
    header.Identification   = ++_Identifier;
9d00933c:	a7a80014 	sh	t0,20(sp)
    header.FragmentInfo     = 0;
    header.TimeToLive       = MY_IP_TTL;
    header.Protocol         = protocol;
    header.HeaderChecksum   = 0;
	header.SourceAddress 	= AppConfig.MyIPAddr;
9d009340:	afa7001c 	sw	a3,28(sp)

    header.DestAddress.Val = remote->IPAddr.Val;
9d009344:	afa30020 	sw	v1,32(sp)
    
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
9d009348:	a7a60012 	sh	a2,18(sp)



static void SwapIPHeader(IP_HEADER* h)
{
    h->TotalLength      = swaps(h->TotalLength);
9d00934c:	afa60028 	sw	a2,40(sp)
    header.TypeOfService    = IP_SERVICE;
    header.TotalLength      = sizeof(header) + len;
    header.Identification   = ++_Identifier;
    header.FragmentInfo     = 0;
    header.TimeToLive       = MY_IP_TTL;
    header.Protocol         = protocol;
9d009350:	a3a50019 	sb	a1,25(sp)
    IP_HEADER   header;
    
    IPHeaderLen = sizeof(IP_HEADER);

    header.VersionIHL       = IP_VERSION | IP_IHL;
    header.TypeOfService    = IP_SERVICE;
9d009354:	a3a00011 	sb	zero,17(sp)
    header.TotalLength      = sizeof(header) + len;
    header.Identification   = ++_Identifier;
    header.FragmentInfo     = 0;
9d009358:	a7a00016 	sh	zero,22(sp)
    header.TimeToLive       = MY_IP_TTL;
9d00935c:	a3a20018 	sb	v0,24(sp)



static void SwapIPHeader(IP_HEADER* h)
{
    h->TotalLength      = swaps(h->TotalLength);
9d009360:	0f402604 	jal	9d009810 <swaps>
9d009364:	a7a0001a 	sh	zero,26(sp)
    h->Identification   = swaps(h->Identification);
9d009368:	97a40014 	lhu	a0,20(sp)
9d00936c:	0f402604 	jal	9d009810 <swaps>
9d009370:	a7a20012 	sh	v0,18(sp)
    h->HeaderChecksum   = swaps(h->HeaderChecksum);
9d009374:	97a4001a 	lhu	a0,26(sp)
9d009378:	0f402604 	jal	9d009810 <swaps>
9d00937c:	a7a20014 	sh	v0,20(sp)

    header.DestAddress.Val = remote->IPAddr.Val;

    SwapIPHeader(&header);

    header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header));
9d009380:	27a40010 	addiu	a0,sp,16
9d009384:	24050014 	li	a1,20
9d009388:	0f40261b 	jal	9d00986c <CalcIPChecksum>
9d00938c:	a7a2001a 	sh	v0,26(sp)

    MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len));
9d009390:	8fa60028 	lw	a2,40(sp)
9d009394:	26040004 	addiu	a0,s0,4
9d009398:	00002821 	move	a1,zero
9d00939c:	0f400d56 	jal	9d003558 <MACPutHeader>
9d0093a0:	a7a2001a 	sh	v0,26(sp)
    MACPutArray((BYTE*)&header, sizeof(header));
9d0093a4:	27a40010 	addiu	a0,sp,16
9d0093a8:	0f400d45 	jal	9d003514 <MACPutArray>
9d0093ac:	24050014 	li	a1,20

    return 0x0000;

}
9d0093b0:	8fbf0034 	lw	ra,52(sp)
9d0093b4:	00001021 	move	v0,zero
9d0093b8:	8fb00030 	lw	s0,48(sp)
9d0093bc:	03e00008 	jr	ra
9d0093c0:	27bd0038 	addiu	sp,sp,56

9d0093c4 <IPSetRxBuffer>:
 * Note:            None
 *
 ********************************************************************/
void IPSetRxBuffer(WORD Offset) 
{
	MACSetReadPtrInRx(Offset+IPHeaderLen);
9d0093c4:	93828100 	lbu	v0,-32512(gp)
9d0093c8:	00822021 	addu	a0,a0,v0
9d0093cc:	0b400e07 	j	9d00381c <MACSetReadPtrInRx>
9d0093d0:	3084ffff 	andi	a0,a0,0xffff

9d0093d4 <LFSRRand>:
	
	// Taps: 32 31 29 1
	// Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
	// Repeat 15 times to make the shift pattern less obvious
	for(i = 0; i < 15; i++)
		dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);
9d0093d4:	8f828028 	lw	v0,-32728(gp)
9d0093d8:	3c06d000 	lui	a2,0xd000
	BYTE i;
	
	// Taps: 32 31 29 1
	// Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
	// Repeat 15 times to make the shift pattern less obvious
	for(i = 0; i < 15; i++)
9d0093dc:	00001821 	move	v1,zero
		dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);
9d0093e0:	24c60001 	addiu	a2,a2,1
	BYTE i;
	
	// Taps: 32 31 29 1
	// Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
	// Repeat 15 times to make the shift pattern less obvious
	for(i = 0; i < 15; i++)
9d0093e4:	2405000f 	li	a1,15
		dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);
9d0093e8:	30440001 	andi	a0,v0,0x1
9d0093ec:	00042023 	negu	a0,a0
	BYTE i;
	
	// Taps: 32 31 29 1
	// Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
	// Repeat 15 times to make the shift pattern less obvious
	for(i = 0; i < 15; i++)
9d0093f0:	24630001 	addiu	v1,v1,1
		dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);
9d0093f4:	00021042 	srl	v0,v0,0x1
9d0093f8:	00862024 	and	a0,a0,a2
	BYTE i;
	
	// Taps: 32 31 29 1
	// Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
	// Repeat 15 times to make the shift pattern less obvious
	for(i = 0; i < 15; i++)
9d0093fc:	306300ff 	andi	v1,v1,0xff
9d009400:	1465fff9 	bne	v1,a1,9d0093e8 <LFSRRand+0x14>
9d009404:	00821026 	xor	v0,a0,v0
9d009408:	af828028 	sw	v0,-32728(gp)
		dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);

	// Return 16-bits as pseudo-random number
	return (WORD)dwLFSRRandSeed;
}
9d00940c:	03e00008 	jr	ra
9d009410:	3042ffff 	andi	v0,v0,0xffff

9d009414 <LFSRSeedRand>:
	dwOldSeed = dwLFSRRandSeed;

	// Ensure zero isn't selected as a seed value, this would result in all 
	// 0x0000 output values from the LFSR
	if(dwSeed == 0u)
		dwSeed = 1;
9d009414:	24020001 	li	v0,1
	dwSeed value of 0x0 will return the same sequence of random numbers as 
	using the seed of 0x1.
  ***************************************************************************/
static DWORD dwLFSRRandSeed = 0x41FE9F9E;	// 0x41FE9F9E corresponds to calling LFSRSeedRand(1)
DWORD LFSRSeedRand(DWORD dwSeed)
{
9d009418:	27bdffe0 	addiu	sp,sp,-32
	dwOldSeed = dwLFSRRandSeed;

	// Ensure zero isn't selected as a seed value, this would result in all 
	// 0x0000 output values from the LFSR
	if(dwSeed == 0u)
		dwSeed = 1;
9d00941c:	0084100b 	movn	v0,a0,a0
	dwSeed value of 0x0 will return the same sequence of random numbers as 
	using the seed of 0x1.
  ***************************************************************************/
static DWORD dwLFSRRandSeed = 0x41FE9F9E;	// 0x41FE9F9E corresponds to calling LFSRSeedRand(1)
DWORD LFSRSeedRand(DWORD dwSeed)
{
9d009420:	afb10018 	sw	s1,24(sp)
9d009424:	afb00014 	sw	s0,20(sp)
9d009428:	afbf001c 	sw	ra,28(sp)
	DWORD dwOldSeed;
	BYTE i;

	// Save original seed to be returned later
	dwOldSeed = dwLFSRRandSeed;
9d00942c:	8f908028 	lw	s0,-32728(gp)
	// 0x0000 output values from the LFSR
	if(dwSeed == 0u)
		dwSeed = 1;
		
	// Set the new seed
	dwLFSRRandSeed = dwSeed;
9d009430:	24110010 	li	s1,16
9d009434:	af828028 	sw	v0,-32728(gp)
	
	// Run the LFSR a few times to get rid of obvious start up artifacts for 
	// seed values that don't have many set bits.
	for(i = 0; i < 16; i++)
		LFSRRand();
9d009438:	2631ffff 	addiu	s1,s1,-1
9d00943c:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d009440:	323100ff 	andi	s1,s1,0xff
	// Set the new seed
	dwLFSRRandSeed = dwSeed;
	
	// Run the LFSR a few times to get rid of obvious start up artifacts for 
	// seed values that don't have many set bits.
	for(i = 0; i < 16; i++)
9d009444:	1620fffd 	bnez	s1,9d00943c <LFSRSeedRand+0x28>
9d009448:	2631ffff 	addiu	s1,s1,-1
		LFSRRand();
	
	// Return saved old seed
	return dwOldSeed;
}
9d00944c:	8fbf001c 	lw	ra,28(sp)
9d009450:	02001021 	move	v0,s0
9d009454:	8fb10018 	lw	s1,24(sp)
9d009458:	8fb00014 	lw	s0,20(sp)
9d00945c:	03e00008 	jr	ra
9d009460:	27bd0020 	addiu	sp,sp,32

9d009464 <GenerateRandomDWORD>:
{
	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
9d009464:	3c02bf81 	lui	v0,0xbf81
9d009468:	8c469000 	lw	a2,-28672(v0)
	AD1CON2Save = AD1CON2;
9d00946c:	3c03bf81 	lui	v1,0xbf81
	AD1CON3Save = AD1CON3;
9d009470:	3c07bf81 	lui	a3,0xbf81
	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
9d009474:	8c659010 	lw	a1,-28656(v1)
	AD1CON3Save = AD1CON3;
	T1CONSave = T1CON;
9d009478:	3c02bf80 	lui	v0,0xbf80
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
	AD1CON3Save = AD1CON3;
9d00947c:	8ce49020 	lw	a0,-28640(a3)
	T1CONSave = T1CON;
	PR1Save = PR1;
9d009480:	3c07bf80 	lui	a3,0xbf80

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
	AD1CON3Save = AD1CON3;
	T1CONSave = T1CON;
9d009484:	8c430600 	lw	v1,1536(v0)
	PR1Save = PR1;
9d009488:	8ce20620 	lw	v0,1568(a3)
	The intent of this function is to produce statistically random and
	cryptographically secure random number.  Whether or not this is true on
	all (or any) devices/voltages/temperatures is not tested.
  ***************************************************************************/
DWORD GenerateRandomDWORD(void)
{
9d00948c:	27bdffa8 	addiu	sp,sp,-88
	AD1CON3Save = AD1CON3;
	T1CONSave = T1CON;
	PR1Save = PR1;

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9d009490:	3c07bf81 	lui	a3,0xbf81
{
	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
9d009494:	30c6ffff 	andi	a2,a2,0xffff
	AD1CON3Save = AD1CON3;
	T1CONSave = T1CON;
	PR1Save = PR1;

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9d009498:	ace09000 	sw	zero,-28672(a3)
{
	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
9d00949c:	afa60010 	sw	a2,16(sp)
	T1CONSave = T1CON;
	PR1Save = PR1;

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
9d0094a0:	3c07bf81 	lui	a3,0xbf81
9d0094a4:	34069f00 	li	a2,0x9f00
	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
9d0094a8:	30a5ffff 	andi	a1,a1,0xffff
	AD1CON3Save = AD1CON3;
9d0094ac:	3084ffff 	andi	a0,a0,0xffff
	T1CONSave = T1CON;
	PR1Save = PR1;

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
9d0094b0:	ace69020 	sw	a2,-28640(a3)
	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
9d0094b4:	afa50014 	sw	a1,20(sp)
	PR1Save = PR1;

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
9d0094b8:	3c06bf81 	lui	a2,0xbf81
9d0094bc:	2405003f 	li	a1,63
	WORD T1CONSave, PR1Save;

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
	AD1CON3Save = AD1CON3;
9d0094c0:	afa40018 	sw	a0,24(sp)

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
9d0094c4:	3c07bf81 	lui	a3,0xbf81
9d0094c8:	340480e4 	li	a0,0x80e4

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
	AD1CON3Save = AD1CON3;
	T1CONSave = T1CON;
9d0094cc:	3063ffff 	andi	v1,v1,0xffff
	PR1Save = PR1;
9d0094d0:	3042ffff 	andi	v0,v0,0xffff

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
9d0094d4:	acc59010 	sw	a1,-28656(a2)

	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
	AD1CON3Save = AD1CON3;
	T1CONSave = T1CON;
9d0094d8:	afa3001c 	sw	v1,28(sp)

	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
9d0094dc:	ace49000 	sw	a0,-28672(a3)
	T1CON = 0x8000;			// TON = 1, no prescalar
9d0094e0:	34038000 	li	v1,0x8000
9d0094e4:	3c04bf80 	lui	a0,0xbf80
	// Save hardware SFRs
	AD1CON1Save = AD1CON1;
	AD1CON2Save = AD1CON2;
	AD1CON3Save = AD1CON3;
	T1CONSave = T1CON;
	PR1Save = PR1;
9d0094e8:	afa20020 	sw	v0,32(sp)
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
	T1CON = 0x8000;			// TON = 1, no prescalar
	PR1 = 0xFFFF;			// Don't clear timer early
9d0094ec:	3c05bf80 	lui	a1,0xbf80
9d0094f0:	3402ffff 	li	v0,0xffff
	// Set up Timer and A/D converter module
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
	T1CON = 0x8000;			// TON = 1, no prescalar
9d0094f4:	ac830600 	sw	v1,1536(a0)
	The intent of this function is to produce statistically random and
	cryptographically secure random number.  Whether or not this is true on
	all (or any) devices/voltages/temperatures is not tested.
  ***************************************************************************/
DWORD GenerateRandomDWORD(void)
{
9d0094f8:	afbe0050 	sw	s8,80(sp)
9d0094fc:	afb7004c 	sw	s7,76(sp)
9d009500:	afb60048 	sw	s6,72(sp)
9d009504:	afb50044 	sw	s5,68(sp)
9d009508:	afb40040 	sw	s4,64(sp)
9d00950c:	afb3003c 	sw	s3,60(sp)
9d009510:	afb20038 	sw	s2,56(sp)
9d009514:	afb10034 	sw	s1,52(sp)
9d009518:	afb00030 	sw	s0,48(sp)
9d00951c:	afbf0054 	sw	ra,84(sp)
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
	T1CON = 0x8000;			// TON = 1, no prescalar
	PR1 = 0xFFFF;			// Don't clear timer early
9d009520:	aca20620 	sw	v0,1568(a1)
	vBitCount = 0;
	dwTotalTime = 0;
	wLastValue = 0;
	randomResult.dw = LFSRRand();
9d009524:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d009528:	3c1e04c4 	lui	s8,0x4c4
9d00952c:	00408821 	move	s1,v0
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
	T1CON = 0x8000;			// TON = 1, no prescalar
	PR1 = 0xFFFF;			// Don't clear timer early
	vBitCount = 0;
	dwTotalTime = 0;
9d009530:	00003021 	move	a2,zero
	wLastValue = 0;
9d009534:	0000a021 	move	s4,zero
	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
	T1CON = 0x8000;			// TON = 1, no prescalar
	PR1 = 0xFFFF;			// Don't clear timer early
	vBitCount = 0;
9d009538:	00009021 	move	s2,zero
9d00953c:	3c13bf80 	lui	s3,0xbf80
9d009540:	3c03bf88 	lui	v1,0xbf88
9d009544:	3c10bf80 	lui	s0,0xbf80
9d009548:	3c15bf88 	lui	s5,0xbf88
	dwTotalTime = 0;
	wLastValue = 0;
	randomResult.dw = LFSRRand();
	while(1)
	{
		ClrWdt();
9d00954c:	24160001 	li	s6,1
		TMR1 = 0x0000;

		#if defined(__C30__)
			IFS0bits.AD1IF = 0;
		#else
			IFS1CLR = _IFS1_AD1IF_MASK;
9d009550:	24170002 	li	s7,2
		#endif
		w = LFSRRand();
	
		// Wait no longer than 1 second obtaining entropy
		dwTotalTime += wTime;
		if(dwTotalTime >= GetInstructionClock())
9d009554:	37deb400 	ori	s8,s8,0xb400
	dwTotalTime = 0;
	wLastValue = 0;
	randomResult.dw = LFSRRand();
	while(1)
	{
		ClrWdt();
9d009558:	ae760008 	sw	s6,8(s3)
		#if defined(__C30__)
			while(!IFS0bits.AD1IF);
		#else
			while(!IFS1bits.AD1IF);
9d00955c:	8c621040 	lw	v0,4160(v1)
9d009560:	30420002 	andi	v0,v0,0x2
9d009564:	1040fffd 	beqz	v0,9d00955c <GenerateRandomDWORD+0xf8>
9d009568:	00000000 	nop
		#endif
		wTime = TMR1;
9d00956c:	8e050610 	lw	a1,1552(s0)
		#if defined(__C30__)
			IFS0bits.AD1IF = 0;
		#else
			IFS1CLR = _IFS1_AD1IF_MASK;
		#endif
		w = LFSRRand();
9d009570:	afa3002c 	sw	v1,44(sp)
			while(!IFS0bits.AD1IF);
		#else
			while(!IFS1bits.AD1IF);
		#endif
		wTime = TMR1;
		TMR1 = 0x0000;
9d009574:	ae000610 	sw	zero,1552(s0)
		#if defined(__C30__)
			while(!IFS0bits.AD1IF);
		#else
			while(!IFS1bits.AD1IF);
		#endif
		wTime = TMR1;
9d009578:	30a5ffff 	andi	a1,a1,0xffff
			IFS1CLR = _IFS1_AD1IF_MASK;
		#endif
		w = LFSRRand();
	
		// Wait no longer than 1 second obtaining entropy
		dwTotalTime += wTime;
9d00957c:	00c53021 	addu	a2,a2,a1
		#if defined(__C30__)
			IFS0bits.AD1IF = 0;
		#else
			IFS1CLR = _IFS1_AD1IF_MASK;
		#endif
		w = LFSRRand();
9d009580:	afa50028 	sw	a1,40(sp)
9d009584:	afa60024 	sw	a2,36(sp)
		TMR1 = 0x0000;

		#if defined(__C30__)
			IFS0bits.AD1IF = 0;
		#else
			IFS1CLR = _IFS1_AD1IF_MASK;
9d009588:	aeb71044 	sw	s7,4164(s5)
		#endif
		w = LFSRRand();
9d00958c:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d009590:	00000000 	nop
	
		// Wait no longer than 1 second obtaining entropy
		dwTotalTime += wTime;
		if(dwTotalTime >= GetInstructionClock())
9d009594:	8fa60024 	lw	a2,36(sp)
9d009598:	8fa3002c 	lw	v1,44(sp)
9d00959c:	00de382b 	sltu	a3,a2,s8
9d0095a0:	10e00017 	beqz	a3,9d009600 <GenerateRandomDWORD+0x19c>
9d0095a4:	8fa50028 	lw	a1,40(sp)
			randomResult.w[1] ^= LFSRRand();
			break;
		}
	
		// Keep sampling if minimal entropy was likely obtained this round
		if(wLastValue == wTime)
9d0095a8:	1285ffeb 	beq	s4,a1,9d009558 <GenerateRandomDWORD+0xf4>
9d0095ac:	02852023 	subu	a0,s4,a1
			continue;
	
		// Add this entropy into the pseudo random number generator by reseeding
		LFSRSeedRand(w + (wLastValue - wTime));
9d0095b0:	00822021 	addu	a0,a0,v0
9d0095b4:	afa3002c 	sw	v1,44(sp)
9d0095b8:	afa50028 	sw	a1,40(sp)
9d0095bc:	0f402505 	jal	9d009414 <LFSRSeedRand>
9d0095c0:	afa60024 	sw	a2,36(sp)
		wLastValue = wTime;
	
		// Accumulate at least 32 bits of randomness over time
		randomResult.dw <<= 1;
		if(LFSRRand() & 0x0080)
9d0095c4:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d0095c8:	00118840 	sll	s1,s1,0x1
9d0095cc:	30420080 	andi	v0,v0,0x80
9d0095d0:	8fa3002c 	lw	v1,44(sp)
9d0095d4:	8fa50028 	lw	a1,40(sp)
9d0095d8:	10400003 	beqz	v0,9d0095e8 <GenerateRandomDWORD+0x184>
9d0095dc:	8fa60024 	lw	a2,36(sp)
			randomResult.w[0] |= 0x1;
9d0095e0:	36220001 	ori	v0,s1,0x1
9d0095e4:	7c517804 	ins	s1,v0,0x0,0x10
	
		// See if we've collected a fair amount of entropy and can quit early
		if(++vBitCount == 0u)
9d0095e8:	26520001 	addiu	s2,s2,1
9d0095ec:	325200ff 	andi	s2,s2,0xff
9d0095f0:	1240000b 	beqz	s2,9d009620 <GenerateRandomDWORD+0x1bc>
9d0095f4:	00a0a021 	move	s4,a1
9d0095f8:	0b402556 	j	9d009558 <GenerateRandomDWORD+0xf4>
9d0095fc:	00000000 	nop
	
		// Wait no longer than 1 second obtaining entropy
		dwTotalTime += wTime;
		if(dwTotalTime >= GetInstructionClock())
		{
			randomResult.w[0] ^= LFSRRand();
9d009600:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d009604:	3230ffff 	andi	s0,s1,0xffff
9d009608:	00501026 	xor	v0,v0,s0
9d00960c:	7c517804 	ins	s1,v0,0x0,0x10
			randomResult.w[1] ^= LFSRRand();
9d009610:	0f4024f5 	jal	9d0093d4 <LFSRRand>
9d009614:	00118402 	srl	s0,s1,0x10
9d009618:	00501026 	xor	v0,v0,s0
9d00961c:	7c51fc04 	ins	s1,v0,0x10,0x10
	}


	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = AD1CON3Save;
9d009620:	8fa30018 	lw	v1,24(sp)
			break;
	}


	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9d009624:	3c06bf81 	lui	a2,0xbf81
	AD1CON3 = AD1CON3Save;
9d009628:	3c07bf81 	lui	a3,0xbf81
			break;
	}


	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9d00962c:	acc09000 	sw	zero,-28672(a2)
	AD1CON3 = AD1CON3Save;
	AD1CON2 = AD1CON2Save;
9d009630:	8fa50014 	lw	a1,20(sp)
	}


	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = AD1CON3Save;
9d009634:	ace39020 	sw	v1,-28640(a3)
	AD1CON2 = AD1CON2Save;
	AD1CON1 = AD1CON1Save;
9d009638:	8fa70010 	lw	a3,16(sp)


	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = AD1CON3Save;
	AD1CON2 = AD1CON2Save;
9d00963c:	3c04bf81 	lui	a0,0xbf81
9d009640:	ac859010 	sw	a1,-28656(a0)
	PR1 = PR1Save;
}
#endif

	return randomResult.dw;
}
9d009644:	8fbf0054 	lw	ra,84(sp)

	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = AD1CON3Save;
	AD1CON2 = AD1CON2Save;
	AD1CON1 = AD1CON1Save;
9d009648:	acc79000 	sw	a3,-28672(a2)
	T1CON = T1CONSave;
9d00964c:	8fa4001c 	lw	a0,28(sp)
	PR1 = PR1Save;
9d009650:	8fa60020 	lw	a2,32(sp)
	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = AD1CON3Save;
	AD1CON2 = AD1CON2Save;
	AD1CON1 = AD1CON1Save;
	T1CON = T1CONSave;
9d009654:	3c03bf80 	lui	v1,0xbf80
	PR1 = PR1Save;
9d009658:	3c05bf80 	lui	a1,0xbf80
}
#endif

	return randomResult.dw;
}
9d00965c:	02201021 	move	v0,s1
	// Restore hardware SFRs
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = AD1CON3Save;
	AD1CON2 = AD1CON2Save;
	AD1CON1 = AD1CON1Save;
	T1CON = T1CONSave;
9d009660:	ac640600 	sw	a0,1536(v1)
	PR1 = PR1Save;
}
#endif

	return randomResult.dw;
}
9d009664:	8fbe0050 	lw	s8,80(sp)
9d009668:	8fb7004c 	lw	s7,76(sp)
9d00966c:	8fb60048 	lw	s6,72(sp)
9d009670:	8fb50044 	lw	s5,68(sp)
9d009674:	8fb40040 	lw	s4,64(sp)
9d009678:	8fb3003c 	lw	s3,60(sp)
9d00967c:	8fb20038 	lw	s2,56(sp)
9d009680:	8fb10034 	lw	s1,52(sp)
9d009684:	8fb00030 	lw	s0,48(sp)
	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
	AD1CON3 = AD1CON3Save;
	AD1CON2 = AD1CON2Save;
	AD1CON1 = AD1CON1Save;
	T1CON = T1CONSave;
	PR1 = PR1Save;
9d009688:	aca60620 	sw	a2,1568(a1)
}
#endif

	return randomResult.dw;
}
9d00968c:	03e00008 	jr	ra
9d009690:	27bd0058 	addiu	sp,sp,88

9d009694 <StringToIPAddress>:
		}
		else
		{
			if(i == (BYTE)('.' - '0'))
			{
				if(dwVal.Val > 0x00020505ul)
9d009694:	3c0b0002 	lui	t3,0x2
	DWORD_VAL dwVal;
	BYTE i, charLen, currentOctet;

	charLen = 0;
	currentOctet = 0;
	dwVal.Val = 0;
9d009698:	00001821 	move	v1,zero
{
	DWORD_VAL dwVal;
	BYTE i, charLen, currentOctet;

	charLen = 0;
	currentOctet = 0;
9d00969c:	00004021 	move	t0,zero
BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress)
{
	DWORD_VAL dwVal;
	BYTE i, charLen, currentOctet;

	charLen = 0;
9d0096a0:	00001021 	move	v0,zero
		if(charLen == 0u)
		{
			if(i > 9u)
				return FALSE;
		}
		else if(charLen == 3u)
9d0096a4:	24090003 	li	t1,3
			dwVal.Val = 0;
			continue;
		}
		else
		{
			if(i == (BYTE)('.' - '0'))
9d0096a8:	240a00fe 	li	t2,254
			{
				if(dwVal.Val > 0x00020505ul)
9d0096ac:	256b0506 	addiu	t3,t3,1286
	BYTE i, charLen, currentOctet;

	charLen = 0;
	currentOctet = 0;
	dwVal.Val = 0;
	while((i = *str++))
9d0096b0:	90860000 	lbu	a2,0(a0)
9d0096b4:	10c00011 	beqz	a2,9d0096fc <StringToIPAddress+0x68>
9d0096b8:	24840001 	addiu	a0,a0,1
	{
		if(currentOctet > 3u)
9d0096bc:	2d070004 	sltiu	a3,t0,4
9d0096c0:	50e00044 	beqzl	a3,9d0097d4 <StringToIPAddress+0x140>
9d0096c4:	2402002f 	li	v0,47
			break;

		i -= '0';
9d0096c8:	24c6ffd0 	addiu	a2,a2,-48
		

		// Validate the character is a numerical digit or dot, depending on location
		if(charLen == 0u)
9d0096cc:	1440001f 	bnez	v0,9d00974c <StringToIPAddress+0xb8>
9d0096d0:	30c600ff 	andi	a2,a2,0xff
		{
			if(i > 9u)
9d0096d4:	2cc7000a 	sltiu	a3,a2,10
9d0096d8:	10e0003c 	beqz	a3,9d0097cc <StringToIPAddress+0x138>
9d0096dc:	00000000 	nop
			if(i > 9u)
				return FALSE;
		}

		charLen++;
		dwVal.Val <<= 8;
9d0096e0:	00031a00 	sll	v1,v1,0x8
		dwVal.v[0] = i;
9d0096e4:	7cc33804 	ins	v1,a2,0x0,0x8
	BYTE i, charLen, currentOctet;

	charLen = 0;
	currentOctet = 0;
	dwVal.Val = 0;
	while((i = *str++))
9d0096e8:	90860000 	lbu	a2,0(a0)
			}
			if(i > 9u)
				return FALSE;
		}

		charLen++;
9d0096ec:	24420001 	addiu	v0,v0,1
9d0096f0:	304200ff 	andi	v0,v0,0xff
	BYTE i, charLen, currentOctet;

	charLen = 0;
	currentOctet = 0;
	dwVal.Val = 0;
	while((i = *str++))
9d0096f4:	14c0fff1 	bnez	a2,9d0096bc <StringToIPAddress+0x28>
9d0096f8:	24840001 	addiu	a0,a0,1
	// address as in "10.5.13.233.picsaregood.com"
	if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
		return FALSE;

	// Verify and convert the last octet and return the result
	if(dwVal.Val > 0x00020505ul)
9d0096fc:	3c040002 	lui	a0,0x2
9d009700:	24840506 	addiu	a0,a0,1286
9d009704:	0064202b 	sltu	a0,v1,a0
9d009708:	1080003f 	beqz	a0,9d009808 <StringToIPAddress+0x174>
9d00970c:	00001021 	move	v0,zero
		return FALSE;

	IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9d009710:	7c643c00 	ext	a0,v1,0x10,0x8
9d009714:	00041080 	sll	v0,a0,0x2
9d009718:	00042100 	sll	a0,a0,0x4
9d00971c:	00441021 	addu	v0,v0,a0
9d009720:	7c643a00 	ext	a0,v1,0x8,0x8
9d009724:	00043040 	sll	a2,a0,0x1
9d009728:	00023880 	sll	a3,v0,0x2
9d00972c:	000420c0 	sll	a0,a0,0x3
9d009730:	00471021 	addu	v0,v0,a3
9d009734:	00c42021 	addu	a0,a2,a0
9d009738:	00441021 	addu	v0,v0,a0
9d00973c:	00431821 	addu	v1,v0,v1
9d009740:	a0a30003 	sb	v1,3(a1)

	return TRUE;
9d009744:	03e00008 	jr	ra
9d009748:	24020001 	li	v0,1
		if(charLen == 0u)
		{
			if(i > 9u)
				return FALSE;
		}
		else if(charLen == 3u)
9d00974c:	10490007 	beq	v0,t1,9d00976c <StringToIPAddress+0xd8>
9d009750:	00000000 	nop
			dwVal.Val = 0;
			continue;
		}
		else
		{
			if(i == (BYTE)('.' - '0'))
9d009754:	10ca0007 	beq	a2,t2,9d009774 <StringToIPAddress+0xe0>
9d009758:	2cc7000a 	sltiu	a3,a2,10
				IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
				charLen = 0;
				dwVal.Val = 0;
				continue;
			}
			if(i > 9u)
9d00975c:	54e0ffe1 	bnezl	a3,9d0096e4 <StringToIPAddress+0x50>
9d009760:	00031a00 	sll	v1,v1,0x8
		return FALSE;

	IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];

	return TRUE;
}
9d009764:	03e00008 	jr	ra
9d009768:	00001021 	move	v0,zero
			if(i > 9u)
				return FALSE;
		}
		else if(charLen == 3u)
		{
			if(i != (BYTE)('.' - '0'))
9d00976c:	14ca0017 	bne	a2,t2,9d0097cc <StringToIPAddress+0x138>
9d009770:	00000000 	nop
		}
		else
		{
			if(i == (BYTE)('.' - '0'))
			{
				if(dwVal.Val > 0x00020505ul)
9d009774:	006b102b 	sltu	v0,v1,t3
9d009778:	10400014 	beqz	v0,9d0097cc <StringToIPAddress+0x138>
9d00977c:	00000000 	nop
					return FALSE;

				IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9d009780:	7c663c00 	ext	a2,v1,0x10,0x8
9d009784:	00063880 	sll	a3,a2,0x2
9d009788:	00061100 	sll	v0,a2,0x4
9d00978c:	00e21021 	addu	v0,a3,v0
9d009790:	7c663a00 	ext	a2,v1,0x8,0x8
9d009794:	00063840 	sll	a3,a2,0x1
9d009798:	00026080 	sll	t4,v0,0x2
9d00979c:	000630c0 	sll	a2,a2,0x3
9d0097a0:	00e63021 	addu	a2,a3,a2
9d0097a4:	004c1021 	addu	v0,v0,t4
9d0097a8:	00461021 	addu	v0,v0,a2
9d0097ac:	00431821 	addu	v1,v0,v1
9d0097b0:	00a83821 	addu	a3,a1,t0
9d0097b4:	25080001 	addiu	t0,t0,1
9d0097b8:	a0e30000 	sb	v1,0(a3)
9d0097bc:	310800ff 	andi	t0,t0,0xff
				charLen = 0;
				dwVal.Val = 0;
9d0097c0:	00001821 	move	v1,zero
				continue;
9d0097c4:	0b4025ac 	j	9d0096b0 <StringToIPAddress+0x1c>
9d0097c8:	00001021 	move	v0,zero
		else
		{
			if(i == (BYTE)('.' - '0'))
			{
				if(dwVal.Val > 0x00020505ul)
					return FALSE;
9d0097cc:	03e00008 	jr	ra
9d0097d0:	00001021 	move	v0,zero
	}

	// Make sure the very last character is a valid termination character 
	// (i.e., not more hostname, which could be legal and not an IP 
	// address as in "10.5.13.233.picsaregood.com"
	if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
9d0097d4:	10c2ffca 	beq	a2,v0,9d009700 <StringToIPAddress+0x6c>
9d0097d8:	3c040002 	lui	a0,0x2
9d0097dc:	2402000d 	li	v0,13
9d0097e0:	10c2ffc8 	beq	a2,v0,9d009704 <StringToIPAddress+0x70>
9d0097e4:	24840506 	addiu	a0,a0,1286
9d0097e8:	2402000a 	li	v0,10
9d0097ec:	10c2ffc4 	beq	a2,v0,9d009700 <StringToIPAddress+0x6c>
9d0097f0:	3c040002 	lui	a0,0x2
9d0097f4:	24020020 	li	v0,32
9d0097f8:	10c2ffc0 	beq	a2,v0,9d0096fc <StringToIPAddress+0x68>
9d0097fc:	24040009 	li	a0,9
9d009800:	10c4ffbe 	beq	a2,a0,9d0096fc <StringToIPAddress+0x68>
9d009804:	00001021 	move	v0,zero
		return FALSE;

	IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];

	return TRUE;
}
9d009808:	03e00008 	jr	ra
9d00980c:	00000000 	nop

9d009810 <swaps>:

  Returns:
	The swapped version of v.
  ***************************************************************************/
WORD swaps(WORD v)
{
9d009810:	3084ffff 	andi	a0,a0,0xffff
	WORD_VAL t;
	BYTE b;

	t.Val   = v;
9d009814:	00801021 	move	v0,a0
	b       = t.v[1];
9d009818:	00041a02 	srl	v1,a0,0x8
	t.v[1]  = t.v[0];
9d00981c:	7c827a04 	ins	v0,a0,0x8,0x8
	t.v[0]  = b;
9d009820:	7c623804 	ins	v0,v1,0x0,0x8

	return t.Val;
}
9d009824:	03e00008 	jr	ra
9d009828:	3042ffff 	andi	v0,v0,0xffff

9d00982c <swapl>:
	The swapped version of v.
  ***************************************************************************/
DWORD swapl(DWORD v)
{
	// Swap bytes 0 and 3
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9d00982c:	00041e02 	srl	v1,a0,0x18
	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];

	// Swap bytes 1 and 2
	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9d009830:	7c823c00 	ext	v0,a0,0x10,0x8
	The swapped version of v.
  ***************************************************************************/
DWORD swapl(DWORD v)
{
	// Swap bytes 0 and 3
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9d009834:	00642826 	xor	a1,v1,a0
	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];

	// Swap bytes 1 and 2
	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9d009838:	7c843a00 	ext	a0,a0,0x8,0x8
	The swapped version of v.
  ***************************************************************************/
DWORD swapl(DWORD v)
{
	// Swap bytes 0 and 3
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9d00983c:	30a500ff 	andi	a1,a1,0xff
	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];

	// Swap bytes 1 and 2
	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9d009840:	00822026 	xor	a0,a0,v0
  ***************************************************************************/
DWORD swapl(DWORD v)
{
	// Swap bytes 0 and 3
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
9d009844:	00a31826 	xor	v1,a1,v1
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];

	// Swap bytes 1 and 2
	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
	((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1];
9d009848:	00821026 	xor	v0,a0,v0
	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9d00984c:	00442026 	xor	a0,v0,a0
DWORD swapl(DWORD v)
{
	// Swap bytes 0 and 3
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9d009850:	00652826 	xor	a1,v1,a1
  ***************************************************************************/
DWORD swapl(DWORD v)
{
	// Swap bytes 0 and 3
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
9d009854:	a3a30003 	sb	v1,3(sp)
	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9d009858:	a3a50000 	sb	a1,0(sp)

	// Swap bytes 1 and 2
	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
	((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1];
9d00985c:	a3a20002 	sb	v0,2(sp)
	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9d009860:	a3a40001 	sb	a0,1(sp)

	return v;
}
9d009864:	03e00008 	jr	ra
9d009868:	8fa20000 	lw	v0,0(sp)

9d00986c <CalcIPChecksum>:
	
  Internal:
	This function could be improved to do 32-bit sums on PIC32 platforms.
  ***************************************************************************/
WORD CalcIPChecksum(BYTE* buffer, WORD count)
{
9d00986c:	30a5ffff 	andi	a1,a1,0xffff
	{
		WORD w[2];
		DWORD dw;
	} sum;

	i = count >> 1;
9d009870:	00051042 	srl	v0,a1,0x1
	val = (WORD*)buffer;
9d009874:	00804021 	move	t0,a0

	// Calculate the sum of all words
	sum.dw = 0x00000000ul;
	while(i--)
9d009878:	1040000e 	beqz	v0,9d0098b4 <CalcIPChecksum+0x48>
9d00987c:	00001821 	move	v1,zero
9d009880:	2442ffff 	addiu	v0,v0,-1
	The calculated checksum.
	
  Internal:
	This function could be improved to do 32-bit sums on PIC32 platforms.
  ***************************************************************************/
WORD CalcIPChecksum(BYTE* buffer, WORD count)
9d009884:	3048ffff 	andi	t0,v0,0xffff
9d009888:	00081040 	sll	v0,t0,0x1
9d00988c:	24870002 	addiu	a3,a0,2
9d009890:	00e23821 	addu	a3,a3,v0
		WORD w[2];
		DWORD dw;
	} sum;

	i = count >> 1;
	val = (WORD*)buffer;
9d009894:	00801021 	move	v0,a0

	// Calculate the sum of all words
	sum.dw = 0x00000000ul;
	while(i--)
		sum.dw += (DWORD)*val++;
9d009898:	94460000 	lhu	a2,0(v0)
9d00989c:	24420002 	addiu	v0,v0,2
	i = count >> 1;
	val = (WORD*)buffer;

	// Calculate the sum of all words
	sum.dw = 0x00000000ul;
	while(i--)
9d0098a0:	1447fffd 	bne	v0,a3,9d009898 <CalcIPChecksum+0x2c>
9d0098a4:	00661821 	addu	v1,v1,a2
	The calculated checksum.
	
  Internal:
	This function could be improved to do 32-bit sums on PIC32 platforms.
  ***************************************************************************/
WORD CalcIPChecksum(BYTE* buffer, WORD count)
9d0098a8:	25080001 	addiu	t0,t0,1
9d0098ac:	00084040 	sll	t0,t0,0x1
	i = count >> 1;
	val = (WORD*)buffer;

	// Calculate the sum of all words
	sum.dw = 0x00000000ul;
	while(i--)
9d0098b0:	00884021 	addu	t0,a0,t0
		sum.dw += (DWORD)*val++;

	// Add in the sum of the remaining byte, if present
	if(count & 0x1)
9d0098b4:	30a50001 	andi	a1,a1,0x1
9d0098b8:	50a00004 	beqzl	a1,9d0098cc <CalcIPChecksum+0x60>
9d0098bc:	00031402 	srl	v0,v1,0x10
		sum.dw += (DWORD)*(BYTE*)val;
9d0098c0:	91020000 	lbu	v0,0(t0)
9d0098c4:	00431821 	addu	v1,v0,v1

	// Do an end-around carry (one's complement arrithmatic)
	sum.dw = sum.w[0] + sum.w[1];
9d0098c8:	00031402 	srl	v0,v1,0x10
9d0098cc:	3063ffff 	andi	v1,v1,0xffff
9d0098d0:	00431821 	addu	v1,v0,v1

	// Do another end-around carry in case if the prior add 
	// caused a carry out
	sum.w[0] += sum.w[1];
9d0098d4:	7c627c00 	ext	v0,v1,0x10,0x10
9d0098d8:	00431821 	addu	v1,v0,v1

	// Return the resulting checksum
	return ~sum.w[0];
9d0098dc:	00031027 	nor	v0,zero,v1
}
9d0098e0:	03e00008 	jr	ra
9d0098e4:	3042ffff 	andi	v0,v0,0xffff

9d0098e8 <FormatNetBIOSName>:
{
	char c;
	char *t;

	t = s;
	while( (c = *t) )
9d0098e8:	80830000 	lb	v1,0(a0)
  ***************************************************************************/
void FormatNetBIOSName(BYTE Name[])
{
	BYTE i;

	Name[15] = '\0';
9d0098ec:	a080000f 	sb	zero,15(a0)
{
	char c;
	char *t;

	t = s;
	while( (c = *t) )
9d0098f0:	1060000c 	beqz	v1,9d009924 <FormatNetBIOSName+0x3c>
9d0098f4:	00801021 	move	v0,a0
	{
		if(c >= 'a' && c <= 'z')
9d0098f8:	306300ff 	andi	v1,v1,0xff
9d0098fc:	2465ff9f 	addiu	a1,v1,-97
9d009900:	30a500ff 	andi	a1,a1,0xff
9d009904:	2ca5001a 	sltiu	a1,a1,26
9d009908:	10a00002 	beqz	a1,9d009914 <FormatNetBIOSName+0x2c>
9d00990c:	2463ffe0 	addiu	v1,v1,-32
		{
			*t -= ('a' - 'A');
9d009910:	a0430000 	sb	v1,0(v0)
		}
		t++;
9d009914:	24420001 	addiu	v0,v0,1
{
	char c;
	char *t;

	t = s;
	while( (c = *t) )
9d009918:	80430000 	lb	v1,0(v0)
9d00991c:	5460fff7 	bnezl	v1,9d0098fc <FormatNetBIOSName+0x14>
9d009920:	306300ff 	andi	v1,v1,0xff
			}
			break;
		}
		i++;
	}
}
9d009924:	00801821 	move	v1,a0

  Returns:
	None
  ***************************************************************************/
void FormatNetBIOSName(BYTE Name[])
{
9d009928:	00001021 	move	v0,zero
	BYTE i;

	Name[15] = '\0';
	strupr((char*)Name);
	i = 0;
	while(i < 15u)
9d00992c:	2407000f 	li	a3,15
	{
		if(Name[i] == '\0')
9d009930:	90650000 	lbu	a1,0(v1)
			{
				Name[i++] = ' ';
			}
			break;
		}
		i++;
9d009934:	24460001 	addiu	a2,v0,1
	Name[15] = '\0';
	strupr((char*)Name);
	i = 0;
	while(i < 15u)
	{
		if(Name[i] == '\0')
9d009938:	10a00006 	beqz	a1,9d009954 <FormatNetBIOSName+0x6c>
9d00993c:	24630001 	addiu	v1,v1,1
			{
				Name[i++] = ' ';
			}
			break;
		}
		i++;
9d009940:	30c200ff 	andi	v0,a2,0xff
	BYTE i;

	Name[15] = '\0';
	strupr((char*)Name);
	i = 0;
	while(i < 15u)
9d009944:	5447fffb 	bnel	v0,a3,9d009934 <FormatNetBIOSName+0x4c>
9d009948:	90650000 	lbu	a1,0(v1)
9d00994c:	03e00008 	jr	ra
9d009950:	00000000 	nop
	{
		if(Name[i] == '\0')
		{
			while(i < 15u)
9d009954:	2c43000f 	sltiu	v1,v0,15
9d009958:	1060000a 	beqz	v1,9d009984 <FormatNetBIOSName+0x9c>
9d00995c:	00000000 	nop
			{
				Name[i++] = ' ';
9d009960:	24070020 	li	a3,32
	i = 0;
	while(i < 15u)
	{
		if(Name[i] == '\0')
		{
			while(i < 15u)
9d009964:	2406000f 	li	a2,15
			{
				Name[i++] = ' ';
9d009968:	24450001 	addiu	a1,v0,1
9d00996c:	00821821 	addu	v1,a0,v0
9d009970:	30a200ff 	andi	v0,a1,0xff
	i = 0;
	while(i < 15u)
	{
		if(Name[i] == '\0')
		{
			while(i < 15u)
9d009974:	1446fffc 	bne	v0,a2,9d009968 <FormatNetBIOSName+0x80>
9d009978:	a0670000 	sb	a3,0(v1)
9d00997c:	03e00008 	jr	ra
9d009980:	00000000 	nop
9d009984:	03e00008 	jr	ra
9d009988:	00000000 	nop

9d00998c <RebootTask>:
		BYTE vMACAddress[6];
		DWORD dwIPAddress;
		WORD wChecksum;
	} BootloaderAddress;
	
	if(MySocket == INVALID_UDP_SOCKET)
9d00998c:	9384802c 	lbu	a0,-32724(gp)
 *					Ethernet bootloader.  By resetting, the Ethernet 
 *					bootloader can take control for a second and let
 *					a firmware upgrade take place.
 ********************************************************************/
void RebootTask(void)
{
9d009990:	27bdffd8 	addiu	sp,sp,-40
9d009994:	afb00020 	sw	s0,32(sp)
		BYTE vMACAddress[6];
		DWORD dwIPAddress;
		WORD wChecksum;
	} BootloaderAddress;
	
	if(MySocket == INVALID_UDP_SOCKET)
9d009998:	241000ff 	li	s0,255
9d00999c:	10900018 	beq	a0,s0,9d009a00 <RebootTask+0x74>
9d0099a0:	afbf0024 	sw	ra,36(sp)

	if(MySocket == INVALID_UDP_SOCKET)
		return;

	// Do nothing if no data is waiting
	if(!UDPIsGetReady(MySocket))
9d0099a4:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d0099a8:	00000000 	nop
9d0099ac:	10400010 	beqz	v0,9d0099f0 <RebootTask+0x64>
9d0099b0:	3c05a001 	lui	a1,0xa001
		return;

	#if defined(REBOOT_SAME_SUBNET_ONLY)
		// Respond only to name requests sent to us from nodes on the same subnet
     	if((remoteNode.IPAddr.Val & AppConfig.MyMask.Val) != (AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val))
9d0099b4:	3c03a001 	lui	v1,0xa001
9d0099b8:	24a49a5c 	addiu	a0,a1,-26020
9d0099bc:	24669a90 	addiu	a2,v1,-25968
9d0099c0:	88c70003 	lwl	a3,3(a2)
9d0099c4:	88820003 	lwl	v0,3(a0)
9d0099c8:	88860007 	lwl	a2,7(a0)
9d0099cc:	98679a90 	lwr	a3,-25968(v1)
9d0099d0:	98a29a5c 	lwr	v0,-26020(a1)
9d0099d4:	98860004 	lwr	a2,4(a0)
9d0099d8:	00473826 	xor	a3,v0,a3
9d0099dc:	00e63024 	and	a2,a3,a2
9d0099e0:	50c00012 	beqzl	a2,9d009a2c <RebootTask+0xa0>
9d0099e4:	88830030 	lwl	v1,48(a0)
		{
			UDPDiscard();
9d0099e8:	0f40132c 	jal	9d004cb0 <UDPDiscard>
9d0099ec:	00000000 	nop
		PRODH = wvPROD.v[1];
		PRODL = wvPROD.v[0];
	}
	#endif
	Reset();
}
9d0099f0:	8fbf0024 	lw	ra,36(sp)
9d0099f4:	8fb00020 	lw	s0,32(sp)
9d0099f8:	03e00008 	jr	ra
9d0099fc:	27bd0028 	addiu	sp,sp,40
		DWORD dwIPAddress;
		WORD wChecksum;
	} BootloaderAddress;
	
	if(MySocket == INVALID_UDP_SOCKET)
		MySocket = UDPOpen(REBOOT_PORT, NULL, INVALID_UDP_PORT);
9d009a00:	24040045 	li	a0,69
9d009a04:	00002821 	move	a1,zero
9d009a08:	0f4011e9 	jal	9d0047a4 <UDPOpen>
9d009a0c:	00003021 	move	a2,zero
9d009a10:	00402021 	move	a0,v0

	if(MySocket == INVALID_UDP_SOCKET)
9d009a14:	1450ffe3 	bne	v0,s0,9d0099a4 <RebootTask+0x18>
9d009a18:	a382802c 	sb	v0,-32724(gp)
		PRODH = wvPROD.v[1];
		PRODL = wvPROD.v[0];
	}
	#endif
	Reset();
}
9d009a1c:	8fbf0024 	lw	ra,36(sp)
9d009a20:	8fb00020 	lw	s0,32(sp)
9d009a24:	03e00008 	jr	ra
9d009a28:	27bd0028 	addiu	sp,sp,40
			return;
		}
	#endif

	// Get our MAC address, IP address, and compute a checksum of them 
	memcpy((void*)&BootloaderAddress.vMACAddress[0], (void*)&AppConfig.MyMACAddr.v[0], sizeof(AppConfig.MyMACAddr));
9d009a2c:	90870031 	lbu	a3,49(a0)
9d009a30:	90860032 	lbu	a2,50(a0)
9d009a34:	9883002d 	lwr	v1,45(a0)
	BootloaderAddress.dwIPAddress = AppConfig.MyIPAddr.Val;
	BootloaderAddress.wChecksum = CalcIPChecksum((BYTE*)&BootloaderAddress, sizeof(BootloaderAddress) - sizeof(BootloaderAddress.wChecksum));
9d009a38:	2405000e 	li	a1,14
9d009a3c:	27a40010 	addiu	a0,sp,16
			return;
		}
	#endif

	// Get our MAC address, IP address, and compute a checksum of them 
	memcpy((void*)&BootloaderAddress.vMACAddress[0], (void*)&AppConfig.MyMACAddr.v[0], sizeof(AppConfig.MyMACAddr));
9d009a40:	afa30010 	sw	v1,16(sp)
9d009a44:	a3a70014 	sb	a3,20(sp)
9d009a48:	a3a60015 	sb	a2,21(sp)
	BootloaderAddress.dwIPAddress = AppConfig.MyIPAddr.Val;
	BootloaderAddress.wChecksum = CalcIPChecksum((BYTE*)&BootloaderAddress, sizeof(BootloaderAddress) - sizeof(BootloaderAddress.wChecksum));
9d009a4c:	0f40261b 	jal	9d00986c <CalcIPChecksum>
9d009a50:	afa20018 	sw	v0,24(sp)
	// to us.
	#if defined(USE_LCD)
		strcpypgm2ram((char*)LCDText, "Bootloader Reset");
		LCDUpdate();
	#endif
	RCONbits.POR = 0;
9d009a54:	3c03bf81 	lui	v1,0xbf81
9d009a58:	8c64f600 	lw	a0,-2560(v1)
	#endif

	// Get our MAC address, IP address, and compute a checksum of them 
	memcpy((void*)&BootloaderAddress.vMACAddress[0], (void*)&AppConfig.MyMACAddr.v[0], sizeof(AppConfig.MyMACAddr));
	BootloaderAddress.dwIPAddress = AppConfig.MyIPAddr.Val;
	BootloaderAddress.wChecksum = CalcIPChecksum((BYTE*)&BootloaderAddress, sizeof(BootloaderAddress) - sizeof(BootloaderAddress.wChecksum));
9d009a5c:	a7a2001c 	sh	v0,28(sp)
	// to us.
	#if defined(USE_LCD)
		strcpypgm2ram((char*)LCDText, "Bootloader Reset");
		LCDUpdate();
	#endif
	RCONbits.POR = 0;
9d009a60:	7c040004 	ins	a0,zero,0x0,0x1
9d009a64:	ac64f600 	sw	a0,-2560(v1)
		wvPROD.Val = ((WORD)&BootloaderAddress);
		PRODH = wvPROD.v[1];
		PRODL = wvPROD.v[0];
	}
	#endif
	Reset();
9d009a68:	0f403624 	jal	9d00d890 <SoftReset>
9d009a6c:	00000000 	nop

9d009a70 <NBNSTask>:
		NBNS_HOME = 0,
		NBNS_OPEN_SOCKET,
		NBNS_LISTEN
	} smNBNS = NBNS_HOME;

	switch(smNBNS)
9d009a70:	8f828104 	lw	v0,-32508(gp)
 * Overview:        Sends responses to NetBIOS name requests
 *
 * Note:            None
 ********************************************************************/
void NBNSTask(void)
{
9d009a74:	27bdffa0 	addiu	sp,sp,-96
		NBNS_HOME = 0,
		NBNS_OPEN_SOCKET,
		NBNS_LISTEN
	} smNBNS = NBNS_HOME;

	switch(smNBNS)
9d009a78:	24030001 	li	v1,1
 * Overview:        Sends responses to NetBIOS name requests
 *
 * Note:            None
 ********************************************************************/
void NBNSTask(void)
{
9d009a7c:	afbf005c 	sw	ra,92(sp)
9d009a80:	afbe0058 	sw	s8,88(sp)
9d009a84:	afb70054 	sw	s7,84(sp)
9d009a88:	afb60050 	sw	s6,80(sp)
9d009a8c:	afb5004c 	sw	s5,76(sp)
9d009a90:	afb40048 	sw	s4,72(sp)
9d009a94:	afb30044 	sw	s3,68(sp)
9d009a98:	afb20040 	sw	s2,64(sp)
9d009a9c:	afb1003c 	sw	s1,60(sp)
		NBNS_HOME = 0,
		NBNS_OPEN_SOCKET,
		NBNS_LISTEN
	} smNBNS = NBNS_HOME;

	switch(smNBNS)
9d009aa0:	104300dd 	beq	v0,v1,9d009e18 <NBNSTask+0x3a8>
9d009aa4:	afb00038 	sw	s0,56(sp)
9d009aa8:	10400010 	beqz	v0,9d009aec <NBNSTask+0x7c>
9d009aac:	8fbf005c 	lw	ra,92(sp)
9d009ab0:	24030002 	li	v1,2
9d009ab4:	10430019 	beq	v0,v1,9d009b1c <NBNSTask+0xac>
9d009ab8:	93848108 	lbu	a0,-32504(gp)
			
			UDPDiscard();

			break;
	}
}
9d009abc:	8fbf005c 	lw	ra,92(sp)
9d009ac0:	8fbe0058 	lw	s8,88(sp)
9d009ac4:	8fb70054 	lw	s7,84(sp)
9d009ac8:	8fb60050 	lw	s6,80(sp)
9d009acc:	8fb5004c 	lw	s5,76(sp)
9d009ad0:	8fb40048 	lw	s4,72(sp)
9d009ad4:	8fb30044 	lw	s3,68(sp)
9d009ad8:	8fb20040 	lw	s2,64(sp)
9d009adc:	8fb1003c 	lw	s1,60(sp)
9d009ae0:	8fb00038 	lw	s0,56(sp)
9d009ae4:	03e00008 	jr	ra
9d009ae8:	27bd0060 	addiu	sp,sp,96
9d009aec:	8fbe0058 	lw	s8,88(sp)
9d009af0:	8fb70054 	lw	s7,84(sp)
9d009af4:	8fb60050 	lw	s6,80(sp)
9d009af8:	8fb5004c 	lw	s5,76(sp)
9d009afc:	8fb40048 	lw	s4,72(sp)
9d009b00:	8fb30044 	lw	s3,68(sp)
9d009b04:	8fb20040 	lw	s2,64(sp)
9d009b08:	8fb1003c 	lw	s1,60(sp)
9d009b0c:	8fb00038 	lw	s0,56(sp)
	} smNBNS = NBNS_HOME;

	switch(smNBNS)
	{
		case NBNS_HOME:
			smNBNS++;
9d009b10:	af838104 	sw	v1,-32508(gp)
			
			UDPDiscard();

			break;
	}
}
9d009b14:	03e00008 	jr	ra
9d009b18:	27bd0060 	addiu	sp,sp,96
				break;

			smNBNS++;

		case NBNS_LISTEN:
			if(!UDPIsGetReady(MySocket))
9d009b1c:	0f4012e0 	jal	9d004b80 <UDPIsGetReady>
9d009b20:	00000000 	nop
9d009b24:	1040ffe5 	beqz	v0,9d009abc <NBNSTask+0x4c>
9d009b28:	3c12a001 	lui	s2,0xa001
				break;

			// Respond only to name requests sent to us from nodes on the same subnet
			// This prevents us from sending out the wrong IP address information if 
			// we haven't gotten a DHCP lease yet.
        	if((remoteNode.IPAddr.Val & AppConfig.MyMask.Val) != (AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val))
9d009b2c:	3c11a001 	lui	s1,0xa001
9d009b30:	26509a5c 	addiu	s0,s2,-26020
9d009b34:	26349a90 	addiu	s4,s1,-25968
9d009b38:	8a040003 	lwl	a0,3(s0)
9d009b3c:	8a830003 	lwl	v1,3(s4)
9d009b40:	8a020007 	lwl	v0,7(s0)
9d009b44:	9a449a5c 	lwr	a0,-26020(s2)
9d009b48:	9a239a90 	lwr	v1,-25968(s1)
9d009b4c:	9a020004 	lwr	v0,4(s0)
9d009b50:	00831826 	xor	v1,a0,v1
9d009b54:	00621024 	and	v0,v1,v0
9d009b58:	144000a1 	bnez	v0,9d009de0 <NBNSTask+0x370>
9d009b5c:	00000000 	nop
				UDPDiscard();
				break;
			}

			// Retrieve the NBNS header and de-big-endian it
			UDPGet(&NBNSHeader.TransactionID.v[1]);
9d009b60:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b64:	27a4001d 	addiu	a0,sp,29
			UDPGet(&NBNSHeader.TransactionID.v[0]);
9d009b68:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b6c:	27a4001c 	addiu	a0,sp,28
			UDPGet(&NBNSHeader.Flags.v[1]);
9d009b70:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b74:	27a4001f 	addiu	a0,sp,31
			UDPGet(&NBNSHeader.Flags.v[0]);
9d009b78:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b7c:	27a4001e 	addiu	a0,sp,30
			UDPGet(&NBNSHeader.Questions.v[1]);
9d009b80:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b84:	27a40021 	addiu	a0,sp,33
			UDPGet(&NBNSHeader.Questions.v[0]);
9d009b88:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b8c:	27a40020 	addiu	a0,sp,32
			UDPGet(&NBNSHeader.Answers.v[1]);
9d009b90:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b94:	27a40023 	addiu	a0,sp,35
			UDPGet(&NBNSHeader.Answers.v[0]);
9d009b98:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009b9c:	27a40022 	addiu	a0,sp,34
			UDPGet(&NBNSHeader.AuthoritativeRecords.v[1]);
9d009ba0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009ba4:	27a40025 	addiu	a0,sp,37
			UDPGet(&NBNSHeader.AuthoritativeRecords.v[0]);
9d009ba8:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009bac:	27a40024 	addiu	a0,sp,36
			UDPGet(&NBNSHeader.AdditionalRecords.v[1]);
9d009bb0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009bb4:	27a40027 	addiu	a0,sp,39
				UDPGet(&Type.v[1]);		// Question type
				UDPGet(&Type.v[0]);
				UDPGet(&Class.v[1]);	// Question class
				UDPGet(&Class.v[0]);
				
				if(Type.Val == 0x0020u && Class.Val == 0x0001u && memcmp((void*)NameString, (void*)AppConfig.NetBIOSName, sizeof(AppConfig.NetBIOSName)) == 0)
9d009bb8:	3c15a001 	lui	s5,0xa001
			UDPGet(&NBNSHeader.Answers.v[1]);
			UDPGet(&NBNSHeader.Answers.v[0]);
			UDPGet(&NBNSHeader.AuthoritativeRecords.v[1]);
			UDPGet(&NBNSHeader.AuthoritativeRecords.v[0]);
			UDPGet(&NBNSHeader.AdditionalRecords.v[1]);
			UDPGet(&NBNSHeader.AdditionalRecords.v[0]);
9d009bbc:	27a40026 	addiu	a0,sp,38
9d009bc0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009bc4:	3c16a001 	lui	s6,0xa001
				UDPGet(&Type.v[1]);		// Question type
				UDPGet(&Type.v[0]);
				UDPGet(&Class.v[1]);	// Question class
				UDPGet(&Class.v[0]);
				
				if(Type.Val == 0x0020u && Class.Val == 0x0001u && memcmp((void*)NameString, (void*)AppConfig.NetBIOSName, sizeof(AppConfig.NetBIOSName)) == 0)
9d009bc8:	26b59a78 	addiu	s5,s5,-25992
					UDPPut(AppConfig.MyIPAddr.v[1]);
					UDPPut(AppConfig.MyIPAddr.v[2]);
					UDPPut(AppConfig.MyIPAddr.v[3]);

					// Change the destination address to the unicast address of the last received packet
		        	memcpy((void*)&UDPSocketInfo[MySocket].remoteNode, (const void*)&remoteNode, sizeof(remoteNode));
9d009bcc:	26d69a9c 	addiu	s6,s6,-25956
			UDPGet(&NBNSHeader.AuthoritativeRecords.v[0]);
			UDPGet(&NBNSHeader.AdditionalRecords.v[1]);
			UDPGet(&NBNSHeader.AdditionalRecords.v[0]);

			// Remove all questions
			while(NBNSHeader.Questions.Val--)
9d009bd0:	97a20020 	lhu	v0,32(sp)
9d009bd4:	2443ffff 	addiu	v1,v0,-1
9d009bd8:	10400081 	beqz	v0,9d009de0 <NBNSTask+0x370>
9d009bdc:	a7a30020 	sh	v1,32(sp)
			UDPGet(&j);
		}
	}
	else
	{
		UDPGet(&i);
9d009be0:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009be4:	27a40011 	addiu	a0,sp,17
		if(i != 32u)
9d009be8:	93a30011 	lbu	v1,17(sp)
9d009bec:	24020020 	li	v0,32
9d009bf0:	10620095 	beq	v1,v0,9d009e48 <NBNSTask+0x3d8>
9d009bf4:	2402001f 	li	v0,31
		{
			*String = 0;
9d009bf8:	a3a00028 	sb	zero,40(sp)

			// Remove all questions
			while(NBNSHeader.Questions.Val--)
			{
				NBNSGetName(NameString);
				UDPGet(&i);				// <??> Trailing character on string
9d009bfc:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009c00:	27a40010 	addiu	a0,sp,16
				UDPGet(&Type.v[1]);		// Question type
9d009c04:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009c08:	27a40015 	addiu	a0,sp,21
				UDPGet(&Type.v[0]);
9d009c0c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009c10:	27a40014 	addiu	a0,sp,20
				UDPGet(&Class.v[1]);	// Question class
9d009c14:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009c18:	27a40019 	addiu	a0,sp,25
				UDPGet(&Class.v[0]);
9d009c1c:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009c20:	27a40018 	addiu	a0,sp,24
				
				if(Type.Val == 0x0020u && Class.Val == 0x0001u && memcmp((void*)NameString, (void*)AppConfig.NetBIOSName, sizeof(AppConfig.NetBIOSName)) == 0)
9d009c24:	97a30014 	lhu	v1,20(sp)
9d009c28:	24020020 	li	v0,32
9d009c2c:	1462ffe9 	bne	v1,v0,9d009bd4 <NBNSTask+0x164>
9d009c30:	97a20020 	lhu	v0,32(sp)
9d009c34:	97a30018 	lhu	v1,24(sp)
9d009c38:	24020001 	li	v0,1
9d009c3c:	1462ffe5 	bne	v1,v0,9d009bd4 <NBNSTask+0x164>
9d009c40:	97a20020 	lhu	v0,32(sp)
9d009c44:	27a40028 	addiu	a0,sp,40
9d009c48:	02a02821 	move	a1,s5
9d009c4c:	0f402fc1 	jal	9d00bf04 <memcmp>
9d009c50:	24060010 	li	a2,16
9d009c54:	1440ffdf 	bnez	v0,9d009bd4 <NBNSTask+0x164>
9d009c58:	97a20020 	lhu	v0,32(sp)
				{
					while(!UDPIsPutReady(MySocket));
9d009c5c:	0f401246 	jal	9d004918 <UDPIsPutReady>
9d009c60:	93848108 	lbu	a0,-32504(gp)
9d009c64:	1040fffd 	beqz	v0,9d009c5c <NBNSTask+0x1ec>
9d009c68:	93a4001d 	lbu	a0,29(sp)

					NBNSHeader.Flags.Val = 0x8400;
9d009c6c:	24028400 	li	v0,-31744

					UDPPut(NBNSHeader.TransactionID.v[1]);
9d009c70:	0f40125d 	jal	9d004974 <UDPPut>
9d009c74:	a7a2001e 	sh	v0,30(sp)
					UDPPut(NBNSHeader.TransactionID.v[0]);
9d009c78:	93a4001c 	lbu	a0,28(sp)
 *
 * Overview:        Sends responses to NetBIOS name requests
 *
 * Note:            None
 ********************************************************************/
void NBNSTask(void)
9d009c7c:	2613002c 	addiu	s3,s0,44
					while(!UDPIsPutReady(MySocket));

					NBNSHeader.Flags.Val = 0x8400;

					UDPPut(NBNSHeader.TransactionID.v[1]);
					UDPPut(NBNSHeader.TransactionID.v[0]);
9d009c80:	0f40125d 	jal	9d004974 <UDPPut>
9d009c84:	02a0b821 	move	s7,s5
					UDPPut(NBNSHeader.Flags.v[1]);
9d009c88:	0f40125d 	jal	9d004974 <UDPPut>
9d009c8c:	93a4001f 	lbu	a0,31(sp)
					UDPPut(NBNSHeader.Flags.v[0]);
9d009c90:	0f40125d 	jal	9d004974 <UDPPut>
9d009c94:	93a4001e 	lbu	a0,30(sp)
					UDPPut(0x00);	// 0x0000 Questions
9d009c98:	0f40125d 	jal	9d004974 <UDPPut>
9d009c9c:	00002021 	move	a0,zero
					UDPPut(0x00);
9d009ca0:	0f40125d 	jal	9d004974 <UDPPut>
9d009ca4:	00002021 	move	a0,zero
					UDPPut(0x00);	// 0x0001 Answers
9d009ca8:	0f40125d 	jal	9d004974 <UDPPut>
9d009cac:	00002021 	move	a0,zero
					UDPPut(0x01);
9d009cb0:	0f40125d 	jal	9d004974 <UDPPut>
9d009cb4:	24040001 	li	a0,1
					UDPPut(0x00);	// 0x0000 Athoritative records
9d009cb8:	0f40125d 	jal	9d004974 <UDPPut>
9d009cbc:	00002021 	move	a0,zero
					UDPPut(0x00);
9d009cc0:	0f40125d 	jal	9d004974 <UDPPut>
9d009cc4:	00002021 	move	a0,zero
					UDPPut(0x00);	// 0x0000 Additional records
9d009cc8:	0f40125d 	jal	9d004974 <UDPPut>
9d009ccc:	00002021 	move	a0,zero
					UDPPut(0x00);
9d009cd0:	0f40125d 	jal	9d004974 <UDPPut>
9d009cd4:	00002021 	move	a0,zero
 ********************************************************************/
static void NBNSPutName(BYTE *String)
{
	BYTE i, j;

	UDPPut(32);	// NetBIOS names are always 32 bytes long (16 decoded bytes)
9d009cd8:	0f40125d 	jal	9d004974 <UDPPut>
9d009cdc:	24040020 	li	a0,32
	for(i = 0; i < 16u; i++)
	{
		j = *String++;
9d009ce0:	92fe0000 	lbu	s8,0(s7)
9d009ce4:	26f70001 	addiu	s7,s7,1
		UDPPut((j>>4) + 'A');
9d009ce8:	001e2102 	srl	a0,s8,0x4
9d009cec:	0f40125d 	jal	9d004974 <UDPPut>
9d009cf0:	24840041 	addiu	a0,a0,65
		UDPPut((j & 0x0F) + 'A');
9d009cf4:	33c4000f 	andi	a0,s8,0xf
9d009cf8:	0f40125d 	jal	9d004974 <UDPPut>
9d009cfc:	24840041 	addiu	a0,a0,65
static void NBNSPutName(BYTE *String)
{
	BYTE i, j;

	UDPPut(32);	// NetBIOS names are always 32 bytes long (16 decoded bytes)
	for(i = 0; i < 16u; i++)
9d009d00:	56f3fff8 	bnel	s7,s3,9d009ce4 <NBNSTask+0x274>
9d009d04:	92fe0000 	lbu	s8,0(s7)
		j = *String++;
		UDPPut((j>>4) + 'A');
		UDPPut((j & 0x0F) + 'A');
	}
	
	UDPPut(0x00);
9d009d08:	0f40125d 	jal	9d004974 <UDPPut>
9d009d0c:	00002021 	move	a0,zero
					UDPPut(0x00);
					UDPPut(0x00);	// 0x0000 Additional records
					UDPPut(0x00);

					NBNSPutName(AppConfig.NetBIOSName);
					UDPPut(0x00);	// 0x0020 Type: NetBIOS
9d009d10:	0f40125d 	jal	9d004974 <UDPPut>
9d009d14:	00002021 	move	a0,zero
					UDPPut(0x20);
9d009d18:	0f40125d 	jal	9d004974 <UDPPut>
9d009d1c:	24040020 	li	a0,32
					UDPPut(0x00);	// 0x0001 Class: Internet
9d009d20:	0f40125d 	jal	9d004974 <UDPPut>
9d009d24:	00002021 	move	a0,zero
					UDPPut(0x01);
9d009d28:	0f40125d 	jal	9d004974 <UDPPut>
9d009d2c:	24040001 	li	a0,1
					UDPPut(0x00);	// 0x00000000 Time To Live
9d009d30:	0f40125d 	jal	9d004974 <UDPPut>
9d009d34:	00002021 	move	a0,zero
					UDPPut(0x00);
9d009d38:	0f40125d 	jal	9d004974 <UDPPut>
9d009d3c:	00002021 	move	a0,zero
					UDPPut(0x00);
9d009d40:	0f40125d 	jal	9d004974 <UDPPut>
9d009d44:	00002021 	move	a0,zero
					UDPPut(0x00);
9d009d48:	0f40125d 	jal	9d004974 <UDPPut>
9d009d4c:	00002021 	move	a0,zero

					UDPPut(0x00);	// 0x0006 Data length
9d009d50:	0f40125d 	jal	9d004974 <UDPPut>
9d009d54:	00002021 	move	a0,zero
					UDPPut(0x06);	
9d009d58:	0f40125d 	jal	9d004974 <UDPPut>
9d009d5c:	24040006 	li	a0,6
					UDPPut(0x60);	// 0x6000 Flags: H-node, Unique
9d009d60:	0f40125d 	jal	9d004974 <UDPPut>
9d009d64:	24040060 	li	a0,96
					UDPPut(0x00);
9d009d68:	0f40125d 	jal	9d004974 <UDPPut>
9d009d6c:	00002021 	move	a0,zero
					UDPPut(AppConfig.MyIPAddr.v[0]);	// Put out IP address
9d009d70:	0f40125d 	jal	9d004974 <UDPPut>
9d009d74:	92449a5c 	lbu	a0,-26020(s2)
					UDPPut(AppConfig.MyIPAddr.v[1]);
9d009d78:	0f40125d 	jal	9d004974 <UDPPut>
9d009d7c:	92040001 	lbu	a0,1(s0)
					UDPPut(AppConfig.MyIPAddr.v[2]);
9d009d80:	0f40125d 	jal	9d004974 <UDPPut>
9d009d84:	92040002 	lbu	a0,2(s0)
					UDPPut(AppConfig.MyIPAddr.v[3]);
9d009d88:	0f40125d 	jal	9d004974 <UDPPut>
9d009d8c:	92040003 	lbu	a0,3(s0)

					// Change the destination address to the unicast address of the last received packet
		        	memcpy((void*)&UDPSocketInfo[MySocket].remoteNode, (const void*)&remoteNode, sizeof(remoteNode));
9d009d90:	93858108 	lbu	a1,-32504(gp)
9d009d94:	8a840003 	lwl	a0,3(s4)
9d009d98:	8a830007 	lwl	v1,7(s4)
9d009d9c:	00051040 	sll	v0,a1,0x1
9d009da0:	9a249a90 	lwr	a0,-25968(s1)
9d009da4:	00052900 	sll	a1,a1,0x4
9d009da8:	00a21023 	subu	v0,a1,v0
9d009dac:	02c21021 	addu	v0,s6,v0
9d009db0:	9a830004 	lwr	v1,4(s4)
9d009db4:	a8440003 	swl	a0,3(v0)
9d009db8:	92860008 	lbu	a2,8(s4)
9d009dbc:	92850009 	lbu	a1,9(s4)
9d009dc0:	b8440000 	swr	a0,0(v0)
9d009dc4:	a8430007 	swl	v1,7(v0)
9d009dc8:	b8430004 	swr	v1,4(v0)
9d009dcc:	a0460008 	sb	a2,8(v0)
					UDPFlush();				
9d009dd0:	0f40128c 	jal	9d004a30 <UDPFlush>
9d009dd4:	a0450009 	sb	a1,9(v0)
			UDPGet(&NBNSHeader.AuthoritativeRecords.v[0]);
			UDPGet(&NBNSHeader.AdditionalRecords.v[1]);
			UDPGet(&NBNSHeader.AdditionalRecords.v[0]);

			// Remove all questions
			while(NBNSHeader.Questions.Val--)
9d009dd8:	0b4026f5 	j	9d009bd4 <NBNSTask+0x164>
9d009ddc:	97a20020 	lhu	v0,32(sp)
					UDPFlush();				
				}

			}
			
			UDPDiscard();
9d009de0:	0f40132c 	jal	9d004cb0 <UDPDiscard>
9d009de4:	00000000 	nop

			break;
	}
}
9d009de8:	8fbf005c 	lw	ra,92(sp)
9d009dec:	8fbe0058 	lw	s8,88(sp)
9d009df0:	8fb70054 	lw	s7,84(sp)
9d009df4:	8fb60050 	lw	s6,80(sp)
9d009df8:	8fb5004c 	lw	s5,76(sp)
9d009dfc:	8fb40048 	lw	s4,72(sp)
9d009e00:	8fb30044 	lw	s3,68(sp)
9d009e04:	8fb20040 	lw	s2,64(sp)
9d009e08:	8fb1003c 	lw	s1,60(sp)
9d009e0c:	8fb00038 	lw	s0,56(sp)
9d009e10:	03e00008 	jr	ra
9d009e14:	27bd0060 	addiu	sp,sp,96
		case NBNS_HOME:
			smNBNS++;
			break;

		case NBNS_OPEN_SOCKET:
			MySocket = UDPOpen(NBNS_PORT, NULL, NBNS_PORT);
9d009e18:	24040089 	li	a0,137
9d009e1c:	00002821 	move	a1,zero
9d009e20:	0f4011e9 	jal	9d0047a4 <UDPOpen>
9d009e24:	24060089 	li	a2,137
9d009e28:	00402021 	move	a0,v0
9d009e2c:	a3828108 	sb	v0,-32504(gp)
			if(MySocket == INVALID_UDP_SOCKET)
9d009e30:	240200ff 	li	v0,255
9d009e34:	1082ff21 	beq	a0,v0,9d009abc <NBNSTask+0x4c>
9d009e38:	8f828104 	lw	v0,-32508(gp)
				break;

			smNBNS++;
9d009e3c:	24420001 	addiu	v0,v0,1
9d009e40:	0b4026c7 	j	9d009b1c <NBNSTask+0xac>
9d009e44:	af828104 	sw	v0,-32508(gp)
		if(i != 32u)
		{
			*String = 0;
			return;
		}
		while(i--)
9d009e48:	a3a20011 	sb	v0,17(sp)
			UDPGet(&NBNSHeader.AdditionalRecords.v[0]);

			// Remove all questions
			while(NBNSHeader.Questions.Val--)
			{
				NBNSGetName(NameString);
9d009e4c:	27b30028 	addiu	s3,sp,40
			*String = 0;
			return;
		}
		while(i--)
		{
			UDPGet(&j);
9d009e50:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009e54:	27a40012 	addiu	a0,sp,18
			j -= 'A';
9d009e58:	93b70012 	lbu	s7,18(sp)
			k = j<<4;
			i--;
9d009e5c:	93a20011 	lbu	v0,17(sp)
			UDPGet(&j);
9d009e60:	27a40012 	addiu	a0,sp,18
			return;
		}
		while(i--)
		{
			UDPGet(&j);
			j -= 'A';
9d009e64:	26f7ffbf 	addiu	s7,s7,-65
9d009e68:	32f700ff 	andi	s7,s7,0xff
			k = j<<4;
			i--;
9d009e6c:	2442ffff 	addiu	v0,v0,-1
			return;
		}
		while(i--)
		{
			UDPGet(&j);
			j -= 'A';
9d009e70:	a3b70012 	sb	s7,18(sp)
			k = j<<4;
			i--;
			UDPGet(&j);
9d009e74:	0f4012fa 	jal	9d004be8 <UDPGet>
9d009e78:	a3a20011 	sb	v0,17(sp)
			j -= 'A';
9d009e7c:	93a20012 	lbu	v0,18(sp)
		}
		while(i--)
		{
			UDPGet(&j);
			j -= 'A';
			k = j<<4;
9d009e80:	0017b900 	sll	s7,s7,0x4
			i--;
			UDPGet(&j);
			j -= 'A';
9d009e84:	2442ffbf 	addiu	v0,v0,-65
9d009e88:	304200ff 	andi	v0,v0,0xff
			*String++ = k | j;
9d009e8c:	0057b825 	or	s7,v0,s7
			UDPGet(&j);
			j -= 'A';
			k = j<<4;
			i--;
			UDPGet(&j);
			j -= 'A';
9d009e90:	a3a20012 	sb	v0,18(sp)
			*String++ = k | j;
9d009e94:	a2770000 	sb	s7,0(s3)
		if(i != 32u)
		{
			*String = 0;
			return;
		}
		while(i--)
9d009e98:	93a20011 	lbu	v0,17(sp)
			j -= 'A';
			k = j<<4;
			i--;
			UDPGet(&j);
			j -= 'A';
			*String++ = k | j;
9d009e9c:	26730001 	addiu	s3,s3,1
		if(i != 32u)
		{
			*String = 0;
			return;
		}
		while(i--)
9d009ea0:	2443ffff 	addiu	v1,v0,-1
9d009ea4:	1440ffea 	bnez	v0,9d009e50 <NBNSTask+0x3e0>
9d009ea8:	a3a30011 	sb	v1,17(sp)
9d009eac:	0b4026ff 	j	9d009bfc <NBNSTask+0x18c>
9d009eb0:	00000000 	nop

9d009eb4 <EthPhyRestartNegotiation>:
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009eb4:	8f85816c 	lw	a1,-32404(gp)
 *                  The EthPhyGetNegotiationResults() can be used to see the outcoming result.
 *
 * Note:            None
 *****************************************************************************/
eEthRes  __attribute__((weak)) EthPhyRestartNegotiation(void)
{
9d009eb8:	27bdffe8 	addiu	sp,sp,-24
9d009ebc:	afbf0014 	sw	ra,20(sp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009ec0:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d009ec4:	24040001 	li	a0,1
    return EthMIIMReadResult();
9d009ec8:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d009ecc:	00000000 	nop
	eEthRes	res;
	__BMSTATbits_t	phyCpbl;
	
	phyCpbl.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
 
	if(phyCpbl.AN_ABLE)
9d009ed0:	30430008 	andi	v1,v0,0x8
9d009ed4:	10600006 	beqz	v1,9d009ef0 <EthPhyRestartNegotiation+0x3c>
9d009ed8:	24020008 	li	v0,8
	{	// ok, we can perform auto negotiation
		EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, _BMCON_AN_ENABLE_MASK|_BMCON_AN_RESTART_MASK);	// restart negotiation and we'll have to wait
9d009edc:	8f85816c 	lw	a1,-32404(gp)
9d009ee0:	00002021 	move	a0,zero
9d009ee4:	0f4035f6 	jal	9d00d7d8 <EthMIIMWriteStart>
9d009ee8:	24061200 	li	a2,4608
		res=ETH_RES_OK;
9d009eec:	00001021 	move	v0,zero
	{
		res=ETH_RES_NEGOTIATION_UNABLE;		// no negotiation ability!
	}

	return res;
}
9d009ef0:	8fbf0014 	lw	ra,20(sp)
9d009ef4:	03e00008 	jr	ra
9d009ef8:	27bd0018 	addiu	sp,sp,24

9d009efc <EthPhyGetHwConfigFlags>:
 *****************************************************************************/
eEthPhyCfgFlags __attribute__((weak)) EthPhyGetHwConfigFlags(void)
{
    eEthPhyCfgFlags hwFlags;
    // the way the hw is configured
    hwFlags=(DEVCFG3bits.FMIIEN!=0)?ETH_PHY_CFG_MII:ETH_PHY_CFG_RMII;
9d009efc:	3c03bfc0 	lui	v1,0xbfc0
9d009f00:	8c652ff0 	lw	a1,12272(v1)
    hwFlags|=(DEVCFG3bits.FETHIO!=0)?ETH_PHY_CFG_DEFAULT:ETH_PHY_CFG_ALTERNATE;
9d009f04:	8c642ff0 	lw	a0,12272(v1)
 *****************************************************************************/
eEthPhyCfgFlags __attribute__((weak)) EthPhyGetHwConfigFlags(void)
{
    eEthPhyCfgFlags hwFlags;
    // the way the hw is configured
    hwFlags=(DEVCFG3bits.FMIIEN!=0)?ETH_PHY_CFG_MII:ETH_PHY_CFG_RMII;
9d009f08:	3c020100 	lui	v0,0x100
9d009f0c:	00a21824 	and	v1,a1,v0
    hwFlags|=(DEVCFG3bits.FETHIO!=0)?ETH_PHY_CFG_DEFAULT:ETH_PHY_CFG_ALTERNATE;
9d009f10:	3c020200 	lui	v0,0x200
9d009f14:	00821024 	and	v0,a0,v0
9d009f18:	24040002 	li	a0,2
 *****************************************************************************/
eEthPhyCfgFlags __attribute__((weak)) EthPhyGetHwConfigFlags(void)
{
    eEthPhyCfgFlags hwFlags;
    // the way the hw is configured
    hwFlags=(DEVCFG3bits.FMIIEN!=0)?ETH_PHY_CFG_MII:ETH_PHY_CFG_RMII;
9d009f1c:	2c630001 	sltiu	v1,v1,1
    hwFlags|=(DEVCFG3bits.FETHIO!=0)?ETH_PHY_CFG_DEFAULT:ETH_PHY_CFG_ALTERNATE;
9d009f20:	0002200b 	movn	a0,zero,v0

    return hwFlags;
}
9d009f24:	03e00008 	jr	ra
9d009f28:	00831025 	or	v0,a0,v1

9d009f2c <EthPhyNegotiationComplete>:
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009f2c:	8f85816c 	lw	a1,-32404(gp)
 *                  Subsequently, EthPhyGetNegotiationResult() can be called. 
 *
 * Note:            None
 *****************************************************************************/
eEthRes  __attribute__((weak)) EthPhyNegotiationComplete(int waitComplete)
{
9d009f30:	27bdffd0 	addiu	sp,sp,-48
9d009f34:	afb2001c 	sw	s2,28(sp)
9d009f38:	00809021 	move	s2,a0
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009f3c:	00002021 	move	a0,zero
 *                  Subsequently, EthPhyGetNegotiationResult() can be called. 
 *
 * Note:            None
 *****************************************************************************/
eEthRes  __attribute__((weak)) EthPhyNegotiationComplete(int waitComplete)
{
9d009f40:	afbf002c 	sw	ra,44(sp)
9d009f44:	afb50028 	sw	s5,40(sp)
9d009f48:	afb40024 	sw	s4,36(sp)
9d009f4c:	afb30020 	sw	s3,32(sp)
9d009f50:	afb10018 	sw	s1,24(sp)
9d009f54:	afb00014 	sw	s0,20(sp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009f58:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d009f5c:	0000a021 	move	s4,zero
    return EthMIIMReadResult();
9d009f60:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d009f64:	00000000 	nop
9d009f68:	7c547804 	ins	s4,v0,0x0,0x10
9d009f6c:	0040a821 	move	s5,v0
	__BMCONbits_t	phyBMCon;
	__BMSTATbits_t	phyStat;
	eEthRes	res;
	
	phyBMCon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
	if(phyBMCon.AN_ENABLE)
9d009f70:	32821000 	andi	v0,s4,0x1000
9d009f74:	14400014 	bnez	v0,9d009fc8 <EthPhyNegotiationComplete+0x9c>
9d009f78:	8f85816c 	lw	a1,-32404(gp)
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
    return EthMIIMReadResult();
9d009f7c:	7eb47804 	ins	s4,s5,0x0,0x10
				phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
			}
		}
	}

	if(!phyBMCon.AN_ENABLE)
9d009f80:	32831000 	andi	v1,s4,0x1000
9d009f84:	10600007 	beqz	v1,9d009fa4 <EthPhyNegotiationComplete+0x78>
9d009f88:	24020009 	li	v0,9
	{	
		res=ETH_RES_NEGOTIATION_INACTIVE;		// no negotiation is taking place!
	}
	else if(phyBMCon.AN_RESTART)
9d009f8c:	32940200 	andi	s4,s4,0x200
9d009f90:	16800004 	bnez	s4,9d009fa4 <EthPhyNegotiationComplete+0x78>
9d009f94:	2402000a 	li	v0,10
	{
		res=ETH_RES_NEGOTIATION_NOT_STARTED;		// not started yet/tmo
	}
	else
	{
		res= (phyStat.AN_COMPLETE==0)?ETH_RES_NEGOTIATION_ACTIVE:ETH_RES_OK;	// active/tmo/ok
9d009f98:	32100020 	andi	s0,s0,0x20
9d009f9c:	2402000b 	li	v0,11
9d009fa0:	0010100b 	movn	v0,zero,s0
	}

	return res;
}
9d009fa4:	8fbf002c 	lw	ra,44(sp)
9d009fa8:	8fb50028 	lw	s5,40(sp)
9d009fac:	8fb40024 	lw	s4,36(sp)
9d009fb0:	8fb30020 	lw	s3,32(sp)
9d009fb4:	8fb2001c 	lw	s2,28(sp)
9d009fb8:	8fb10018 	lw	s1,24(sp)
9d009fbc:	8fb00014 	lw	s0,20(sp)
9d009fc0:	03e00008 	jr	ra
9d009fc4:	27bd0030 	addiu	sp,sp,48
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009fc8:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d009fcc:	00002021 	move	a0,zero
    return EthMIIMReadResult();
9d009fd0:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d009fd4:	00000000 	nop
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009fd8:	8f85816c 	lw	a1,-32404(gp)
9d009fdc:	24040001 	li	a0,1
    return EthMIIMReadResult();
9d009fe0:	00409821 	move	s3,v0
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d009fe4:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d009fe8:	0040a821 	move	s5,v0
    return EthMIIMReadResult();
9d009fec:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d009ff0:	00000000 	nop
	if(phyBMCon.AN_ENABLE)
	{	// just protect from an accidental call
		phyBMCon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);

		if(waitComplete)
9d009ff4:	1240ffe1 	beqz	s2,9d009f7c <EthPhyNegotiationComplete+0x50>
9d009ff8:	00408021 	move	s0,v0
9d009ffc:	7e747804 	ins	s4,s3,0x0,0x10
		{
			unsigned int	tStart, tWait;
			
			if(phyBMCon.AN_RESTART)
9d00a000:	32820200 	andi	v0,s4,0x200
9d00a004:	1440001e 	bnez	v0,9d00a080 <EthPhyNegotiationComplete+0x154>
9d00a008:	00000000 	nop
				tWait=(GetSystemClock()/2000)*PHY_NEG_INIT_TMO;
				tStart=ReadCoreTimer();
				do
				{
					phyBMCon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
				}while(phyBMCon.AN_RESTART && (ReadCoreTimer()-tStart)<tWait);		// wait auto negotiation start
9d00a00c:	7eb47804 	ins	s4,s5,0x0,0x10
			}

			if(!phyBMCon.AN_RESTART)
9d00a010:	32820200 	andi	v0,s4,0x200
9d00a014:	5440ffda 	bnezl	v0,9d009f80 <EthPhyNegotiationComplete+0x54>
9d00a018:	7eb47804 	ins	s4,s5,0x0,0x10
			{	// ok, started
				tWait=(GetSystemClock()/2000)*PHY_NEG_DONE_TMO;
				tStart=ReadCoreTimer();
9d00a01c:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a020:	3c1004c4 	lui	s0,0x4c4
9d00a024:	00409021 	move	s2,v0
				do
				{
					phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
				}while(phyStat.AN_COMPLETE==0 && (ReadCoreTimer()-tStart)<tWait);	// wait auto negotiation done
9d00a028:	3610b400 	ori	s0,s0,0xb400
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a02c:	8f85816c 	lw	a1,-32404(gp)
9d00a030:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a034:	24040001 	li	a0,1
    return EthMIIMReadResult();
9d00a038:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a03c:	00000000 	nop
9d00a040:	7c517804 	ins	s1,v0,0x0,0x10
				tWait=(GetSystemClock()/2000)*PHY_NEG_DONE_TMO;
				tStart=ReadCoreTimer();
				do
				{
					phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
				}while(phyStat.AN_COMPLETE==0 && (ReadCoreTimer()-tStart)<tWait);	// wait auto negotiation done
9d00a044:	32220020 	andi	v0,s1,0x20
9d00a048:	14400007 	bnez	v0,9d00a068 <EthPhyNegotiationComplete+0x13c>
9d00a04c:	8f85816c 	lw	a1,-32404(gp)
9d00a050:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a054:	00000000 	nop
9d00a058:	00521023 	subu	v0,v0,s2
9d00a05c:	0050102b 	sltu	v0,v0,s0
9d00a060:	1440fff3 	bnez	v0,9d00a030 <EthPhyNegotiationComplete+0x104>
9d00a064:	8f85816c 	lw	a1,-32404(gp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a068:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a06c:	24040001 	li	a0,1
    return EthMIIMReadResult();
9d00a070:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a074:	7eb47804 	ins	s4,s5,0x0,0x10
9d00a078:	0b4027e0 	j	9d009f80 <EthPhyNegotiationComplete+0x54>
9d00a07c:	00408021 	move	s0,v0
			unsigned int	tStart, tWait;
			
			if(phyBMCon.AN_RESTART)
			{	// not started yet
				tWait=(GetSystemClock()/2000)*PHY_NEG_INIT_TMO;
				tStart=ReadCoreTimer();
9d00a080:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a084:	34139c40 	li	s3,0x9c40
9d00a088:	00409021 	move	s2,v0
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a08c:	8f85816c 	lw	a1,-32404(gp)
9d00a090:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a094:	00002021 	move	a0,zero
    return EthMIIMReadResult();
9d00a098:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a09c:	00000000 	nop
9d00a0a0:	7c547804 	ins	s4,v0,0x0,0x10
9d00a0a4:	0040a821 	move	s5,v0
				tWait=(GetSystemClock()/2000)*PHY_NEG_INIT_TMO;
				tStart=ReadCoreTimer();
				do
				{
					phyBMCon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
				}while(phyBMCon.AN_RESTART && (ReadCoreTimer()-tStart)<tWait);		// wait auto negotiation start
9d00a0a8:	32820200 	andi	v0,s4,0x200
9d00a0ac:	5040ffd8 	beqzl	v0,9d00a010 <EthPhyNegotiationComplete+0xe4>
9d00a0b0:	7eb47804 	ins	s4,s5,0x0,0x10
9d00a0b4:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a0b8:	00000000 	nop
9d00a0bc:	00521023 	subu	v0,v0,s2
9d00a0c0:	0053102b 	sltu	v0,v0,s3
9d00a0c4:	1440fff2 	bnez	v0,9d00a090 <EthPhyNegotiationComplete+0x164>
9d00a0c8:	8f85816c 	lw	a1,-32404(gp)
9d00a0cc:	0b402804 	j	9d00a010 <EthPhyNegotiationComplete+0xe4>
9d00a0d0:	7eb47804 	ins	s4,s5,0x0,0x10

9d00a0d4 <EthPhyGetNegotiationResult>:
 *                  The result is based on the PHY status!.
 *
 * Note:            If no negotiation possible/active/failed, most likely the flags are invalid!
 *****************************************************************************/
eEthLinkStat  __attribute__((weak)) EthPhyGetNegotiationResult(eEthOpenFlags* pFlags, eEthMacPauseType* pPauseType)
{
9d00a0d4:	27bdffd0 	addiu	sp,sp,-48
9d00a0d8:	afb10018 	sw	s1,24(sp)
9d00a0dc:	00a08821 	move	s1,a1
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a0e0:	8f85816c 	lw	a1,-32404(gp)
 *                  The result is based on the PHY status!.
 *
 * Note:            If no negotiation possible/active/failed, most likely the flags are invalid!
 *****************************************************************************/
eEthLinkStat  __attribute__((weak)) EthPhyGetNegotiationResult(eEthOpenFlags* pFlags, eEthMacPauseType* pPauseType)
{
9d00a0e4:	afb2001c 	sw	s2,28(sp)
9d00a0e8:	00809021 	move	s2,a0
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a0ec:	24040001 	li	a0,1
 *                  The result is based on the PHY status!.
 *
 * Note:            If no negotiation possible/active/failed, most likely the flags are invalid!
 *****************************************************************************/
eEthLinkStat  __attribute__((weak)) EthPhyGetNegotiationResult(eEthOpenFlags* pFlags, eEthMacPauseType* pPauseType)
{
9d00a0f0:	afbf002c 	sw	ra,44(sp)
9d00a0f4:	afb50028 	sw	s5,40(sp)
9d00a0f8:	afb40024 	sw	s4,36(sp)
9d00a0fc:	afb30020 	sw	s3,32(sp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a100:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a104:	afb00014 	sw	s0,20(sp)
    return EthMIIMReadResult();
9d00a108:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a10c:	00000000 	nop
9d00a110:	00001821 	move	v1,zero
9d00a114:	7c437804 	ins	v1,v0,0x0,0x10

	oFlags=0;	// don't know the result yet
	pauseType=ETH_MAC_PAUSE_TYPE_NONE;

	phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	if(phyStat.AN_COMPLETE==0)
9d00a118:	30620020 	andi	v0,v1,0x20
9d00a11c:	10400013 	beqz	v0,9d00a16c <EthPhyGetNegotiationResult+0x98>
9d00a120:	00001021 	move	v0,zero
	{
		linkStat=(ETH_LINK_ST_DOWN|ETH_LINK_ST_NEG_TMO);
	}
	else if(!phyStat.LINK_STAT)
9d00a124:	30630004 	andi	v1,v1,0x4
9d00a128:	14600013 	bnez	v1,9d00a178 <EthPhyGetNegotiationResult+0xa4>
9d00a12c:	00001821 	move	v1,zero
	{
		linkStat=ETH_LINK_ST_DOWN;
9d00a130:	00009821 	move	s3,zero
				pauseType|=ETH_MAC_PAUSE_TYPE_EN_RX;
			}
		}
	}
	
	if(pFlags)
9d00a134:	56400001 	bnezl	s2,9d00a13c <EthPhyGetNegotiationResult+0x68>
9d00a138:	ae430000 	sw	v1,0(s2)
	{
		*pFlags=oFlags;
	}

	if(pPauseType)
9d00a13c:	56200001 	bnezl	s1,9d00a144 <EthPhyGetNegotiationResult+0x70>
9d00a140:	ae220000 	sw	v0,0(s1)
	{
		*pPauseType=pauseType;
	}
	return linkStat;
}
9d00a144:	8fbf002c 	lw	ra,44(sp)
9d00a148:	02601021 	move	v0,s3
9d00a14c:	8fb50028 	lw	s5,40(sp)
9d00a150:	8fb40024 	lw	s4,36(sp)
9d00a154:	8fb30020 	lw	s3,32(sp)
9d00a158:	8fb2001c 	lw	s2,28(sp)
9d00a15c:	8fb10018 	lw	s1,24(sp)
9d00a160:	8fb00014 	lw	s0,20(sp)
9d00a164:	03e00008 	jr	ra
9d00a168:	27bd0030 	addiu	sp,sp,48
	
	//	should have BMCON.AN_ENABLE==1
	//	wait for it to finish! 


	oFlags=0;	// don't know the result yet
9d00a16c:	00001821 	move	v1,zero
	pauseType=ETH_MAC_PAUSE_TYPE_NONE;

	phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	if(phyStat.AN_COMPLETE==0)
	{
		linkStat=(ETH_LINK_ST_DOWN|ETH_LINK_ST_NEG_TMO);
9d00a170:	0b40284d 	j	9d00a134 <EthPhyGetNegotiationResult+0x60>
9d00a174:	24131000 	li	s3,4096
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a178:	8f85816c 	lw	a1,-32404(gp)
9d00a17c:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a180:	24040006 	li	a0,6
    return EthMIIMReadResult();
9d00a184:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a188:	00000000 	nop
9d00a18c:	00001821 	move	v1,zero
9d00a190:	7c437804 	ins	v1,v0,0x0,0x10
		lcl_AsmDir=(ETH_MAC_PAUSE_CPBL_MASK & ETH_MAC_PAUSE_TYPE_ASM_DIR)?1:0;
		lp_Pause=lp_AsmDir=0;			// in case negotiation fails
		lpAD.w=_ANAD_BASE10T_MASK;		// lowest priority resolution
				
		phyExp.w=_PhyReadReg(PHY_REG_ANEXP, _PhyAdd);
		if(phyExp.LP_AN_ABLE)
9d00a194:	30620001 	andi	v0,v1,0x1
9d00a198:	14400027 	bnez	v0,9d00a238 <EthPhyGetNegotiationResult+0x164>
9d00a19c:	30630010 	andi	v1,v1,0x10
		linkStat=ETH_LINK_ST_UP;

		lcl_Pause=(ETH_MAC_PAUSE_CPBL_MASK & ETH_MAC_PAUSE_TYPE_PAUSE)?1:0;
		lcl_AsmDir=(ETH_MAC_PAUSE_CPBL_MASK & ETH_MAC_PAUSE_TYPE_ASM_DIR)?1:0;
		lp_Pause=lp_AsmDir=0;			// in case negotiation fails
		lpAD.w=_ANAD_BASE10T_MASK;		// lowest priority resolution
9d00a1a0:	2413000b 	li	s3,11
9d00a1a4:	24020003 	li	v0,3
9d00a1a8:	24140020 	li	s4,32
9d00a1ac:	00008021 	move	s0,zero
9d00a1b0:	0000a821 	move	s5,zero
9d00a1b4:	0043980a 	movz	s3,v0,v1
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a1b8:	8f85816c 	lw	a1,-32404(gp)
9d00a1bc:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a1c0:	24040004 	li	a0,4
    return EthMIIMReadResult();
9d00a1c4:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a1c8:	00000000 	nop
		}
	
		// set the PHY connection params
		
		anadReg.w=_PhyReadReg(PHY_REG_ANAD, _PhyAdd);		// get our advertised capabilities
		anadReg.w&=lpAD.w;				// get the matching ones
9d00a1cc:	0054a024 	and	s4,v0,s4
		// get the settings, according to IEEE 802.3 Annex 28B.3 Priority Resolution
		// Note: we don't support 100BaseT4 !
		
		if(anadReg.w&_ANAD_BASE100TX_FDX_MASK)
9d00a1d0:	3294ffff 	andi	s4,s4,0xffff
9d00a1d4:	32820100 	andi	v0,s4,0x100
9d00a1d8:	14400010 	bnez	v0,9d00a21c <EthPhyGetNegotiationResult+0x148>
9d00a1dc:	2403000a 	li	v1,10
		{
			oFlags=(ETH_OPEN_100|ETH_OPEN_FDUPLEX);
		}
		else if(anadReg.w&_ANAD_BASE100TX_MASK)
9d00a1e0:	32820080 	andi	v0,s4,0x80
9d00a1e4:	1440000b 	bnez	v0,9d00a214 <EthPhyGetNegotiationResult+0x140>
9d00a1e8:	2403000c 	li	v1,12
		{
			oFlags=(ETH_OPEN_100|ETH_OPEN_HDUPLEX);
		}
		else if(anadReg.w&_ANAD_BASE10T_FDX_MASK)
9d00a1ec:	32820040 	andi	v0,s4,0x40
9d00a1f0:	1440000a 	bnez	v0,9d00a21c <EthPhyGetNegotiationResult+0x148>
9d00a1f4:	24030012 	li	v1,18
		{
			oFlags=(ETH_OPEN_10|ETH_OPEN_FDUPLEX);
		}
		else if(anadReg.w&_ANAD_BASE10T_MASK)
9d00a1f8:	32940020 	andi	s4,s4,0x20
9d00a1fc:	16800005 	bnez	s4,9d00a214 <EthPhyGetNegotiationResult+0x140>
9d00a200:	24030014 	li	v1,20
		{
			oFlags=(ETH_OPEN_10|ETH_OPEN_HDUPLEX);
		}
		else
		{	// this should NOT happen!
			linkStat|=ETH_LINK_ST_NEG_FATAL_ERR;
9d00a204:	36732000 	ori	s3,s3,0x2000
			linkStat&=~ETH_LINK_ST_UP;		// make sure we stop...!
9d00a208:	2402fffe 	li	v0,-2
9d00a20c:	02629824 	and	s3,s3,v0
	
	//	should have BMCON.AN_ENABLE==1
	//	wait for it to finish! 


	oFlags=0;	// don't know the result yet
9d00a210:	00001821 	move	v1,zero
	pauseType=ETH_MAC_PAUSE_TYPE_NONE;
9d00a214:	0b40284d 	j	9d00a134 <EthPhyGetNegotiationResult+0x60>
9d00a218:	00001021 	move	v0,zero

		// set the pause type for the MAC
		// according to IEEE Std 802.3-2002 Tables 28B-2, 28B-3 
		if(oFlags&ETH_OPEN_FDUPLEX)
		{	// pause type relevant for full duplex only
			if(lp_Pause & (lcl_Pause|(lcl_AsmDir&lp_AsmDir)))
9d00a21c:	32a40001 	andi	a0,s5,0x1
			{
				pauseType=ETH_MAC_PAUSE_TYPE_EN_TX;
9d00a220:	24020004 	li	v0,4
9d00a224:	0004100a 	movz	v0,zero,a0
			}
			if(lcl_Pause & (lp_Pause | (lcl_AsmDir&lp_AsmDir)))
9d00a228:	02158025 	or	s0,s0,s5
			{
				pauseType|=ETH_MAC_PAUSE_TYPE_EN_RX;
9d00a22c:	34440008 	ori	a0,v0,0x8
9d00a230:	0b40284d 	j	9d00a134 <EthPhyGetNegotiationResult+0x60>
9d00a234:	0090100b 	movn	v0,a0,s0
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a238:	8f85816c 	lw	a1,-32404(gp)
9d00a23c:	24040005 	li	a0,5
9d00a240:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a244:	24130005 	li	s3,5
    return EthMIIMReadResult();
9d00a248:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a24c:	0000a821 	move	s5,zero
9d00a250:	0040a021 	move	s4,v0
9d00a254:	00001021 	move	v0,zero
9d00a258:	7e827804 	ins	v0,s4,0x0,0x10
		phyExp.w=_PhyReadReg(PHY_REG_ANEXP, _PhyAdd);
		if(phyExp.LP_AN_ABLE)
		{	// ok,valid auto negotiation info

			lpAD.w=_PhyReadReg(PHY_REG_ANLPAD, _PhyAdd);
			if(lpAD.REM_FAULT)
9d00a25c:	30452000 	andi	a1,v0,0x2000
			{
				linkStat|=ETH_LINK_ST_REMOTE_FAULT;
9d00a260:	24040001 	li	a0,1
			}
			
			if(lpAD.PAUSE)
9d00a264:	30430400 	andi	v1,v0,0x400
9d00a268:	10600003 	beqz	v1,9d00a278 <EthPhyGetNegotiationResult+0x1a4>
9d00a26c:	0085980a 	movz	s3,a0,a1
			{
				linkStat|=ETH_LINK_ST_LP_PAUSE;
9d00a270:	36730010 	ori	s3,s3,0x10
				lp_Pause=1;
9d00a274:	24150001 	li	s5,1
			}
			if(lpAD.ASM_DIR)
9d00a278:	30420800 	andi	v0,v0,0x800
9d00a27c:	1040ffce 	beqz	v0,9d00a1b8 <EthPhyGetNegotiationResult+0xe4>
9d00a280:	00008021 	move	s0,zero
			{
				linkStat|=ETH_LINK_ST_LP_ASM_DIR;
9d00a284:	36730020 	ori	s3,s3,0x20
				lp_AsmDir=1;
9d00a288:	0b40286e 	j	9d00a1b8 <EthPhyGetNegotiationResult+0xe4>
9d00a28c:	24100001 	li	s0,1

9d00a290 <EthPhyGetLinkStatus>:
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a290:	8f85816c 	lw	a1,-32404(gp)
 *                  will be performed to return the current link status.
 *
 * Note:            None
 *****************************************************************************/
eEthLinkStat  __attribute__((weak)) EthPhyGetLinkStatus(int refresh)
{
9d00a294:	27bdffe8 	addiu	sp,sp,-24
9d00a298:	afb00010 	sw	s0,16(sp)
9d00a29c:	00808021 	move	s0,a0
9d00a2a0:	afbf0014 	sw	ra,20(sp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a2a4:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a2a8:	24040001 	li	a0,1
    return EthMIIMReadResult();
9d00a2ac:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a2b0:	00000000 	nop
{
	__BMSTATbits_t	phyStat;
	
	// read the link status
	phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	if(phyStat.LINK_STAT==0 && refresh)
9d00a2b4:	30430004 	andi	v1,v0,0x4
9d00a2b8:	14600003 	bnez	v1,9d00a2c8 <EthPhyGetLinkStatus+0x38>
9d00a2bc:	00001821 	move	v1,zero
9d00a2c0:	1600000a 	bnez	s0,9d00a2ec <EthPhyGetLinkStatus+0x5c>
9d00a2c4:	8f85816c 	lw	a1,-32404(gp)
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
    return EthMIIMReadResult();
9d00a2c8:	7c437804 	ins	v1,v0,0x0,0x10
	{	// link down could be an old condition. re-read
		phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	}

	return _Phy2LinkStat(phyStat);
}
9d00a2cc:	8fbf0014 	lw	ra,20(sp)
// 

static __inline__ eEthLinkStat __attribute__((always_inline)) _Phy2LinkStat(__BMSTATbits_t phyStat)
{
	eEthLinkStat	linkStat;
	linkStat=(phyStat.LINK_STAT)?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;
9d00a2d0:	7c640080 	ext	a0,v1,0x2,0x1
	if(phyStat.REM_FAULT)
	{
		linkStat|=ETH_LINK_ST_REMOTE_FAULT;
9d00a2d4:	34820004 	ori	v0,a0,0x4

static __inline__ eEthLinkStat __attribute__((always_inline)) _Phy2LinkStat(__BMSTATbits_t phyStat)
{
	eEthLinkStat	linkStat;
	linkStat=(phyStat.LINK_STAT)?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;
	if(phyStat.REM_FAULT)
9d00a2d8:	30630010 	andi	v1,v1,0x10
	{	// link down could be an old condition. re-read
		phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	}

	return _Phy2LinkStat(phyStat);
}
9d00a2dc:	0083100a 	movz	v0,a0,v1
9d00a2e0:	8fb00010 	lw	s0,16(sp)
9d00a2e4:	03e00008 	jr	ra
9d00a2e8:	27bd0018 	addiu	sp,sp,24
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a2ec:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a2f0:	24040001 	li	a0,1
    return EthMIIMReadResult();
9d00a2f4:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a2f8:	00000000 	nop
9d00a2fc:	00001821 	move	v1,zero
9d00a300:	7c437804 	ins	v1,v0,0x0,0x10
	{	// link down could be an old condition. re-read
		phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	}

	return _Phy2LinkStat(phyStat);
}
9d00a304:	8fbf0014 	lw	ra,20(sp)
// 

static __inline__ eEthLinkStat __attribute__((always_inline)) _Phy2LinkStat(__BMSTATbits_t phyStat)
{
	eEthLinkStat	linkStat;
	linkStat=(phyStat.LINK_STAT)?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;
9d00a308:	7c640080 	ext	a0,v1,0x2,0x1
	if(phyStat.REM_FAULT)
	{
		linkStat|=ETH_LINK_ST_REMOTE_FAULT;
9d00a30c:	34820004 	ori	v0,a0,0x4

static __inline__ eEthLinkStat __attribute__((always_inline)) _Phy2LinkStat(__BMSTATbits_t phyStat)
{
	eEthLinkStat	linkStat;
	linkStat=(phyStat.LINK_STAT)?ETH_LINK_ST_UP:ETH_LINK_ST_DOWN;
	if(phyStat.REM_FAULT)
9d00a310:	30630010 	andi	v1,v1,0x10
	{	// link down could be an old condition. re-read
		phyStat.w=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	}

	return _Phy2LinkStat(phyStat);
}
9d00a314:	0083100a 	movz	v0,a0,v1
9d00a318:	8fb00010 	lw	s0,16(sp)
9d00a31c:	03e00008 	jr	ra
9d00a320:	27bd0018 	addiu	sp,sp,24

9d00a324 <EthPhyReset>:
 * Note:            None
 *****************************************************************************/
int  __attribute__((weak)) EthPhyReset(int waitComplete)
{

	EthMIIMWriteStart(PHY_REG_BMCON, _BMCON_RESET_MASK, _PhyAdd);		// Soft Reset the PHY
9d00a324:	9786816c 	lhu	a2,-32404(gp)
 *                  It does not wait for the reset procedure to complete
 *
 * Note:            None
 *****************************************************************************/
int  __attribute__((weak)) EthPhyReset(int waitComplete)
{
9d00a328:	27bdffe0 	addiu	sp,sp,-32
9d00a32c:	afb00010 	sw	s0,16(sp)

	EthMIIMWriteStart(PHY_REG_BMCON, _BMCON_RESET_MASK, _PhyAdd);		// Soft Reset the PHY
9d00a330:	34058000 	li	a1,0x8000
 *                  It does not wait for the reset procedure to complete
 *
 * Note:            None
 *****************************************************************************/
int  __attribute__((weak)) EthPhyReset(int waitComplete)
{
9d00a334:	00808021 	move	s0,a0

	EthMIIMWriteStart(PHY_REG_BMCON, _BMCON_RESET_MASK, _PhyAdd);		// Soft Reset the PHY
9d00a338:	00002021 	move	a0,zero
 *                  It does not wait for the reset procedure to complete
 *
 * Note:            None
 *****************************************************************************/
int  __attribute__((weak)) EthPhyReset(int waitComplete)
{
9d00a33c:	afbf001c 	sw	ra,28(sp)
9d00a340:	afb20018 	sw	s2,24(sp)

	EthMIIMWriteStart(PHY_REG_BMCON, _BMCON_RESET_MASK, _PhyAdd);		// Soft Reset the PHY
9d00a344:	0f4035f6 	jal	9d00d7d8 <EthMIIMWriteStart>
9d00a348:	afb10014 	sw	s1,20(sp)
	
	if(waitComplete)
9d00a34c:	16000007 	bnez	s0,9d00a36c <EthPhyReset+0x48>
9d00a350:	24020001 	li	v0,1
		}
	}

	return 1;

}
9d00a354:	8fbf001c 	lw	ra,28(sp)
9d00a358:	8fb20018 	lw	s2,24(sp)
9d00a35c:	8fb10014 	lw	s1,20(sp)
9d00a360:	8fb00010 	lw	s0,16(sp)
9d00a364:	03e00008 	jr	ra
9d00a368:	27bd0020 	addiu	sp,sp,32
	{	// wait reset self clear
		__BMCONbits_t bmcon;
		unsigned int	tStart, tWaitReset;

		tWaitReset=(GetSystemClock()/2000)*PHY_RESET_CLR_TMO;
		tStart=ReadCoreTimer();
9d00a36c:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a370:	3c100131 	lui	s0,0x131
9d00a374:	00408821 	move	s1,v0
		do
		{
			bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		}while(bmcon.RESET && (ReadCoreTimer()-tStart)<tWaitReset);
9d00a378:	0b4028e6 	j	9d00a398 <EthPhyReset+0x74>
9d00a37c:	26102d00 	addiu	s0,s0,11520
9d00a380:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a384:	00000000 	nop
9d00a388:	00511023 	subu	v0,v0,s1
9d00a38c:	0050102b 	sltu	v0,v0,s0
9d00a390:	1040000a 	beqz	v0,9d00a3bc <EthPhyReset+0x98>
9d00a394:	8f85816c 	lw	a1,-32404(gp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a398:	8f85816c 	lw	a1,-32404(gp)
9d00a39c:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a3a0:	00002021 	move	a0,zero
    return EthMIIMReadResult();
9d00a3a4:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a3a8:	00000000 	nop
9d00a3ac:	7c527804 	ins	s2,v0,0x0,0x10
		tWaitReset=(GetSystemClock()/2000)*PHY_RESET_CLR_TMO;
		tStart=ReadCoreTimer();
		do
		{
			bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		}while(bmcon.RESET && (ReadCoreTimer()-tStart)<tWaitReset);
9d00a3b0:	32428000 	andi	v0,s2,0x8000
9d00a3b4:	1440fff2 	bnez	v0,9d00a380 <EthPhyReset+0x5c>
9d00a3b8:	8f85816c 	lw	a1,-32404(gp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a3bc:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a3c0:	00002021 	move	a0,zero
    return EthMIIMReadResult();
9d00a3c4:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a3c8:	00000000 	nop
		}
	}

	return 1;

}
9d00a3cc:	8fbf001c 	lw	ra,28(sp)
		{
			bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		}while(bmcon.RESET && (ReadCoreTimer()-tStart)<tWaitReset);

		bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		if(bmcon.RESET)
9d00a3d0:	30428000 	andi	v0,v0,0x8000
 * Overview:        This function immediately resets the PHY.
 *                  It does not wait for the reset procedure to complete
 *
 * Note:            None
 *****************************************************************************/
int  __attribute__((weak)) EthPhyReset(int waitComplete)
9d00a3d4:	2c420001 	sltiu	v0,v0,1
		}
	}

	return 1;

}
9d00a3d8:	8fb20018 	lw	s2,24(sp)
9d00a3dc:	8fb10014 	lw	s1,20(sp)
9d00a3e0:	8fb00010 	lw	s0,16(sp)
9d00a3e4:	03e00008 	jr	ra
9d00a3e8:	27bd0020 	addiu	sp,sp,32

9d00a3ec <EthPhyInit>:
 *                  Then it programs the PHY accordingly.
 *
 * Note:            None
 *****************************************************************************/
eEthRes __attribute__((weak)) EthPhyInit(eEthOpenFlags oFlags, eEthPhyCfgFlags cFlags, eEthOpenFlags* pResFlags)
{
9d00a3ec:	27bdffd0 	addiu	sp,sp,-48
9d00a3f0:	afb10014 	sw	s1,20(sp)
9d00a3f4:	00a08821 	move	s1,a1
9d00a3f8:	afb50024 	sw	s5,36(sp)
9d00a3fc:	afb00010 	sw	s0,16(sp)
9d00a400:	afbf002c 	sw	ra,44(sp)
9d00a404:	afb60028 	sw	s6,40(sp)
9d00a408:	afb40020 	sw	s4,32(sp)
9d00a40c:	afb3001c 	sw	s3,28(sp)
9d00a410:	afb20018 	sw	s2,24(sp)
9d00a414:	00808021 	move	s0,a0
	eEthPhyCfgFlags	hwFlags, swFlags;
	unsigned short	phyCpbl, openReqs, matchCpbl;
	eEthRes	res;

	// the way the hw is configured
    hwFlags=EthPhyGetHwConfigFlags();
9d00a418:	0f4027bf 	jal	9d009efc <EthPhyGetHwConfigFlags>
9d00a41c:	00c0a821 	move	s5,a2

	if(cFlags&ETH_PHY_CFG_AUTO)
9d00a420:	32230010 	andi	v1,s1,0x10
9d00a424:	1460000e 	bnez	v1,9d00a460 <EthPhyInit+0x74>
9d00a428:	32230003 	andi	v1,s1,0x3
	}
	else
	{	// some minimal check against the way the hw is configured
		swFlags=cFlags&(ETH_PHY_CFG_RMII|ETH_PHY_CFG_ALTERNATE);	
	
		if((swFlags ^ hwFlags)!=0)
9d00a42c:	1062000d 	beq	v1,v0,9d00a464 <EthPhyInit+0x78>
9d00a430:	2413000f 	li	s3,15

	*pResFlags=oFlags;		// upper layer needs to know the PHY set-up to further set-up the MAC.

	return ETH_RES_OK;	

}
9d00a434:	8fbf002c 	lw	ra,44(sp)
9d00a438:	02601021 	move	v0,s3
9d00a43c:	8fb60028 	lw	s6,40(sp)
9d00a440:	8fb50024 	lw	s5,36(sp)
9d00a444:	8fb40020 	lw	s4,32(sp)
9d00a448:	8fb3001c 	lw	s3,28(sp)
9d00a44c:	8fb20018 	lw	s2,24(sp)
9d00a450:	8fb10014 	lw	s1,20(sp)
9d00a454:	8fb00010 	lw	s0,16(sp)
9d00a458:	03e00008 	jr	ra
9d00a45c:	27bd0030 	addiu	sp,sp,48
	eEthPhyCfgFlags	hwFlags, swFlags;
	unsigned short	phyCpbl, openReqs, matchCpbl;
	eEthRes	res;

	// the way the hw is configured
    hwFlags=EthPhyGetHwConfigFlags();
9d00a460:	00408821 	move	s1,v0
			return ETH_RES_CFG_ERR;
		}
	}

	
	_PhyAdd=EthPhyMIIMAddress();		// get the PHY address
9d00a464:	0f402a68 	jal	9d00a9a0 <EthPhyMIIMAddress>
9d00a468:	00000000 	nop


	if(oFlags&(ETH_OPEN_PHY_LOOPBACK|ETH_OPEN_MAC_LOOPBACK))
9d00a46c:	320300c0 	andi	v1,s0,0xc0
9d00a470:	10600003 	beqz	v1,9d00a480 <EthPhyInit+0x94>
9d00a474:	af82816c 	sw	v0,-32404(gp)
	{
		oFlags&=~ETH_OPEN_AUTO;	// no negotiation in loopback mode!
9d00a478:	2402fffe 	li	v0,-2
9d00a47c:	02028024 	and	s0,s0,v0
	}
	
	if(!(oFlags&ETH_OPEN_AUTO))
9d00a480:	32020001 	andi	v0,s0,0x1
9d00a484:	14400004 	bnez	v0,9d00a498 <EthPhyInit+0xac>
9d00a488:	3c02bfc0 	lui	v0,0xbfc0
	{
		oFlags&=~ETH_OPEN_MDIX_AUTO;		// Auto-MDIX has to be in auto negotiation only
9d00a48c:	2402feff 	li	v0,-257
9d00a490:	02028024 	and	s0,s0,v0
 *****************************************************************************/
static void _PhyInitIo(void)
{
	__DEVCFG3bits_t bcfg3;

	bcfg3=DEVCFG3bits;
9d00a494:	3c02bfc0 	lui	v0,0xbfc0
9d00a498:	8c532ff0 	lw	s3,12272(v0)
	if(!(oFlags&ETH_OPEN_AUTO))
	{
		oFlags&=~ETH_OPEN_MDIX_AUTO;		// Auto-MDIX has to be in auto negotiation only
	}
	
    oFlags|=(cFlags&ETH_PHY_CFG_RMII)?ETH_OPEN_RMII:ETH_OPEN_MII;
9d00a49c:	32230001 	andi	v1,s1,0x1
9d00a4a0:	24120400 	li	s2,1024
static void _PhyInitIo(void)
{
	__DEVCFG3bits_t bcfg3;

	bcfg3=DEVCFG3bits;
	if(bcfg3.FETHIO)
9d00a4a4:	7e620640 	ext	v0,s3,0x19,0x1
9d00a4a8:	104000b7 	beqz	v0,9d00a788 <EthPhyInit+0x39c>
9d00a4ac:	0003900a 	movz	s2,zero,v1
	{	// default setting, both RMII and MII 
		PORTSetPinsDigitalOut(_ETH_MDC_PORT, _ETH_MDC_BIT);	
9d00a4b0:	24040003 	li	a0,3
9d00a4b4:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a4b8:	24050800 	li	a1,2048
		PORTSetPinsDigitalIn(_ETH_MDIO_PORT, _ETH_MDIO_BIT);
9d00a4bc:	24040003 	li	a0,3
9d00a4c0:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a4c4:	24050100 	li	a1,256

		PORTSetPinsDigitalOut(_ETH_TXEN_PORT, _ETH_TXEN_BIT);	
9d00a4c8:	24040003 	li	a0,3
9d00a4cc:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a4d0:	24050040 	li	a1,64
		PORTSetPinsDigitalOut(_ETH_TXD0_PORT, _ETH_TXD0_BIT);	
9d00a4d4:	24040005 	li	a0,5
9d00a4d8:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a4dc:	24050002 	li	a1,2
		PORTSetPinsDigitalOut(_ETH_TXD1_PORT, _ETH_TXD1_BIT);	
9d00a4e0:	24040005 	li	a0,5
9d00a4e4:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a4e8:	24050001 	li	a1,1

		
		PORTSetPinsDigitalIn(_ETH_RXCLK_PORT, _ETH_RXCLK_BIT);
9d00a4ec:	24040006 	li	a0,6
9d00a4f0:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a4f4:	24050200 	li	a1,512
		PORTSetPinsDigitalIn(_ETH_RXDV_PORT, _ETH_RXDV_BIT);
9d00a4f8:	24040006 	li	a0,6
9d00a4fc:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a500:	24050100 	li	a1,256
		PORTSetPinsDigitalIn(_ETH_RXD0_PORT, _ETH_RXD0_BIT);
9d00a504:	24040001 	li	a0,1
9d00a508:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a50c:	24051000 	li	a1,4096
		PORTSetPinsDigitalIn(_ETH_RXD1_PORT, _ETH_RXD1_BIT);
9d00a510:	24040001 	li	a0,1
9d00a514:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a518:	24052000 	li	a1,8192
		PORTSetPinsDigitalIn(_ETH_RXERR_PORT, _ETH_RXERR_BIT);


		if(bcfg3.FMIIEN)
9d00a51c:	7e730600 	ext	s3,s3,0x18,0x1
		
		PORTSetPinsDigitalIn(_ETH_RXCLK_PORT, _ETH_RXCLK_BIT);
		PORTSetPinsDigitalIn(_ETH_RXDV_PORT, _ETH_RXDV_BIT);
		PORTSetPinsDigitalIn(_ETH_RXD0_PORT, _ETH_RXD0_BIT);
		PORTSetPinsDigitalIn(_ETH_RXD1_PORT, _ETH_RXD1_BIT);
		PORTSetPinsDigitalIn(_ETH_RXERR_PORT, _ETH_RXERR_BIT);
9d00a520:	24040001 	li	a0,1
9d00a524:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a528:	24050800 	li	a1,2048


		if(bcfg3.FMIIEN)
9d00a52c:	566000d1 	bnezl	s3,9d00a874 <EthPhyInit+0x488>
9d00a530:	24040003 	li	a0,3
	
    oFlags|=(cFlags&ETH_PHY_CFG_RMII)?ETH_OPEN_RMII:ETH_OPEN_MII;
    
	_PhyInitIo();	// init IO pins

	EthMIIMConfig(GetSystemClock(), EthPhyMIIMClock());
9d00a534:	0f402a6a 	jal	9d00a9a8 <EthPhyMIIMClock>
9d00a538:	0000b021 	move	s6,zero
9d00a53c:	3c0404c4 	lui	a0,0x4c4
9d00a540:	00402821 	move	a1,v0
9d00a544:	0f403604 	jal	9d00d810 <EthMIIMConfig>
9d00a548:	3484b400 	ori	a0,a0,0xb400
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a54c:	8f85816c 	lw	a1,-32404(gp)
9d00a550:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a554:	00002021 	move	a0,zero
    return EthMIIMReadResult();
9d00a558:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a55c:	00000000 	nop
9d00a560:	7c567804 	ins	s6,v0,0x0,0x10
	__BMCONbits_t bmcon;
	unsigned int	tStart, tWaitReset;

	bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);		// read the BMCON register

	if(bmcon.RESET)
9d00a564:	32c28000 	andi	v0,s6,0x8000
9d00a568:	1040001d 	beqz	v0,9d00a5e0 <EthPhyInit+0x1f4>
9d00a56c:	8f85816c 	lw	a1,-32404(gp)
	{	// that is already suspicios...but give it a chance to clear itself
		tWaitReset=(GetSystemClock()/2000)*PHY_RESET_CLR_TMO;
		tStart=ReadCoreTimer();
9d00a570:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a574:	3c140131 	lui	s4,0x131
9d00a578:	00409821 	move	s3,v0
		do
		{
			bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		}while(bmcon.RESET && (ReadCoreTimer()-tStart)<tWaitReset);	// wait reset self clear
9d00a57c:	26942d00 	addiu	s4,s4,11520
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a580:	8f85816c 	lw	a1,-32404(gp)
9d00a584:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a588:	00002021 	move	a0,zero
    return EthMIIMReadResult();
9d00a58c:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a590:	00000000 	nop
9d00a594:	7c567804 	ins	s6,v0,0x0,0x10
		tWaitReset=(GetSystemClock()/2000)*PHY_RESET_CLR_TMO;
		tStart=ReadCoreTimer();
		do
		{
			bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		}while(bmcon.RESET && (ReadCoreTimer()-tStart)<tWaitReset);	// wait reset self clear
9d00a598:	32c28000 	andi	v0,s6,0x8000
9d00a59c:	10400007 	beqz	v0,9d00a5bc <EthPhyInit+0x1d0>
9d00a5a0:	8f85816c 	lw	a1,-32404(gp)
9d00a5a4:	0f40324a 	jal	9d00c928 <ReadCoreTimer>
9d00a5a8:	00000000 	nop
9d00a5ac:	00531023 	subu	v0,v0,s3
9d00a5b0:	0054102b 	sltu	v0,v0,s4
9d00a5b4:	1440fff3 	bnez	v0,9d00a584 <EthPhyInit+0x198>
9d00a5b8:	8f85816c 	lw	a1,-32404(gp)
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a5bc:	00002021 	move	a0,zero
9d00a5c0:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a5c4:	2413000d 	li	s3,13
    return EthMIIMReadResult();
9d00a5c8:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a5cc:	00000000 	nop
9d00a5d0:	7c567804 	ins	s6,v0,0x0,0x10
		{
			bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		}while(bmcon.RESET && (ReadCoreTimer()-tStart)<tWaitReset);	// wait reset self clear

		bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);
		if(bmcon.RESET)
9d00a5d4:	32c28000 	andi	v0,s6,0x8000
9d00a5d8:	1440ff96 	bnez	v0,9d00a434 <EthPhyInit+0x48>
9d00a5dc:	8f85816c 	lw	a1,-32404(gp)
	}

	// ok, reset bit is low
	// try to see if we can write smth to the PHY
	// we use Loopback and Isolate bits
	EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, _BMCON_LOOPBACK_MASK|_BMCON_ISOLATE_MASK);	// write control bits
9d00a5e0:	24064400 	li	a2,17408
9d00a5e4:	0f4035f6 	jal	9d00d7d8 <EthMIIMWriteStart>
9d00a5e8:	00002021 	move	a0,zero
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a5ec:	8f85816c 	lw	a1,-32404(gp)
9d00a5f0:	00002021 	move	a0,zero
9d00a5f4:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a5f8:	2413000d 	li	s3,13
    return EthMIIMReadResult();
9d00a5fc:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a600:	00000000 	nop
9d00a604:	7c567804 	ins	s6,v0,0x0,0x10
	// ok, reset bit is low
	// try to see if we can write smth to the PHY
	// we use Loopback and Isolate bits
	EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, _BMCON_LOOPBACK_MASK|_BMCON_ISOLATE_MASK);	// write control bits
	bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);		// read back
	if(bmcon.LOOPBACK==0 || bmcon.ISOLATE==0)
9d00a608:	32d64400 	andi	s6,s6,0x4400
9d00a60c:	24034400 	li	v1,17408
9d00a610:	16c3ff89 	bne	s6,v1,9d00a438 <EthPhyInit+0x4c>
9d00a614:	8fbf002c 	lw	ra,44(sp)
	{	// failed to set
		return 0;
	}
	bmcon.w^=_BMCON_LOOPBACK_MASK|_BMCON_ISOLATE_MASK;
	EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, bmcon.w);		// clear bits and write
9d00a618:	8f85816c 	lw	a1,-32404(gp)
	bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);		// read back
	if(bmcon.LOOPBACK==0 || bmcon.ISOLATE==0)
	{	// failed to set
		return 0;
	}
	bmcon.w^=_BMCON_LOOPBACK_MASK|_BMCON_ISOLATE_MASK;
9d00a61c:	38424400 	xori	v0,v0,0x4400
	EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, bmcon.w);		// clear bits and write
9d00a620:	3046ffff 	andi	a2,v0,0xffff
9d00a624:	0f4035f6 	jal	9d00d7d8 <EthMIIMWriteStart>
9d00a628:	00002021 	move	a0,zero
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a62c:	8f85816c 	lw	a1,-32404(gp)
9d00a630:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a634:	00002021 	move	a0,zero
    return EthMIIMReadResult();
9d00a638:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a63c:	00000000 	nop
		return 0;
	}
	bmcon.w^=_BMCON_LOOPBACK_MASK|_BMCON_ISOLATE_MASK;
	EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, bmcon.w);		// clear bits and write
	bmcon.w=_PhyReadReg(PHY_REG_BMCON, _PhyAdd);		// read back
	if(bmcon.LOOPBACK || bmcon.ISOLATE)
9d00a640:	30424400 	andi	v0,v0,0x4400
9d00a644:	1440ff7c 	bnez	v0,9d00a438 <EthPhyInit+0x4c>
9d00a648:	8fbf002c 	lw	ra,44(sp)
		return 0;
	}
	
	// everything seems to be fine
	//
	return EthPhyReset(1);
9d00a64c:	0f4028c9 	jal	9d00a324 <EthPhyReset>
9d00a650:	24040001 	li	a0,1

	EthMIIMConfig(GetSystemClock(), EthPhyMIIMClock());


	// try to detect the PHY and reset it
	if(!_PhyDetectReset())
9d00a654:	1040ff77 	beqz	v0,9d00a434 <EthPhyInit+0x48>
9d00a658:	02508025 	or	s0,s2,s0
	{	// failed to detect the PHY
		return ETH_RES_DTCT_ERR; 
	}

	// provide some defaults
	if(!(oFlags&(ETH_OPEN_FDUPLEX|ETH_OPEN_HDUPLEX)))
9d00a65c:	32030006 	andi	v1,s0,0x6
	{
		oFlags|=ETH_OPEN_HDUPLEX;
9d00a660:	36020004 	ori	v0,s0,0x4
9d00a664:	0043800a 	movz	s0,v0,v1
	}
	if(!(oFlags&(ETH_OPEN_100|ETH_OPEN_10)))
	{
		oFlags|=ETH_OPEN_10;
9d00a668:	36020010 	ori	v0,s0,0x10
	// provide some defaults
	if(!(oFlags&(ETH_OPEN_FDUPLEX|ETH_OPEN_HDUPLEX)))
	{
		oFlags|=ETH_OPEN_HDUPLEX;
	}
	if(!(oFlags&(ETH_OPEN_100|ETH_OPEN_10)))
9d00a66c:	32030018 	andi	v1,s0,0x18
	{
		oFlags|=ETH_OPEN_10;
9d00a670:	0043800a 	movz	s0,v0,v1
	}
	
	if(oFlags&ETH_OPEN_AUTO)
9d00a674:	32020001 	andi	v0,s0,0x1
9d00a678:	10400097 	beqz	v0,9d00a8d8 <EthPhyInit+0x4ec>
9d00a67c:	32020008 	andi	v0,s0,0x8
	{	// advertise auto negotiation
		openReqs=_BMSTAT_AN_ABLE_MASK;

		if(oFlags&ETH_OPEN_100)
9d00a680:	10400007 	beqz	v0,9d00a6a0 <EthPhyInit+0x2b4>
9d00a684:	24140008 	li	s4,8
		{
			if(oFlags&ETH_OPEN_FDUPLEX)
9d00a688:	32030002 	andi	v1,s0,0x2
			{
				openReqs|=_BMSTAT_BASE100TX_FDX_MASK;
9d00a68c:	24024008 	li	v0,16392
9d00a690:	0043a00b 	movn	s4,v0,v1
			}
			if(oFlags&ETH_OPEN_HDUPLEX)
			{
				openReqs|=_BMSTAT_BASE100TX_HDX_MASK;
9d00a694:	36822000 	ori	v0,s4,0x2000
		{
			if(oFlags&ETH_OPEN_FDUPLEX)
			{
				openReqs|=_BMSTAT_BASE100TX_FDX_MASK;
			}
			if(oFlags&ETH_OPEN_HDUPLEX)
9d00a698:	32030004 	andi	v1,s0,0x4
			{
				openReqs|=_BMSTAT_BASE100TX_HDX_MASK;
9d00a69c:	0043a00b 	movn	s4,v0,v1
			}
		}
			
		if(oFlags&ETH_OPEN_10)
9d00a6a0:	32020010 	andi	v0,s0,0x10
9d00a6a4:	50400008 	beqzl	v0,9d00a6c8 <EthPhyInit+0x2dc>
9d00a6a8:	7c14a620 	seh	s4,s4
		{
			if(oFlags&ETH_OPEN_FDUPLEX)
9d00a6ac:	32040002 	andi	a0,s0,0x2
			{
				openReqs|=_BMSTAT_BASE10T_FDX_MASK;
9d00a6b0:	36831000 	ori	v1,s4,0x1000
			}
			if(oFlags&ETH_OPEN_HDUPLEX)
9d00a6b4:	32020004 	andi	v0,s0,0x4
9d00a6b8:	10400002 	beqz	v0,9d00a6c4 <EthPhyInit+0x2d8>
9d00a6bc:	0064a00b 	movn	s4,v1,a0
			{
				openReqs|=_BMSTAT_BASE10T_HDX_MASK;
9d00a6c0:	36940800 	ori	s4,s4,0x800
		{
			if(oFlags&ETH_OPEN_FDUPLEX)
			{
				openReqs|=_BMSTAT_BASE10T_FDX_MASK;
			}
			if(oFlags&ETH_OPEN_HDUPLEX)
9d00a6c4:	7c14a620 	seh	s4,s4
	return linkStat;	
}

static __inline__ unsigned short __attribute__((always_inline)) _PhyReadReg( unsigned int rIx, unsigned int phyAdd )
{
    EthMIIMReadStart(rIx, phyAdd);
9d00a6c8:	8f85816c 	lw	a1,-32404(gp)
9d00a6cc:	24040001 	li	a0,1
9d00a6d0:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a6d4:	32947808 	andi	s4,s4,0x7808
    return EthMIIMReadResult();
9d00a6d8:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a6dc:	2413000e 	li	s3,14
		}
	}
	
	// try to match the oFlags with the PHY capabilities
	phyCpbl=_PhyReadReg(PHY_REG_BMSTAT, _PhyAdd);
	matchCpbl=(openReqs&(MAC_COMM_CPBL_MASK|_BMSTAT_AN_ABLE_MASK))&phyCpbl;	// common features
9d00a6e0:	0282a024 	and	s4,s4,v0
	if(!(matchCpbl&MAC_COMM_CPBL_MASK))
9d00a6e4:	32827800 	andi	v0,s4,0x7800
9d00a6e8:	1040ff53 	beqz	v0,9d00a438 <EthPhyInit+0x4c>
9d00a6ec:	8fbf002c 	lw	ra,44(sp)
	{	// no match?
		return ETH_RES_CPBL_ERR;
	}
	
	// we're ok, we can configure the PHY
	res=EthPhyConfigureMII(cFlags);
9d00a6f0:	0f402a4b 	jal	9d00a92c <EthPhyConfigureMII>
9d00a6f4:	02202021 	move	a0,s1
	if(res!=ETH_RES_OK)
9d00a6f8:	1440ff4e 	bnez	v0,9d00a434 <EthPhyInit+0x48>
9d00a6fc:	00409821 	move	s3,v0
	{
		return res;
	}
	
	res=EthPhyConfigureMdix(oFlags);
9d00a700:	0f402a4f 	jal	9d00a93c <EthPhyConfigureMdix>
9d00a704:	02002021 	move	a0,s0
	if(res!=ETH_RES_OK)
9d00a708:	1440ff4a 	bnez	v0,9d00a434 <EthPhyInit+0x48>
9d00a70c:	00409821 	move	s3,v0
	{
		return res;
	}
		
	if(matchCpbl&_BMSTAT_AN_ABLE_MASK)
9d00a710:	32820008 	andi	v0,s4,0x8
9d00a714:	1440007a 	bnez	v0,9d00a900 <EthPhyInit+0x514>
9d00a718:	8f85816c 	lw	a1,-32404(gp)
	}
	else
	{	// ok, just don't use negotiation

		ctrlReg=0;
		if(matchCpbl&(_BMSTAT_BASE100TX_HDX_MASK|_BMSTAT_BASE100TX_FDX_MASK))	// set 100Mbps request/capability
9d00a71c:	32966000 	andi	s6,s4,0x6000
		{
			ctrlReg|=_BMCON_SPEED_MASK;
9d00a720:	24062000 	li	a2,8192
		}

		if(matchCpbl&(_BMSTAT_BASE10T_FDX_MASK|_BMSTAT_BASE100TX_FDX_MASK))
9d00a724:	32915000 	andi	s1,s4,0x5000
9d00a728:	12200004 	beqz	s1,9d00a73c <EthPhyInit+0x350>
9d00a72c:	0016300a 	movz	a2,zero,s6
		{
			ctrlReg|=_BMCON_DUPLEX_MASK;
9d00a730:	34c60100 	ori	a2,a2,0x100
9d00a734:	30c6ffff 	andi	a2,a2,0xffff
		if(oFlags&ETH_OPEN_PHY_LOOPBACK)
		{
			ctrlReg|=_BMCON_LOOPBACK_MASK;
		}
		
		EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, ctrlReg);	// update the configuration
9d00a738:	8f85816c 	lw	a1,-32404(gp)
			ctrlReg|=_BMCON_DUPLEX_MASK;
		}
		
		if(oFlags&ETH_OPEN_PHY_LOOPBACK)
		{
			ctrlReg|=_BMCON_LOOPBACK_MASK;
9d00a73c:	34c24000 	ori	v0,a2,0x4000
		if(matchCpbl&(_BMSTAT_BASE10T_FDX_MASK|_BMSTAT_BASE100TX_FDX_MASK))
		{
			ctrlReg|=_BMCON_DUPLEX_MASK;
		}
		
		if(oFlags&ETH_OPEN_PHY_LOOPBACK)
9d00a740:	32030080 	andi	v1,s0,0x80
		{
			ctrlReg|=_BMCON_LOOPBACK_MASK;
9d00a744:	0043300b 	movn	a2,v0,v1
		}
		
		EthMIIMWriteStart(PHY_REG_BMCON, _PhyAdd, ctrlReg);	// update the configuration
9d00a748:	0f4035f6 	jal	9d00d7d8 <EthMIIMWriteStart>
9d00a74c:	00002021 	move	a0,zero

	// now update the open flags
	// the upper layer needs to know the PHY set-up to further set-up the MAC.
	
	// clear the capabilities	
	oFlags&=~(ETH_OPEN_AUTO|ETH_OPEN_FDUPLEX|ETH_OPEN_HDUPLEX|ETH_OPEN_100|ETH_OPEN_10);
9d00a750:	2402ffe0 	li	v0,-32
9d00a754:	02028024 	and	s0,s0,v0
	{
		oFlags|=ETH_OPEN_AUTO;
	}
	if(matchCpbl&(_BMSTAT_BASE100TX_HDX_MASK|_BMSTAT_BASE100TX_FDX_MASK))	// set 100Mbps request/capability
	{
		oFlags|=ETH_OPEN_100;
9d00a758:	36020008 	ori	v0,s0,0x8
9d00a75c:	0056800b 	movn	s0,v0,s6
	}
	if(matchCpbl&(_BMSTAT_BASE10T_HDX_MASK|_BMSTAT_BASE10T_FDX_MASK))	// set 10Mbps request/capability
9d00a760:	32831800 	andi	v1,s4,0x1800
	{
		oFlags|=ETH_OPEN_10;
9d00a764:	36020010 	ori	v0,s0,0x10
9d00a768:	0043800b 	movn	s0,v0,v1
	}
	if(matchCpbl&(_BMSTAT_BASE10T_FDX_MASK|_BMSTAT_BASE100TX_FDX_MASK))
	{
		oFlags|=ETH_OPEN_FDUPLEX;
9d00a76c:	36020002 	ori	v0,s0,0x2
9d00a770:	0051800b 	movn	s0,v0,s1
	}
	if(matchCpbl&(_BMSTAT_BASE10T_HDX_MASK|_BMSTAT_BASE100TX_HDX_MASK))
9d00a774:	32942800 	andi	s4,s4,0x2800
	{
		oFlags|=ETH_OPEN_HDUPLEX;
9d00a778:	36020004 	ori	v0,s0,0x4
9d00a77c:	0054800b 	movn	s0,v0,s4
	}

	*pResFlags=oFlags;		// upper layer needs to know the PHY set-up to further set-up the MAC.

	return ETH_RES_OK;	
9d00a780:	0b40290d 	j	9d00a434 <EthPhyInit+0x48>
9d00a784:	aeb00000 	sw	s0,0(s5)
			PORTSetPinsDigitalIn(_ETH_COL_PORT, _ETH_COL_BIT);
		}
	}
	else
	{	// alternate setting, both RMII and MII
		PORTSetPinsDigitalOut(_ETH_ALT_MDC_PORT, _ETH_ALT_MDC_BIT);	
9d00a788:	24040003 	li	a0,3
9d00a78c:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a790:	24050800 	li	a1,2048
		PORTSetPinsDigitalIn(_ETH_ALT_MDIO_PORT, _ETH_ALT_MDIO_BIT);
9d00a794:	24040003 	li	a0,3
9d00a798:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a79c:	24050100 	li	a1,256

		PORTSetPinsDigitalOut(_ETH_ALT_TXEN_PORT, _ETH_ALT_TXEN_BIT);	
9d00a7a0:	00002021 	move	a0,zero
9d00a7a4:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a7a8:	34058000 	li	a1,0x8000
		PORTSetPinsDigitalOut(_ETH_ALT_TXD0_PORT, _ETH_ALT_TXD0_BIT);	
9d00a7ac:	24040003 	li	a0,3
9d00a7b0:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a7b4:	24054000 	li	a1,16384
		PORTSetPinsDigitalOut(_ETH_ALT_TXD1_PORT, _ETH_ALT_TXD1_BIT);	
9d00a7b8:	24040003 	li	a0,3
9d00a7bc:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a7c0:	34058000 	li	a1,0x8000

		
		PORTSetPinsDigitalIn(_ETH_ALT_RXCLK_PORT, _ETH_ALT_RXCLK_BIT);
9d00a7c4:	24040006 	li	a0,6
9d00a7c8:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a7cc:	24050200 	li	a1,512
		PORTSetPinsDigitalIn(_ETH_ALT_RXDV_PORT, _ETH_ALT_RXDV_BIT);
9d00a7d0:	24040006 	li	a0,6
9d00a7d4:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a7d8:	24050100 	li	a1,256
		PORTSetPinsDigitalIn(_ETH_ALT_RXD0_PORT, _ETH_ALT_RXD0_BIT);
9d00a7dc:	24040004 	li	a0,4
9d00a7e0:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a7e4:	24050100 	li	a1,256
		PORTSetPinsDigitalIn(_ETH_ALT_RXD1_PORT, _ETH_ALT_RXD1_BIT);
9d00a7e8:	24040004 	li	a0,4
9d00a7ec:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a7f0:	24050200 	li	a1,512
		PORTSetPinsDigitalIn(_ETH_ALT_RXERR_PORT, _ETH_ALT_RXERR_BIT);


		if(bcfg3.FMIIEN)
9d00a7f4:	7e730600 	ext	s3,s3,0x18,0x1
		
		PORTSetPinsDigitalIn(_ETH_ALT_RXCLK_PORT, _ETH_ALT_RXCLK_BIT);
		PORTSetPinsDigitalIn(_ETH_ALT_RXDV_PORT, _ETH_ALT_RXDV_BIT);
		PORTSetPinsDigitalIn(_ETH_ALT_RXD0_PORT, _ETH_ALT_RXD0_BIT);
		PORTSetPinsDigitalIn(_ETH_ALT_RXD1_PORT, _ETH_ALT_RXD1_BIT);
		PORTSetPinsDigitalIn(_ETH_ALT_RXERR_PORT, _ETH_ALT_RXERR_BIT);
9d00a7f8:	24040006 	li	a0,6
9d00a7fc:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a800:	34058000 	li	a1,0x8000


		if(bcfg3.FMIIEN)
9d00a804:	1260ff4b 	beqz	s3,9d00a534 <EthPhyInit+0x148>
9d00a808:	00000000 	nop
		{	// just MII
			PORTSetPinsDigitalIn(_ETH_ALT_TXCLK_PORT, _ETH_ALT_TXCLK_BIT);
9d00a80c:	00002021 	move	a0,zero
9d00a810:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a814:	24054000 	li	a1,16384
			PORTSetPinsDigitalOut(_ETH_ALT_TXD2_PORT, _ETH_ALT_TXD2_BIT);	
9d00a818:	24040001 	li	a0,1
9d00a81c:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a820:	34058000 	li	a1,0x8000
			PORTSetPinsDigitalOut(_ETH_ALT_TXD3_PORT, _ETH_ALT_TXD3_BIT);	
9d00a824:	24040001 	li	a0,1
9d00a828:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a82c:	24054000 	li	a1,16384
			PORTSetPinsDigitalOut(_ETH_ALT_TXERR_PORT, _ETH_ALT_TXERR_BIT);	
9d00a830:	24040001 	li	a0,1
9d00a834:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a838:	24050800 	li	a1,2048

			PORTSetPinsDigitalIn(_ETH_ALT_RXD2_PORT, _ETH_ALT_RXD2_BIT);
9d00a83c:	00002021 	move	a0,zero
9d00a840:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a844:	24050200 	li	a1,512
			PORTSetPinsDigitalIn(_ETH_ALT_RXD3_PORT, _ETH_ALT_RXD3_BIT);
9d00a848:	00002021 	move	a0,zero
9d00a84c:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a850:	24050400 	li	a1,1024
			PORTSetPinsDigitalIn(_ETH_ALT_CRS_PORT, _ETH_ALT_CRS_BIT);
9d00a854:	24040001 	li	a0,1
9d00a858:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a85c:	24051000 	li	a1,4096
			PORTSetPinsDigitalIn(_ETH_ALT_COL_PORT, _ETH_ALT_COL_BIT);
9d00a860:	24040001 	li	a0,1
9d00a864:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a868:	24052000 	li	a1,8192
9d00a86c:	0b40294d 	j	9d00a534 <EthPhyInit+0x148>
9d00a870:	00000000 	nop
		PORTSetPinsDigitalIn(_ETH_RXERR_PORT, _ETH_RXERR_BIT);


		if(bcfg3.FMIIEN)
		{	// just MII
			PORTSetPinsDigitalIn(_ETH_TXCLK_PORT, _ETH_TXCLK_BIT);
9d00a874:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a878:	24050080 	li	a1,128
			PORTSetPinsDigitalOut(_ETH_TXD2_PORT, _ETH_TXD2_BIT);	
9d00a87c:	24040003 	li	a0,3
9d00a880:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a884:	24051000 	li	a1,4096
			PORTSetPinsDigitalOut(_ETH_TXD3_PORT, _ETH_TXD3_BIT);	
9d00a888:	24040003 	li	a0,3
9d00a88c:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a890:	24052000 	li	a1,8192
			PORTSetPinsDigitalOut(_ETH_TXERR_PORT, _ETH_TXERR_BIT);	
9d00a894:	24040006 	li	a0,6
9d00a898:	0f40367c 	jal	9d00d9f0 <PORTSetPinsDigitalOut>
9d00a89c:	24050002 	li	a1,2

			PORTSetPinsDigitalIn(_ETH_RXD2_PORT, _ETH_RXD2_BIT);
9d00a8a0:	24040001 	li	a0,1
9d00a8a4:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a8a8:	24054000 	li	a1,16384
			PORTSetPinsDigitalIn(_ETH_RXD3_PORT, _ETH_RXD3_BIT);
9d00a8ac:	24040001 	li	a0,1
9d00a8b0:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a8b4:	34058000 	li	a1,0x8000
			PORTSetPinsDigitalIn(_ETH_CRS_PORT, _ETH_CRS_BIT);
9d00a8b8:	24040006 	li	a0,6
9d00a8bc:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a8c0:	24050080 	li	a1,128
			PORTSetPinsDigitalIn(_ETH_COL_PORT, _ETH_COL_BIT);
9d00a8c4:	24040006 	li	a0,6
9d00a8c8:	0f40366c 	jal	9d00d9b0 <PORTSetPinsDigitalIn>
9d00a8cc:	24050040 	li	a1,64
9d00a8d0:	0b40294d 	j	9d00a534 <EthPhyInit+0x148>
9d00a8d4:	00000000 	nop
			}
		}		
	}
	else
	{	// no auto negotiation
		if(oFlags&ETH_OPEN_100)
9d00a8d8:	10400005 	beqz	v0,9d00a8f0 <EthPhyInit+0x504>
9d00a8dc:	32030002 	andi	v1,s0,0x2
		{
			openReqs=(oFlags&ETH_OPEN_FDUPLEX)?_BMSTAT_BASE100TX_FDX_MASK:_BMSTAT_BASE100TX_HDX_MASK;
9d00a8e0:	24144000 	li	s4,16384
9d00a8e4:	24022000 	li	v0,8192
9d00a8e8:	0b4029b2 	j	9d00a6c8 <EthPhyInit+0x2dc>
9d00a8ec:	0043a00a 	movz	s4,v0,v1
		}
		else
		{
			openReqs=(oFlags&ETH_OPEN_FDUPLEX)?_BMSTAT_BASE10T_FDX_MASK:_BMSTAT_BASE10T_HDX_MASK;
9d00a8f0:	24141000 	li	s4,4096
9d00a8f4:	24020800 	li	v0,2048
9d00a8f8:	0b4029b2 	j	9d00a6c8 <EthPhyInit+0x2dc>
9d00a8fc:	0043a00a 	movz	s4,v0,v1
		
	if(matchCpbl&_BMSTAT_AN_ABLE_MASK)
	{	// ok, we can perform auto negotiation
		unsigned short	anadReg;

		anadReg=(((matchCpbl>>_BMSTAT_NEGOTIATION_POS)<<_ANAD_NEGOTIATION_POS)&_ANAD_NEGOTIATION_MASK)|PROT_802_3;
9d00a900:	00143182 	srl	a2,s4,0x6
		if(ETH_MAC_PAUSE_CPBL_MASK& ETH_MAC_PAUSE_TYPE_ASM_DIR)
		{
			anadReg|=_ANAD_ASM_DIR_MASK;
		}

		EthMIIMWriteStart(PHY_REG_ANAD, _PhyAdd, anadReg);		// advertise our capabilities
9d00a904:	24040004 	li	a0,4
9d00a908:	0f4035f6 	jal	9d00d7d8 <EthMIIMWriteStart>
9d00a90c:	34c60c01 	ori	a2,a2,0xc01
						
		EthPhyRestartNegotiation();	// restart negotiation and we'll have to wait
9d00a910:	0f4027ad 	jal	9d009eb4 <EthPhyRestartNegotiation>
9d00a914:	32966000 	andi	s6,s4,0x6000

	// now update the open flags
	// the upper layer needs to know the PHY set-up to further set-up the MAC.
	
	// clear the capabilities	
	oFlags&=~(ETH_OPEN_AUTO|ETH_OPEN_FDUPLEX|ETH_OPEN_HDUPLEX|ETH_OPEN_100|ETH_OPEN_10);
9d00a918:	2402ffe0 	li	v0,-32
9d00a91c:	02028024 	and	s0,s0,v0

	if(matchCpbl&_BMSTAT_AN_ABLE_MASK)
	{
		oFlags|=ETH_OPEN_AUTO;
9d00a920:	36100001 	ori	s0,s0,0x1
9d00a924:	0b4029d6 	j	9d00a758 <EthPhyInit+0x36c>
9d00a928:	32915000 	andi	s1,s4,0x5000

9d00a92c <EthPhyConfigureMII>:
 *
 * Note:            SMSC 8720 supports RMII  mode only!
 *****************************************************************************/
eEthRes EthPhyConfigureMII(eEthPhyCfgFlags cFlags)
{
	return (cFlags&ETH_PHY_CFG_RMII)?ETH_RES_OK:ETH_RES_CFG_ERR;
9d00a92c:	30840001 	andi	a0,a0,0x1
9d00a930:	2402000f 	li	v0,15
}
9d00a934:	03e00008 	jr	ra
9d00a938:	0004100b 	movn	v0,zero,a0

9d00a93c <EthPhyConfigureMdix>:
 * Overview:        This function configures the MDIX mode for the PHY.
 *
 * Note:            None
 *****************************************************************************/
eEthRes EthPhyConfigureMdix(eEthOpenFlags oFlags)
{
9d00a93c:	27bdffe8 	addiu	sp,sp,-24
9d00a940:	afb00010 	sw	s0,16(sp)
	unsigned short	phyReg;

	EthMIIMReadStart(PHY_REG_SPECIAL_CTRL, PHY_ADDRESS);
9d00a944:	00002821 	move	a1,zero
 * Overview:        This function configures the MDIX mode for the PHY.
 *
 * Note:            None
 *****************************************************************************/
eEthRes EthPhyConfigureMdix(eEthOpenFlags oFlags)
{
9d00a948:	00808021 	move	s0,a0
9d00a94c:	afbf0014 	sw	ra,20(sp)
	unsigned short	phyReg;

	EthMIIMReadStart(PHY_REG_SPECIAL_CTRL, PHY_ADDRESS);
9d00a950:	0f4035dc 	jal	9d00d770 <EthMIIMReadStart>
9d00a954:	2404001b 	li	a0,27
	phyReg=EthMIIMReadResult()&(_SPECIALCTRL_XPOL_MASK);	// mask off not used bits
9d00a958:	0f4035ec 	jal	9d00d7b0 <EthMIIMReadResult>
9d00a95c:	00000000 	nop
9d00a960:	30460010 	andi	a2,v0,0x10

	if(oFlags&ETH_OPEN_MDIX_AUTO)
9d00a964:	32030100 	andi	v1,s0,0x100
9d00a968:	14600005 	bnez	v1,9d00a980 <EthPhyConfigureMdix+0x44>
9d00a96c:	30c6ffff 	andi	a2,a2,0xffff
	{	// enable Auto-MDIX
		phyReg&=~_SPECIALCTRL_AMDIXCTRL_MASK;
	}
	else
	{	// no Auto-MDIX
		phyReg|=_SPECIALCTRL_AMDIXCTRL_MASK;	// disable Auto-MDIX
9d00a970:	34c68000 	ori	a2,a2,0x8000
	       if(oFlags&ETH_OPEN_MDIX_SWAP)
9d00a974:	32100200 	andi	s0,s0,0x200
	       {
		       phyReg|=_SPECIALCTRL_CH_SELECT_MASK;	// swap
9d00a978:	34c22000 	ori	v0,a2,0x2000
9d00a97c:	0050300b 	movn	a2,v0,s0
	       {
		       phyReg&=~_SPECIALCTRL_CH_SELECT_MASK;	// normal
	       }
	}
	
	EthMIIMWriteStart(PHY_REG_SPECIAL_CTRL, PHY_ADDRESS, phyReg);	
9d00a980:	2404001b 	li	a0,27
9d00a984:	0f4035f6 	jal	9d00d7d8 <EthMIIMWriteStart>
9d00a988:	00002821 	move	a1,zero

	return ETH_RES_OK;	

}
9d00a98c:	8fbf0014 	lw	ra,20(sp)
9d00a990:	00001021 	move	v0,zero
9d00a994:	8fb00010 	lw	s0,16(sp)
9d00a998:	03e00008 	jr	ra
9d00a99c:	27bd0018 	addiu	sp,sp,24

9d00a9a0 <EthPhyMIIMAddress>:
 * Note:            None
 *****************************************************************************/
unsigned int EthPhyMIIMAddress(void)
{
	return PHY_ADDRESS;
}
9d00a9a0:	03e00008 	jr	ra
9d00a9a4:	00001021 	move	v0,zero

9d00a9a8 <EthPhyMIIMClock>:
 * Overview:        This function returns the maximum clock frequency that the PHY can use for the MIIM transactions
 *
 * Note:            None
 *****************************************************************************/
unsigned int EthPhyMIIMClock(void)
{
9d00a9a8:	3c020026 	lui	v0,0x26
	return 2500000;		//  2.5 MHz max clock supported
}
9d00a9ac:	03e00008 	jr	ra
9d00a9b0:	244225a0 	addiu	v0,v0,9632

9d00a9b4 <_Z5resetv>:
#include <p32xxxx.h>

void reset()
{
    SYSKEY = 0;
    SYSKEY = 0xaa996655;
9d00a9b4:	3c03aa99 	lui	v1,0xaa99

#include <p32xxxx.h>

void reset()
{
    SYSKEY = 0;
9d00a9b8:	3c02bf81 	lui	v0,0xbf81
    SYSKEY = 0xaa996655;
9d00a9bc:	24636655 	addiu	v1,v1,26197

#include <p32xxxx.h>

void reset()
{
    SYSKEY = 0;
9d00a9c0:	ac40f230 	sw	zero,-3536(v0)
    SYSKEY = 0xaa996655;
9d00a9c4:	ac43f230 	sw	v1,-3536(v0)
    SYSKEY = 0x556699aa;
9d00a9c8:	3c035566 	lui	v1,0x5566
9d00a9cc:	346399aa 	ori	v1,v1,0x99aa
9d00a9d0:	ac43f230 	sw	v1,-3536(v0)

    /* Reset microcontroller */
    RSWRSTSET = 1;
9d00a9d4:	3c02bf81 	lui	v0,0xbf81
9d00a9d8:	24030001 	li	v1,1
9d00a9dc:	ac43f618 	sw	v1,-2536(v0)
    (void) RSWRST;
9d00a9e0:	3c02bf81 	lui	v0,0xbf81
9d00a9e4:	8c42f610 	lw	v0,-2544(v0)
}
9d00a9e8:	03e00008 	jr	ra
9d00a9ec:	00000000 	nop

9d00a9f0 <pinMode>:
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d00a9f0:	308400ff 	andi	a0,a0,0xff
9d00a9f4:	27bdffe0 	addiu	sp,sp,-32
uint8_t		            timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d00a9f8:	2c820057 	sltiu	v0,a0,87
#include "wiring_private.h"
#include "pins_arduino.h"

//************************************************************************
void pinMode(uint8_t pin, uint8_t mode)
{
9d00a9fc:	afbf001c 	sw	ra,28(sp)
9d00aa00:	afb10018 	sw	s1,24(sp)
9d00aa04:	afb00014 	sw	s0,20(sp)
uint8_t		            timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d00aa08:	10400022 	beqz	v0,9d00aa94 <pinMode+0xa4>
9d00aa0c:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif	// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d00aa10:	3c029d01 	lui	v0,0x9d01
9d00aa14:	2442dd58 	addiu	v0,v0,-8872
9d00aa18:	00441021 	addu	v0,v0,a0
9d00aa1c:	90420000 	lbu	v0,0(v0)
9d00aa20:	1040001c 	beqz	v0,9d00aa94 <pinMode+0xa4>
9d00aa24:	00021880 	sll	v1,v0,0x2
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = portRegisters(port);
9d00aa28:	3c069d01 	lui	a2,0x9d01
9d00aa2c:	24c6dd34 	addiu	a2,a2,-8908
9d00aa30:	00663021 	addu	a2,v1,a2

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d00aa34:	3c039d01 	lui	v1,0x9d01
9d00aa38:	00042040 	sll	a0,a0,0x1
9d00aa3c:	2463ddb0 	addiu	v1,v1,-8784
9d00aa40:	00641821 	addu	v1,v1,a0
9d00aa44:	94700000 	lhu	s0,0(v1)
	// analog input capable pins.
	// Clear the bit in the ANSELx register to ensure that the pin is in
	// digital input mode.
	iop->ansel.clr = bit;
#else
	if (port == _IOPORT_PB)
9d00aa48:	24030002 	li	v1,2
9d00aa4c:	10430026 	beq	v0,v1,9d00aae8 <pinMode+0xf8>
9d00aa50:	8cd10000 	lw	s1,0(a2)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d00aa54:	24020002 	li	v0,2
9d00aa58:	10a2001c 	beq	a1,v0,9d00aacc <pinMode+0xdc>
9d00aa5c:	2ca20003 	sltiu	v0,a1,3
9d00aa60:	50400011 	beqzl	v0,9d00aaa8 <pinMode+0xb8>
9d00aa64:	2ca50006 	sltiu	a1,a1,6
9d00aa68:	14a00012 	bnez	a1,9d00aab4 <pinMode+0xc4>
9d00aa6c:	8fbf001c 	lw	ra,28(sp)
            }
#endif
            // continue into INPUT case
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
9d00aa70:	3c029d01 	lui	v0,0x9d01
9d00aa74:	2442de60 	addiu	v0,v0,-8608
9d00aa78:	00442021 	addu	a0,v0,a0
9d00aa7c:	90840000 	lbu	a0,0(a0)
9d00aa80:	3084000f 	andi	a0,a0,0xf
            if (timer != NOT_ON_TIMER)
9d00aa84:	1480001c 	bnez	a0,9d00aaf8 <pinMode+0x108>
9d00aa88:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d00aa8c:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d00aa90:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d00aa94:	8fbf001c 	lw	ra,28(sp)
9d00aa98:	8fb10018 	lw	s1,24(sp)
9d00aa9c:	8fb00014 	lw	s0,20(sp)
9d00aaa0:	03e00008 	jr	ra
9d00aaa4:	27bd0020 	addiu	sp,sp,32

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d00aaa8:	14a0fff2 	bnez	a1,9d00aa74 <pinMode+0x84>
9d00aaac:	3c029d01 	lui	v0,0x9d01
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d00aab0:	8fbf001c 	lw	ra,28(sp)
            cn = digitalPinToCN(pin);
            if (cn != NOT_CN_PIN) {
                CNPUECLR = cn;
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
9d00aab4:	ae300004 	sw	s0,4(s1)
            iop->odc.clr  = bit;	//make sure it isn't open drain
9d00aab8:	ae300034 	sw	s0,52(s1)
	}
}
9d00aabc:	8fb10018 	lw	s1,24(sp)
9d00aac0:	8fb00014 	lw	s0,20(sp)
9d00aac4:	03e00008 	jr	ra
9d00aac8:	27bd0020 	addiu	sp,sp,32
9d00aacc:	8fbf001c 	lw	ra,28(sp)
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
            iop->tris.set = bit;	//make the pin an input
            break;
        case OPEN:
            iop->tris.clr = bit;	//OPEN implies output, make the pin an output
9d00aad0:	ae300004 	sw	s0,4(s1)
            iop->odc.set  = bit;	//make the pin open drain
9d00aad4:	ae300038 	sw	s0,56(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d00aad8:	8fb10018 	lw	s1,24(sp)
9d00aadc:	8fb00014 	lw	s0,20(sp)
9d00aae0:	03e00008 	jr	ra
9d00aae4:	27bd0020 	addiu	sp,sp,32
		//	You have to set the bit in the AD1PCFG for an analog pin to be used as a 
		//	digital input. They come up after reset as analog input with the digital 
		//	input disabled. For the PORTB pins you switch between analog input and 
		//	digital input using AD1PCFG.

		AD1PCFGSET = bit;
9d00aae8:	3c02bf81 	lui	v0,0xbf81
9d00aaec:	ac509068 	sw	s0,-28568(v0)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	// Set the pin to the requested mode.
    switch (mode) {
9d00aaf0:	0b402a96 	j	9d00aa58 <pinMode+0x68>
9d00aaf4:	24020002 	li	v0,2
            //* Determine if this is an output compare pin. If so,
            //* we need to make sure PWM output is off.
            timer = digitalPinToTimerOC(pin) >> _BN_TIMER_OC;
            if (timer != NOT_ON_TIMER)
            {
                turnOffPWM(timer);
9d00aaf8:	0f402b19 	jal	9d00ac64 <turnOffPWM>
9d00aafc:	00000000 	nop
            }

            //*	May  1,	2011
            //*	according to item #26 in PIC32MX5XX-6XX-7XX Errata.pdf 
            //*	if we are setting to input, set the data bit to zero first
            iop->lat.clr  = bit;	//clear to output bit		
9d00ab00:	ae300024 	sw	s0,36(s1)
            iop->tris.set = bit;	//make the pin an input
9d00ab04:	ae300008 	sw	s0,8(s1)
            } 
#endif
            iop->tris.clr = bit;	//make the pin an output
            iop->odc.clr  = bit;	//make sure it isn't open drain
	}
}
9d00ab08:	0b402aa6 	j	9d00aa98 <pinMode+0xa8>
9d00ab0c:	8fbf001c 	lw	ra,28(sp)

9d00ab10 <digitalWrite>:
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d00ab10:	308400ff 	andi	a0,a0,0xff
9d00ab14:	27bdffd8 	addiu	sp,sp,-40
uint8_t					timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d00ab18:	2c820057 	sltiu	v0,a0,87
//*	Reading from PORT gives you a snapshot of the actual pins state regardless of how, 
//*	if at all, the PIC is trying to drive them.  
//*	Reading from LAT gives you the values last written to the pins, whether thru LAT or PORT.
//************************************************************************
void digitalWrite(uint8_t pin, uint8_t val)
{
9d00ab1c:	afbf0024 	sw	ra,36(sp)
9d00ab20:	afb10020 	sw	s1,32(sp)
9d00ab24:	afb0001c 	sw	s0,28(sp)
uint8_t					timer;
uint32_t                cn;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d00ab28:	1040001d 	beqz	v0,9d00aba0 <digitalWrite+0x90>
9d00ab2c:	30a500ff 	andi	a1,a1,0xff
		return;
	}
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d00ab30:	3c029d01 	lui	v0,0x9d01
9d00ab34:	2442dd58 	addiu	v0,v0,-8872
9d00ab38:	00821021 	addu	v0,a0,v0
9d00ab3c:	90420000 	lbu	v0,0(v0)
9d00ab40:	10400017 	beqz	v0,9d00aba0 <digitalWrite+0x90>
9d00ab44:	3c039d01 	lui	v1,0x9d01
	{
		return;
	}

	//* Obtain pointer to the registers for this io port.
	iop = portRegisters(port);
9d00ab48:	2463dd34 	addiu	v1,v1,-8908
9d00ab4c:	00021080 	sll	v0,v0,0x2
9d00ab50:	00431021 	addu	v0,v0,v1
9d00ab54:	8c500000 	lw	s0,0(v0)

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d00ab58:	3c039d01 	lui	v1,0x9d01
9d00ab5c:	00042040 	sll	a0,a0,0x1
9d00ab60:	2463ddb0 	addiu	v1,v1,-8784
9d00ab64:	00831821 	addu	v1,a0,v1

    //* If the port is in input mode and we write a value to it
    //* we must be enabling or disabling the internal pull-up
    //* resistor.  Only works for pins that have an associated
    //* change notification pin.
    if (iop->tris.reg & bit) {
9d00ab68:	8e020000 	lw	v0,0(s0)
9d00ab6c:	94710000 	lhu	s1,0(v1)
9d00ab70:	02221024 	and	v0,s1,v0
9d00ab74:	1440000a 	bnez	v0,9d00aba0 <digitalWrite+0x90>
9d00ab78:	3c029d01 	lui	v0,0x9d01
#endif

    } else {
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
9d00ab7c:	2442de60 	addiu	v0,v0,-8608
9d00ab80:	00822021 	addu	a0,a0,v0
9d00ab84:	90840000 	lbu	a0,0(a0)
9d00ab88:	3084000f 	andi	a0,a0,0xf
        if (timer != NOT_ON_TIMER)
9d00ab8c:	1480000c 	bnez	a0,9d00abc0 <digitalWrite+0xb0>
9d00ab90:	00000000 	nop
        {
            turnOffPWM(timer);
        }

        //* Set the pin state
        if (val == LOW)
9d00ab94:	10a00007 	beqz	a1,9d00abb4 <digitalWrite+0xa4>
9d00ab98:	00000000 	nop
        {
            iop->lat.clr = bit;
        }
        else
        {
            iop->lat.set = bit;
9d00ab9c:	ae110028 	sw	s1,40(s0)
        }
    }
}
9d00aba0:	8fbf0024 	lw	ra,36(sp)
9d00aba4:	8fb10020 	lw	s1,32(sp)
9d00aba8:	8fb0001c 	lw	s0,28(sp)
9d00abac:	03e00008 	jr	ra
9d00abb0:	27bd0028 	addiu	sp,sp,40
        }

        //* Set the pin state
        if (val == LOW)
        {
            iop->lat.clr = bit;
9d00abb4:	ae110024 	sw	s1,36(s0)
        else
        {
            iop->lat.set = bit;
        }
    }
}
9d00abb8:	0b402ae9 	j	9d00aba4 <digitalWrite+0x94>
9d00abbc:	8fbf0024 	lw	ra,36(sp)
        //* Determine if this is an output compare pin. If so,
        //* we need to make sure PWM output is off.
        timer = digitalPinToTimerOC(pin);
        if (timer != NOT_ON_TIMER)
        {
            turnOffPWM(timer);
9d00abc0:	0f402b19 	jal	9d00ac64 <turnOffPWM>
9d00abc4:	afa50010 	sw	a1,16(sp)
9d00abc8:	8fa50010 	lw	a1,16(sp)
        }

        //* Set the pin state
        if (val == LOW)
9d00abcc:	14a0fff3 	bnez	a1,9d00ab9c <digitalWrite+0x8c>
9d00abd0:	00000000 	nop
9d00abd4:	0b402aed 	j	9d00abb4 <digitalWrite+0xa4>
9d00abd8:	00000000 	nop

9d00abdc <digitalRead>:
    }
}

//************************************************************************
int digitalRead(uint8_t pin)
{
9d00abdc:	308400ff 	andi	a0,a0,0xff
uint8_t					port;
int						highLow;

	/* Check if pin number is in valid range.
	*/
	if (pin >= NUM_DIGITAL_PINS_EXTENDED)
9d00abe0:	2c820057 	sltiu	v0,a0,87
9d00abe4:	10400018 	beqz	v0,9d00ac48 <digitalRead+0x6c>
9d00abe8:	00000000 	nop
		return tmp;
	}
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
9d00abec:	3c029d01 	lui	v0,0x9d01
9d00abf0:	2442dd58 	addiu	v0,v0,-8872
9d00abf4:	00821021 	addu	v0,a0,v0
9d00abf8:	90430000 	lbu	v1,0(v0)
9d00abfc:	10600012 	beqz	v1,9d00ac48 <digitalRead+0x6c>
9d00ac00:	00001021 	move	v0,zero
	{
		return LOW;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_regset *)portRegisters(port);
9d00ac04:	3c029d01 	lui	v0,0x9d01
9d00ac08:	00032880 	sll	a1,v1,0x2
9d00ac0c:	2442dd34 	addiu	v0,v0,-8908
9d00ac10:	00a21021 	addu	v0,a1,v0

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d00ac14:	3c059d01 	lui	a1,0x9d01
9d00ac18:	24a5ddb0 	addiu	a1,a1,-8784
9d00ac1c:	00042040 	sll	a0,a0,0x1
9d00ac20:	00852021 	addu	a0,a0,a1
	{
		return LOW;
	}

	//* Obtain pointer to the registers for this io port.
	iop = (p32_regset *)portRegisters(port);
9d00ac24:	8c450000 	lw	a1,0(v0)

	//* Obtain bit mask for the specific bit for this pin.
	bit = digitalPinToBitMask(pin);
9d00ac28:	94820000 	lhu	v0,0(a0)
	// analog input capable pins.
	// Clear the bit in the ANSELx register to ensure that the pin is in
	// digital input mode.
	iop->ansel.clr = bit;
#else
	if (port == _IOPORT_PB)
9d00ac2c:	24040002 	li	a0,2
9d00ac30:	10640007 	beq	v1,a0,9d00ac50 <digitalRead+0x74>
9d00ac34:	3c03bf81 	lui	v1,0xbf81

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	//* Get the pin state.
	if ((iop->port.reg & bit) != 0) 
9d00ac38:	8ca30010 	lw	v1,16(a1)
9d00ac3c:	00431024 	and	v0,v0,v1
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
	{
		return LOW;
9d00ac40:	03e00008 	jr	ra
9d00ac44:	0002102b 	sltu	v0,zero,v0
	{
		highLow	=	LOW;
	}

	return(highLow);
}
9d00ac48:	03e00008 	jr	ra
9d00ac4c:	00000000 	nop
		//	You have to set the bit in the AD1PCFG for an analog pin to be used as a 
		//	digital input. They come up after reset as analog input with the digital 
		//	input disabled. For the PORTB pins you switch between analog input and 
		//	digital input using AD1PCFG.

		AD1PCFGSET = bit;
9d00ac50:	ac629068 	sw	v0,-28568(v1)

	}
#endif	// defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)

	//* Get the pin state.
	if ((iop->port.reg & bit) != 0) 
9d00ac54:	8ca30010 	lw	v1,16(a1)
9d00ac58:	00431024 	and	v0,v0,v1
#endif		// OPT_BOARD_DIGITAL_IO

	//* Get the port number for this pin.
	if ((port = digitalPinToPort(pin)) == NOT_A_PIN)
	{
		return LOW;
9d00ac5c:	03e00008 	jr	ra
9d00ac60:	0002102b 	sltu	v0,zero,v0

9d00ac64 <turnOffPWM>:
}


//************************************************************************
void turnOffPWM(uint8_t timer)
{
9d00ac64:	308400ff 	andi	a0,a0,0xff
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d00ac68:	2482ffff 	addiu	v0,a0,-1
9d00ac6c:	24030001 	li	v1,1
9d00ac70:	93858109 	lbu	a1,-32503(gp)
9d00ac74:	00431004 	sllv	v0,v1,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d00ac78:	3c03005f 	lui	v1,0x5f
9d00ac7c:	3463c017 	ori	v1,v1,0xc017
9d00ac80:	00832021 	addu	a0,a0,v1
	ocp->ocxCon.clr = OCCON_ON;

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d00ac84:	00021027 	nor	v0,zero,v0
{
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
9d00ac88:	00042240 	sll	a0,a0,0x9
	ocp->ocxCon.clr = OCCON_ON;
9d00ac8c:	34038000 	li	v1,0x8000

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));
9d00ac90:	00451024 	and	v0,v0,a1
	p32_oc *	ocp;

	/* Disable the output compare.
	*/
	ocp = (p32_oc *)(_OCMP1_BASE_ADDRESS + (0x200 * (timer - (_TIMER_OC1 >> _BN_TIMER_OC))));
	ocp->ocxCon.clr = OCCON_ON;
9d00ac94:	ac830004 	sw	v1,4(a0)

	// Turn off the bit saying that this PWM is active.
	pwm_active &= ~(1 << (timer - (_TIMER_OC1 >> _BN_TIMER_OC)));

	// If no PWM are active, turn off the timer.
	if (pwm_active == 0)
9d00ac98:	14400003 	bnez	v0,9d00aca8 <turnOffPWM+0x44>
9d00ac9c:	a3828109 	sb	v0,-32503(gp)
	{
    	T2CONCLR = TBCON_ON;
9d00aca0:	3c02bf80 	lui	v0,0xbf80
9d00aca4:	ac430804 	sw	v1,2052(v0)
9d00aca8:	03e00008 	jr	ra
9d00acac:	00000000 	nop

9d00acb0 <_board_init>:
**		that needs to be done when the processor comes out of
**		reset and before the user sketch is run.
*/
#if	(OPT_BOARD_INIT != 0)

void _board_init(void) {
9d00acb0:	27bdffe8 	addiu	sp,sp,-24
9d00acb4:	afbf0014 	sw	ra,20(sp)
	// ocsilator pins as general I/O
	
	unsigned int dma_status;
	unsigned int int_status;
	
		mSYSTEMUnlock(int_status, dma_status);
9d00acb8:	0f403642 	jal	9d00d908 <INTDisableInterrupts>
9d00acbc:	00000000 	nop
	 * Example:         int susp=DmaSuspend();
	 ********************************************************************/
        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
	{
		int suspSt;
		if(!(suspSt=DMACONbits.SUSPEND))
9d00acc0:	3c03bf88 	lui	v1,0xbf88
9d00acc4:	8c643000 	lw	a0,12288(v1)
9d00acc8:	7c840300 	ext	a0,a0,0xc,0x1
9d00accc:	1480001c 	bnez	a0,9d00ad40 <_board_init+0x90>
9d00acd0:	3c04aa99 	lui	a0,0xaa99
		{
			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9d00acd4:	24051000 	li	a1,4096
9d00acd8:	3c04bf88 	lui	a0,0xbf88
9d00acdc:	ac853008 	sw	a1,12296(a0)
			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9d00ace0:	8c653000 	lw	a1,12288(v1)
9d00ace4:	30a50800 	andi	a1,a1,0x800
9d00ace8:	14a0fffd 	bnez	a1,9d00ace0 <_board_init+0x30>
9d00acec:	3c04aa99 	lui	a0,0xaa99
9d00acf0:	3c03bf81 	lui	v1,0xbf81
9d00acf4:	24846655 	addiu	a0,a0,26197
9d00acf8:	ac60f230 	sw	zero,-3536(v1)
9d00acfc:	ac64f230 	sw	a0,-3536(v1)
9d00ad00:	3c045566 	lui	a0,0x5566
9d00ad04:	348499aa 	ori	a0,a0,0x99aa
9d00ad08:	ac64f230 	sw	a0,-3536(v1)

		OSCCONCLR	=	_OSCCON_SOSCEN_MASK;
9d00ad0c:	24050002 	li	a1,2
9d00ad10:	3c04bf81 	lui	a0,0xbf81
9d00ad14:	ac85f004 	sw	a1,-4092(a0)


		mSYSTEMLock(int_status, dma_status);
9d00ad18:	3c043333 	lui	a0,0x3333
9d00ad1c:	24843333 	addiu	a0,a0,13107
9d00ad20:	ac64f230 	sw	a0,-3536(v1)
		{
			DmaSuspend();
		}
		else
		{
			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9d00ad24:	24041000 	li	a0,4096
9d00ad28:	3c03bf88 	lui	v1,0xbf88
9d00ad2c:	ac643004 	sw	a0,12292(v1)
	
}
9d00ad30:	8fbf0014 	lw	ra,20(sp)
		mSYSTEMUnlock(int_status, dma_status);

		OSCCONCLR	=	_OSCCON_SOSCEN_MASK;


		mSYSTEMLock(int_status, dma_status);
9d00ad34:	00402021 	move	a0,v0
9d00ad38:	0b403644 	j	9d00d910 <INTRestoreInterrupts>
9d00ad3c:	27bd0018 	addiu	sp,sp,24
	// ocsilator pins as general I/O
	
	unsigned int dma_status;
	unsigned int int_status;
	
		mSYSTEMUnlock(int_status, dma_status);
9d00ad40:	3c05bf81 	lui	a1,0xbf81
9d00ad44:	24846655 	addiu	a0,a0,26197
9d00ad48:	aca0f230 	sw	zero,-3536(a1)
9d00ad4c:	aca4f230 	sw	a0,-3536(a1)
9d00ad50:	3c045566 	lui	a0,0x5566
9d00ad54:	348499aa 	ori	a0,a0,0x99aa
9d00ad58:	aca4f230 	sw	a0,-3536(a1)

		OSCCONCLR	=	_OSCCON_SOSCEN_MASK;
9d00ad5c:	24060002 	li	a2,2
9d00ad60:	3c04bf81 	lui	a0,0xbf81
9d00ad64:	ac86f004 	sw	a2,-4092(a0)


		mSYSTEMLock(int_status, dma_status);
9d00ad68:	3c043333 	lui	a0,0x3333
9d00ad6c:	24843333 	addiu	a0,a0,13107
9d00ad70:	aca4f230 	sw	a0,-3536(a1)
	 * Example:         int susp=DmaSuspend();
	 ********************************************************************/
        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
	{
		int suspSt;
		if(!(suspSt=DMACONbits.SUSPEND))
9d00ad74:	8c643000 	lw	a0,12288(v1)
9d00ad78:	7c840300 	ext	a0,a0,0xc,0x1
9d00ad7c:	1480ffec 	bnez	a0,9d00ad30 <_board_init+0x80>
9d00ad80:	24051000 	li	a1,4096
		{
			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9d00ad84:	3c04bf88 	lui	a0,0xbf88
9d00ad88:	ac853008 	sw	a1,12296(a0)
			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9d00ad8c:	8c653000 	lw	a1,12288(v1)
9d00ad90:	30a50800 	andi	a1,a1,0x800
9d00ad94:	14a0fffd 	bnez	a1,9d00ad8c <_board_init+0xdc>
9d00ad98:	8fbf0014 	lw	ra,20(sp)
9d00ad9c:	00402021 	move	a0,v0
9d00ada0:	0b403644 	j	9d00d910 <INTRestoreInterrupts>
9d00ada4:	27bd0018 	addiu	sp,sp,24

9d00ada8 <_ZN5Print5printEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d00ada8:	8c820000 	lw	v0,0(a0)
9d00adac:	8c590004 	lw	t9,4(v0)
9d00adb0:	03200008 	jr	t9
9d00adb4:	00000000 	nop

9d00adb8 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
{
9d00adb8:	27bdffc0 	addiu	sp,sp,-64
9d00adbc:	afb10038 	sw	s1,56(sp)
9d00adc0:	afb00034 	sw	s0,52(sp)
9d00adc4:	afbf003c 	sw	ra,60(sp)
9d00adc8:	00808021 	move	s0,a0
9d00adcc:	30c600ff 	andi	a2,a2,0xff
unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars.
unsigned long i = 0;

	if (n == 0)
9d00add0:	10a00020 	beqz	a1,9d00ae54 <_ZN5Print11printNumberEmh+0x9c>
9d00add4:	00008821 	move	s1,zero
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d00add8:	00a6001b 	divu	zero,a1,a2
9d00addc:	00c001f4 	teq	a2,zero,0x7
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d00ade0:	27a40010 	addiu	a0,sp,16
9d00ade4:	00911021 	addu	v0,a0,s1
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d00ade8:	26310001 	addiu	s1,s1,1
9d00adec:	00001810 	mfhi	v1
9d00adf0:	00002812 	mflo	a1
	{
		print('0');
		return;
	}

	while (n > 0)
9d00adf4:	14a0fff8 	bnez	a1,9d00add8 <_ZN5Print11printNumberEmh+0x20>
9d00adf8:	a0430000 	sb	v1,0(v0)
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d00adfc:	12200011 	beqz	s1,9d00ae44 <_ZN5Print11printNumberEmh+0x8c>
9d00ae00:	8fbf003c 	lw	ra,60(sp)
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d00ae04:	27a30010 	addiu	v1,sp,16
9d00ae08:	00711021 	addu	v0,v1,s1
		n /= base;
	}

	for (; i > 0; i--)
	{
		print((char) (buf[i - 1] < 10 ?
9d00ae0c:	9042ffff 	lbu	v0,-1(v0)
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
9d00ae10:	24450030 	addiu	a1,v0,48
9d00ae14:	2c43000a 	sltiu	v1,v0,10
9d00ae18:	7c052c20 	seb	a1,a1
9d00ae1c:	14600002 	bnez	v1,9d00ae28 <_ZN5Print11printNumberEmh+0x70>
9d00ae20:	24420037 	addiu	v0,v0,55
9d00ae24:	7c022c20 	seb	a1,v0
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d00ae28:	2631ffff 	addiu	s1,s1,-1
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00ae2c:	02002021 	move	a0,s0
9d00ae30:	0f402ba5 	jal	9d00ae94 <_ZN5Print5printEli>
9d00ae34:	00003021 	move	a2,zero
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d00ae38:	1620fff3 	bnez	s1,9d00ae08 <_ZN5Print11printNumberEmh+0x50>
9d00ae3c:	27a30010 	addiu	v1,sp,16
	{
		print((char) (buf[i - 1] < 10 ?
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
	}
}
9d00ae40:	8fbf003c 	lw	ra,60(sp)
9d00ae44:	8fb10038 	lw	s1,56(sp)
9d00ae48:	8fb00034 	lw	s0,52(sp)
9d00ae4c:	03e00008 	jr	ra
9d00ae50:	27bd0040 	addiu	sp,sp,64
9d00ae54:	8fbf003c 	lw	ra,60(sp)
9d00ae58:	8fb10038 	lw	s1,56(sp)
9d00ae5c:	8fb00034 	lw	s0,52(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00ae60:	24050030 	li	a1,48
9d00ae64:	00003021 	move	a2,zero
9d00ae68:	0b402ba5 	j	9d00ae94 <_ZN5Print5printEli>
9d00ae6c:	27bd0040 	addiu	sp,sp,64

9d00ae70 <_ZN5Print5printEmi>:
}

//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
9d00ae70:	50c00003 	beqzl	a2,9d00ae80 <_ZN5Print5printEmi+0x10>
9d00ae74:	8c830000 	lw	v1,0(a0)
	{
		write(n);
	}
	else
	{
		printNumber(n, base);
9d00ae78:	0b402b6e 	j	9d00adb8 <_ZN5Print11printNumberEmh>
9d00ae7c:	30c600ff 	andi	a2,a2,0xff
//************************************************************************
void Print::print(unsigned long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00ae80:	8c790000 	lw	t9,0(v1)
9d00ae84:	03200008 	jr	t9
9d00ae88:	30a500ff 	andi	a1,a1,0xff

9d00ae8c <_ZN5Print5printEhi>:
}

//************************************************************************
void Print::print(unsigned char b, int base)
{
	print((unsigned long) b, base);
9d00ae8c:	0b402b9c 	j	9d00ae70 <_ZN5Print5printEmi>
9d00ae90:	30a500ff 	andi	a1,a1,0xff

9d00ae94 <_ZN5Print5printEli>:
	print((unsigned long) n, base);
}

//************************************************************************
void Print::print(long n, int base)
{
9d00ae94:	27bdffe0 	addiu	sp,sp,-32
9d00ae98:	afb10018 	sw	s1,24(sp)
9d00ae9c:	afb00014 	sw	s0,20(sp)
9d00aea0:	afbf001c 	sw	ra,28(sp)
9d00aea4:	00808821 	move	s1,a0
	if (base == 0)
9d00aea8:	10c00013 	beqz	a2,9d00aef8 <_ZN5Print5printEli+0x64>
9d00aeac:	00a08021 	move	s0,a1
	{
		write(n);
	}
	else if (base == 10)
9d00aeb0:	2402000a 	li	v0,10
9d00aeb4:	10c20006 	beq	a2,v0,9d00aed0 <_ZN5Print5printEli+0x3c>
9d00aeb8:	8fbf001c 	lw	ra,28(sp)
	}
	else
	{
		printNumber(n, base);
	}
}
9d00aebc:	8fb10018 	lw	s1,24(sp)
9d00aec0:	8fb00014 	lw	s0,20(sp)
		}
		printNumber(n, 10);
	}
	else
	{
		printNumber(n, base);
9d00aec4:	30c600ff 	andi	a2,a2,0xff
9d00aec8:	0b402b6e 	j	9d00adb8 <_ZN5Print11printNumberEmh>
9d00aecc:	27bd0020 	addiu	sp,sp,32
	{
		write(n);
	}
	else if (base == 10)
	{
		if (n < 0)
9d00aed0:	04a00011 	bltz	a1,9d00af18 <_ZN5Print5printEli+0x84>
9d00aed4:	2405002d 	li	a1,45
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d00aed8:	02202021 	move	a0,s1
9d00aedc:	02002821 	move	a1,s0
	}
	else
	{
		printNumber(n, base);
	}
}
9d00aee0:	8fbf001c 	lw	ra,28(sp)
9d00aee4:	8fb10018 	lw	s1,24(sp)
9d00aee8:	8fb00014 	lw	s0,20(sp)
		if (n < 0)
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d00aeec:	2406000a 	li	a2,10
	}
	else
	{
		printNumber(n, base);
9d00aef0:	0b402b6e 	j	9d00adb8 <_ZN5Print11printNumberEmh>
9d00aef4:	27bd0020 	addiu	sp,sp,32
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00aef8:	8c820000 	lw	v0,0(a0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d00aefc:	8fbf001c 	lw	ra,28(sp)
9d00af00:	8fb10018 	lw	s1,24(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00af04:	8c590000 	lw	t9,0(v0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d00af08:	8fb00014 	lw	s0,20(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00af0c:	30a500ff 	andi	a1,a1,0xff
9d00af10:	03200008 	jr	t9
9d00af14:	27bd0020 	addiu	sp,sp,32
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00af18:	0f402ba5 	jal	9d00ae94 <_ZN5Print5printEli>
9d00af1c:	00003021 	move	a2,zero
	else if (base == 10)
	{
		if (n < 0)
		{
			print('-');
			n = -n;
9d00af20:	0b402bb6 	j	9d00aed8 <_ZN5Print5printEli+0x44>
9d00af24:	00108023 	negu	s0,s0

9d00af28 <_ZN5Print7printlnEv>:
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d00af28:	27bdffe8 	addiu	sp,sp,-24
9d00af2c:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00af30:	2405000d 	li	a1,13
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d00af34:	00808021 	move	s0,a0
9d00af38:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00af3c:	0f402ba5 	jal	9d00ae94 <_ZN5Print5printEli>
9d00af40:	00003021 	move	a2,zero
9d00af44:	02002021 	move	a0,s0
//************************************************************************
void Print::println(void)
{
	print('\r');
	print('\n');
}
9d00af48:	8fbf0014 	lw	ra,20(sp)
9d00af4c:	8fb00010 	lw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00af50:	2405000a 	li	a1,10
9d00af54:	00003021 	move	a2,zero
9d00af58:	0b402ba5 	j	9d00ae94 <_ZN5Print5printEli>
9d00af5c:	27bd0018 	addiu	sp,sp,24

9d00af60 <_ZN5Print7printlnEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d00af60:	8c820000 	lw	v0,0(a0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d00af64:	27bdffe8 	addiu	sp,sp,-24
9d00af68:	afbf0014 	sw	ra,20(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d00af6c:	8c420004 	lw	v0,4(v0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d00af70:	afb00010 	sw	s0,16(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d00af74:	0040f809 	jalr	v0
9d00af78:	00808021 	move	s0,a0
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d00af7c:	02002021 	move	a0,s0
}
9d00af80:	8fbf0014 	lw	ra,20(sp)
9d00af84:	8fb00010 	lw	s0,16(sp)
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d00af88:	0b402bca 	j	9d00af28 <_ZN5Print7printlnEv>
9d00af8c:	27bd0018 	addiu	sp,sp,24

9d00af90 <main>:
__attribute__((section(".comment"))) void (*__use_force_isr_install)(void) = &__use_isr_install;
}

//************************************************************************
int main(void)
{
9d00af90:	27bdffe8 	addiu	sp,sp,-24
9d00af94:	afbf0014 	sw	ra,20(sp)
	init();
9d00af98:	0f402d26 	jal	9d00b498 <init>
9d00af9c:	00000000 	nop

	setup();
9d00afa0:	0f4004d7 	jal	9d00135c <setup>
9d00afa4:	00000000 	nop

	while (1)
	{
		_scheduleTask();
9d00afa8:	0f402d61 	jal	9d00b584 <_scheduleTask>
9d00afac:	00000000 	nop
		loop();
9d00afb0:	0f4004eb 	jal	9d0013ac <loop>
9d00afb4:	00000000 	nop
9d00afb8:	0b402bea 	j	9d00afa8 <main+0x18>
9d00afbc:	00000000 	nop

9d00afc0 <initIntVector>:
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;
9d00afc0:	3c029d01 	lui	v0,0x9d01
9d00afc4:	2442dae8 	addiu	v0,v0,-9496
9d00afc8:	88430043 	lwl	v1,67(v0)
9d00afcc:	8846004b 	lwl	a2,75(v0)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d00afd0:	3c08a000 	lui	t0,0xa000
*/
void initIntVector(void)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;
9d00afd4:	98430040 	lwr	v1,64(v0)
9d00afd8:	98460048 	lwr	a2,72(v0)

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d00afdc:	2409ffff 	li	t1,-1
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d00afe0:	00001021 	move	v0,zero
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d00afe4:	25080008 	addiu	t0,t0,8
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d00afe8:	24070034 	li	a3,52
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d00afec:	8c640000 	lw	a0,0(v1)
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d00aff0:	00022880 	sll	a1,v0,0x2
9d00aff4:	00a82821 	addu	a1,a1,t0

    for(i=0; i<NUM_INT_VECTOR; i++)
    {
        // If a compiler installed interrupt handler exits, pre-load it
        // and don't fool with the priority
        if(*((uint32_t *) pvOrgIntVec) != 0xFFFFFFFF)
9d00aff8:	10890002 	beq	a0,t1,9d00b004 <initIntVector+0x44>
9d00affc:	24420001 	addiu	v0,v0,1
        {
            _isr_primary_install[i] = (isrFunc) pvOrgIntVec;
9d00b000:	aca30000 	sw	v1,0(a1)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    int i = 0;
    void * pvOrgIntVec = pImageHeader->pOrgVector0;

    for(i=0; i<NUM_INT_VECTOR; i++)
9d00b004:	1447fff9 	bne	v0,a3,9d00afec <initIntVector+0x2c>
9d00b008:	00661821 	addu	v1,v1,a2
9d00b00c:	03e00008 	jr	ra
9d00b010:	00000000 	nop

9d00b014 <setIntVector>:
isrFunc setIntVector(int vec, isrFunc func)
{
    const IMAGE_HEADER_INFO * pImageHeader = getImageHeaderInfoStructure();
    isrFunc t = 0;

    if (vec < NUM_INT_VECTOR)
9d00b014:	28830034 	slti	v1,a0,52
9d00b018:	10600007 	beqz	v1,9d00b038 <setIntVector+0x24>
9d00b01c:	00001021 	move	v0,zero
    {
        t = _isr_primary_install[vec];
9d00b020:	3c02a000 	lui	v0,0xa000
9d00b024:	24420008 	addiu	v0,v0,8
9d00b028:	00042080 	sll	a0,a0,0x2
9d00b02c:	00822021 	addu	a0,a0,v0
9d00b030:	8c820000 	lw	v0,0(a0)
        _isr_primary_install[vec] = func;       
9d00b034:	ac850000 	sw	a1,0(a0)
    }

    return t;
}
9d00b038:	03e00008 	jr	ra
9d00b03c:	00000000 	nop

9d00b040 <setIntEnable>:
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d00b040:	28830000 	slti	v1,a0,0
9d00b044:	2482001f 	addiu	v0,a0,31
9d00b048:	0083100a 	movz	v0,a0,v1
9d00b04c:	00021143 	sra	v0,v0,0x5
9d00b050:	3c03bf88 	lui	v1,0xbf88
9d00b054:	00021100 	sll	v0,v0,0x4
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d00b058:	24050001 	li	a1,1
uint32_t setIntEnable(int irq)
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
9d00b05c:	24631060 	addiu	v1,v1,4192
9d00b060:	00621821 	addu	v1,v1,v0
	st = iec->reg;
	iec->set = 1 << (irq % 32);
9d00b064:	00852004 	sllv	a0,a1,a0
{
	p32_regset *	iec;
	uint32_t		st;

	iec = ((p32_regset *)&IEC0) + (irq / 32);
	st = iec->reg;
9d00b068:	8c620000 	lw	v0,0(v1)
	iec->set = 1 << (irq % 32);
9d00b06c:	ac640008 	sw	a0,8(v1)
	return st;
}
9d00b070:	03e00008 	jr	ra
9d00b074:	00000000 	nop

9d00b078 <setIntPriority>:
	ipc = ((p32_regset *)&IPC0) + (vec / 4);

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d00b078:	000417c3 	sra	v0,a0,0x1f
9d00b07c:	00021782 	srl	v0,v0,0x1e
9d00b080:	00821821 	addu	v1,a0,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d00b084:	24870003 	addiu	a3,a0,3
9d00b088:	28880000 	slti	t0,a0,0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d00b08c:	30630003 	andi	v1,v1,0x3
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d00b090:	00e8200b 	movn	a0,a3,t0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d00b094:	00621023 	subu	v0,v1,v0
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d00b098:	00042083 	sra	a0,a0,0x2
9d00b09c:	3c03bf88 	lui	v1,0xbf88
9d00b0a0:	24631090 	addiu	v1,v1,4240
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d00b0a4:	00052880 	sll	a1,a1,0x2
	int				bn;

	/* Compute the address of the interrupt priority control register used
	** by this interrupt vector
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);
9d00b0a8:	00042100 	sll	a0,a0,0x4
9d00b0ac:	00642021 	addu	a0,v1,a0

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this vector.
	*/
	bn = 8 * (vec % 4);
9d00b0b0:	000210c0 	sll	v0,v0,0x3

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
	ipc->set = ((ipl << 2) + spl) << bn;
9d00b0b4:	00c52821 	addu	a1,a2,a1
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d00b0b8:	2403001f 	li	v1,31
9d00b0bc:	00431804 	sllv	v1,v1,v0
	ipc->set = ((ipl << 2) + spl) << bn;
9d00b0c0:	00451004 	sllv	v0,a1,v0
	*/
	bn = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = (0x1F << bn);
9d00b0c4:	ac830004 	sw	v1,4(a0)
	ipc->set = ((ipl << 2) + spl) << bn;
9d00b0c8:	ac820008 	sw	v0,8(a0)
}
9d00b0cc:	03e00008 	jr	ra
9d00b0d0:	00000000 	nop

9d00b0d4 <getPeripheralClock>:
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d00b0d4:	3c02bf81 	lui	v0,0xbf81
9d00b0d8:	8c43f000 	lw	v1,-4096(v0)

    return clkPb;

}
9d00b0dc:	3c0204c4 	lui	v0,0x4c4
9d00b0e0:	3442b400 	ori	v0,v0,0xb400
uint32_t getPeripheralClock()
{
	uint32_t	clkPb;

    clkPb = F_CPU;
    clkPb >>= OSCCONbits.PBDIV;
9d00b0e4:	7c630cc0 	ext	v1,v1,0x13,0x2

    return clkPb;

}
9d00b0e8:	03e00008 	jr	ra
9d00b0ec:	00621006 	srlv	v0,v0,v1

9d00b0f0 <_configSystem>:

uint32_t __attribute__((nomips16)) disableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("di    %0" : "=r"(status));
9d00b0f0:	41686000 	di	t0

	stInt = disableInterrupts();

	/* Disable wait states in data ram.
	*/
	BMXCONCLR = (1 << _BMXCON_BMXWSDRM_POSITION);
9d00b0f4:	24030040 	li	v1,64
9d00b0f8:	3c02bf88 	lui	v0,0xbf88
9d00b0fc:	ac432004 	sw	v1,8196(v0)

#ifdef _PCACHE

	stCache = CHECON;
9d00b100:	3c07bf88 	lui	a3,0xbf88
9d00b104:	8ce94000 	lw	t1,16384(a3)
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d00b108:	2402fff8 	li	v0,-8
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
9d00b10c:	40038000 	mfc0	v1,c0_config
	tmp = (tmp & ~7) | 3;
9d00b110:	00621024 	and	v0,v1,v0
	stCache = CHECON;

	/* Configure predictive prefetch caching for both cached and
	** non-cached memory regions.
	*/
    stCache |= (3 << _CHECON_PREFEN_POSITION);
9d00b114:	35290030 	ori	t1,t1,0x30

	/* Turn on caching for KSEG0
	*/
	asm("mfc0 %0,$16,0" :  "=r"(tmp));
	tmp = (tmp & ~7) | 3;
9d00b118:	34420003 	ori	v0,v0,0x3
	asm("mtc0 %0,$16,0" :: "r" (tmp));
9d00b11c:	40828000 	mtc0	v0,c0_config

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d00b120:	3c0501c9 	lui	a1,0x1c9
9d00b124:	34a5c381 	ori	a1,a1,0xc381
9d00b128:	0085182b 	sltu	v1,a0,a1
9d00b12c:	14600007 	bnez	v1,9d00b14c <_configSystem+0x5c>
9d00b130:	00001021 	move	v0,zero
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
9d00b134:	3c06fe36 	lui	a2,0xfe36
9d00b138:	24c63c80 	addiu	a2,a2,15488
9d00b13c:	00862021 	addu	a0,a0,a2

	/* Configure the number of wait states in the program flash
	*/
    wait = 0;

    while(clk > FLASH_SPEED_HZ)
9d00b140:	0085182b 	sltu	v1,a0,a1
9d00b144:	1060fffd 	beqz	v1,9d00b13c <_configSystem+0x4c>
9d00b148:	24420001 	addiu	v0,v0,1
    {
        wait += 1;
        clk -= FLASH_SPEED_HZ;
    }

    stCache &= ~_CHECON_PFMWS_MASK;
9d00b14c:	2404fff8 	li	a0,-8
9d00b150:	01241824 	and	v1,t1,a0
	stCache |= (wait << _CHECON_PFMWS_POSITION);
9d00b154:	00431025 	or	v0,v0,v1
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d00b158:	31030001 	andi	v1,t0,0x1
    }

    stCache &= ~_CHECON_PFMWS_MASK;
	stCache |= (wait << _CHECON_PFMWS_POSITION);

	CHECON = stCache;
9d00b15c:	14600003 	bnez	v1,9d00b16c <_configSystem+0x7c>
**		enableInterrupts() or disableInterrupts().
*/

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
9d00b160:	ace24000 	sw	v0,16384(a3)
	{
        asm volatile("ei");
	}
    else
	{
        asm volatile("di");
9d00b164:	03e00008 	jr	ra
9d00b168:	41606000 	di

void __attribute__((nomips16))  restoreInterrupts(uint32_t st)
{
    if (st & 0x00000001)
	{
        asm volatile("ei");
9d00b16c:	03e00008 	jr	ra
9d00b170:	41606020 	ei

9d00b174 <_enableMultiVectorInterrupts>:
    unsigned int val;

    /* Set the CP0 bit so that interrupt exceptions use the
	** special interrupt vector and not the general exception vector.
	*/
    asm volatile("mfc0   %0,$13" : "=r"(val));
9d00b174:	40036800 	mfc0	v1,c0_cause
    val |= 0x00800000;
9d00b178:	3c020080 	lui	v0,0x80
9d00b17c:	00621025 	or	v0,v1,v0
    asm volatile("mtc0   %0,$13" : "+r"(val));
9d00b180:	40826800 	mtc0	v0,c0_cause

	/* Turn on multi-vectored interrupts.
	*/
    INTCONSET = _INTCON_MVEC_MASK;
9d00b184:	24031000 	li	v1,4096
9d00b188:	3c02bf88 	lui	v0,0xbf88
9d00b18c:	ac431008 	sw	v1,4104(v0)

uint32_t __attribute__((nomips16))  enableInterrupts(void)
{
    uint32_t status = 0;

    asm volatile("ei    %0" : "=r"(status));
9d00b190:	03e00008 	jr	ra

    /* Enable interrupts.
	*/
    enableInterrupts();

}
9d00b194:	41626020 	ei	v0

9d00b198 <_initCoreTimer>:

void __attribute__((nomips16)) _initCoreTimer(uint32_t prd)
{
	/* Clear the core timer counter
	*/
    asm volatile("mtc0   $0,$9");
9d00b198:	40804800 	mtc0	zero,c0_count

    /* Store the requested value in the compare register
	*/
    asm volatile("mtc0   %0,$11" : "+r"(prd));
9d00b19c:	03e00008 	jr	ra
}
9d00b1a0:	40845800 	mtc0	a0,c0_compare

9d00b1a4 <millisecondCoreTimerService>:
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static nextInt = 0;
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
9d00b1a4:	8f858118 	lw	a1,-32488(gp)
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility
9d00b1a8:	8f83810c 	lw	v1,-32500(gp)
**
*/
uint32_t millisecondCoreTimerService(uint32_t curTime)
{
    static nextInt = 0;
    uint32_t relWait = 0;
9d00b1ac:	00001021 	move	v0,zero
    uint32_t relTime = curTime - nextInt;
9d00b1b0:	00852023 	subu	a0,a0,a1

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
    {
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
9d00b1b4:	34079c40 	li	a3,0x9c40
9d00b1b8:	00471021 	addu	v0,v0,a3
    uint32_t relWait = 0;
    uint32_t relTime = curTime - nextInt;
    uint32_t millisLocal = gTimer0_millis;  // defeat volatility

    // catch-up up to current time; we may have fallen behind due to interrupts being diabled.
    while(relWait <= relTime)
9d00b1bc:	0082302b 	sltu	a2,a0,v0
9d00b1c0:	10c0fffd 	beqz	a2,9d00b1b8 <millisecondCoreTimerService+0x14>
9d00b1c4:	24630001 	addiu	v1,v1,1
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d00b1c8:	00451021 	addu	v0,v0,a1

    // we want to sync gCore_timer_last_val with the last millisecond "count" value
    // curTime may not be exactly on a millisecond boundary, but we know where that is
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;
9d00b1cc:	34049c40 	li	a0,0x9c40
9d00b1d0:	00442023 	subu	a0,v0,a0
9d00b1d4:	af848110 	sw	a0,-32496(gp)
        millisLocal++;                      // add a ms to our time
        relWait += CORE_TICK_RATE;          // add a ms to our next ISR time
     }

    // set when we want to be called again
    nextInt += relWait;                     // calculate the absolute interrupt time we want.
9d00b1d8:	af828118 	sw	v0,-32488(gp)
    // we know nextInt is our next millisecond boundary, so less 1 CORE_TICK_RATE will be our last one
    // gCore_timer_last_val = curTime;         // This is the original bogus code
    gCore_timer_last_val =  nextInt - CORE_TICK_RATE;

    // update the global millisecond counter.
    gTimer0_millis = millisLocal;           // Total number of ms
9d00b1dc:	af83810c 	sw	v1,-32500(gp)

    return(nextInt);
}
9d00b1e0:	03e00008 	jr	ra
9d00b1e4:	00000000 	nop

9d00b1e8 <CoreTimerHandler>:
**      each service's logical compare values. And then the next and soonest logical compare value is searched for and set as
**      the real compare value to be interrupted to notify the Serivces when count hits that value.
**
*/
void __attribute__((interrupt(),nomips16)) CoreTimerHandler(void)
{
9d00b1e8:	415de800 	rdpgpr	sp,sp
9d00b1ec:	401b7000 	mfc0	k1,c0_epc
9d00b1f0:	401a6002 	mfc0	k0,c0_srsctl
9d00b1f4:	27bdff58 	addiu	sp,sp,-168
9d00b1f8:	afbb00a4 	sw	k1,164(sp)
9d00b1fc:	401b6000 	mfc0	k1,c0_status
9d00b200:	afba00a0 	sw	k0,160(sp)
9d00b204:	401a6800 	mfc0	k0,c0_cause
9d00b208:	001ad282 	srl	k0,k0,0xa
9d00b20c:	afbb009c 	sw	k1,156(sp)
9d00b210:	7f5b7a84 	ins	k1,k0,0xa,0x6
9d00b214:	7c1b2044 	ins	k1,zero,0x1,0x4
9d00b218:	409b6000 	mtc0	k1,c0_status
9d00b21c:	afa3002c 	sw	v1,44(sp)
9d00b220:	8fa300a0 	lw	v1,160(sp)
9d00b224:	3063000f 	andi	v1,v1,0xf
9d00b228:	1460001a 	bnez	v1,9d00b294 <CoreTimerHandler+0xac>
9d00b22c:	afa20028 	sw	v0,40(sp)
9d00b230:	afbf008c 	sw	ra,140(sp)
9d00b234:	afbe0088 	sw	s8,136(sp)
9d00b238:	afb90084 	sw	t9,132(sp)
9d00b23c:	afb80080 	sw	t8,128(sp)
9d00b240:	afb7007c 	sw	s7,124(sp)
9d00b244:	afb60078 	sw	s6,120(sp)
9d00b248:	afb50074 	sw	s5,116(sp)
9d00b24c:	afb40070 	sw	s4,112(sp)
9d00b250:	afb3006c 	sw	s3,108(sp)
9d00b254:	afb20068 	sw	s2,104(sp)
9d00b258:	afb10064 	sw	s1,100(sp)
9d00b25c:	afb00060 	sw	s0,96(sp)
9d00b260:	afaf005c 	sw	t7,92(sp)
9d00b264:	afae0058 	sw	t6,88(sp)
9d00b268:	afad0054 	sw	t5,84(sp)
9d00b26c:	afac0050 	sw	t4,80(sp)
9d00b270:	afab004c 	sw	t3,76(sp)
9d00b274:	afaa0048 	sw	t2,72(sp)
9d00b278:	afa90044 	sw	t1,68(sp)
9d00b27c:	afa80040 	sw	t0,64(sp)
9d00b280:	afa7003c 	sw	a3,60(sp)
9d00b284:	afa60038 	sw	a2,56(sp)
9d00b288:	afa50034 	sw	a1,52(sp)
9d00b28c:	afa40030 	sw	a0,48(sp)
9d00b290:	afa10024 	sw	at,36(sp)
9d00b294:	00001012 	mflo	v0
9d00b298:	afa20094 	sw	v0,148(sp)
9d00b29c:	00001810 	mfhi	v1
9d00b2a0:	afa30090 	sw	v1,144(sp)

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d00b2a4:	40134800 	mfc0	s3,c0_count
    relCurTime = curTime - gLastBaseCount;
9d00b2a8:	8f9e8114 	lw	s8,-32492(gp)
9d00b2ac:	3c10a000 	lui	s0,0xa000
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00b2b0:	3c05a000 	lui	a1,0xa000
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d00b2b4:	027ef023 	subu	s8,s3,s8

    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
9d00b2b8:	02603021 	move	a2,s3
9d00b2bc:	261000dc 	addiu	s0,s0,220
9d00b2c0:	3c12bf88 	lui	s2,0xbf88
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00b2c4:	24a500d8 	addiu	a1,a1,216
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d00b2c8:	24030003 	li	v1,3
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
        write_comp(compare); 

        // clear the CT flag
        mCTClearIntFlag();
9d00b2cc:	24110001 	li	s1,1
    // we know that count >= compare, otherwise we would not have been interrupted
    // we also know that count and compare >= gLastBaseCount as this was our last count value.

    // get our current time; this will establish our next base
    read_count(curTime); 
    relCurTime = curTime - gLastBaseCount;
9d00b2d0:	0200b021 	move	s6,s0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d00b2d4:	0000a021 	move	s4,zero
    nextBase = curTime;

    do
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;
9d00b2d8:	2415ffff 	li	s5,-1

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d00b2dc:	8ec20000 	lw	v0,0(s6)
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00b2e0:	0014b8c0 	sll	s7,s4,0x3
9d00b2e4:	02e5b821 	addu	s7,s7,a1
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d00b2e8:	26940001 	addiu	s4,s4,1
        {
            // if the serivce exists
            if(gCoreTimerInfo[i].serivce != NULL)
9d00b2ec:	10400009 	beqz	v0,9d00b314 <CoreTimerHandler+0x12c>
9d00b2f0:	26d60008 	addiu	s6,s6,8
            {
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00b2f4:	8ee70000 	lw	a3,0(s7)
9d00b2f8:	8f848114 	lw	a0,-32492(gp)
9d00b2fc:	00e42023 	subu	a0,a3,a0
                if(relInt <= relCurTime)
9d00b300:	03c4382b 	sltu	a3,s8,a0
9d00b304:	50e0003d 	beqzl	a3,9d00b3fc <CoreTimerHandler+0x214>
9d00b308:	00c02021 	move	a0,a2
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d00b30c:	0095102b 	sltu	v0,a0,s5
9d00b310:	0082a80b 	movn	s5,a0,v0
    {
        // make sure we find the lowest int to set
        relNextInt = 0xFFFFFFFF;

        // check to see who all we need to call
        for(i=0; i<MaxNbrOfCoreTimerServices; i++)
9d00b314:	5683fff2 	bnel	s4,v1,9d00b2e0 <CoreTimerHandler+0xf8>
9d00b318:	8ec20000 	lw	v0,0(s6)
        // other service may cause the compare value to be set for an earlier time; but we always know there will be a compare time
        // to set, so we know that relNextInt has a value other than 0xFFFFFFFF in it.

        // Go ahead and set the compare register to the next interrupt we want.
        // we need to apply our base to convert from relative values to an absolute time.
        compare = relNextInt + gLastBaseCount;
9d00b31c:	8f828114 	lw	v0,-32492(gp)
9d00b320:	02a21021 	addu	v0,s5,v0
        write_comp(compare); 
9d00b324:	40825800 	mtc0	v0,c0_compare

        // clear the CT flag
        mCTClearIntFlag();
9d00b328:	ae511034 	sw	s1,4148(s2)

        // read the count after the CT flag has been set so we can make sure count has not passed compare
        // during our processing of this int
        read_count(curTime); 
9d00b32c:	40064800 	mfc0	a2,c0_count

        // get the relative time so we can operate in the linear portion of our uint32.
        relCurTime = curTime - gLastBaseCount;
9d00b330:	8f9e8114 	lw	s8,-32492(gp)
9d00b334:	00def023 	subu	s8,a2,s8

        // if the current time has passed our interrupt time, then we basically hit the interrupt again
        // so we probabaly missed the CT flag being set and we need to reprocess this interrupt and find the next one to set.
    } while(relNextInt <= relCurTime);
9d00b338:	03d5a82b 	sltu	s5,s8,s5
9d00b33c:	52a0ffe5 	beqzl	s5,9d00b2d4 <CoreTimerHandler+0xec>
9d00b340:	0200b021 	move	s6,s0
    // otherwise the next interrupt time (compare time) is after the current time and CT will catch it when count == compare.
    // we can safely exit the ISR.

    // but first we must set our new base so the next time we come into this routine we
    // have a valid lower base to shift our times to for comparisons.
    gLastBaseCount = nextBase;
9d00b344:	af938114 	sw	s3,-32492(gp)
}
9d00b348:	8fa20094 	lw	v0,148(sp)
9d00b34c:	8fa30090 	lw	v1,144(sp)
9d00b350:	00400013 	mtlo	v0
9d00b354:	8fa200a0 	lw	v0,160(sp)
9d00b358:	3042000f 	andi	v0,v0,0xf
9d00b35c:	1440001c 	bnez	v0,9d00b3d0 <CoreTimerHandler+0x1e8>
9d00b360:	00600011 	mthi	v1
9d00b364:	8fbf008c 	lw	ra,140(sp)
9d00b368:	8fbe0088 	lw	s8,136(sp)
9d00b36c:	8fb90084 	lw	t9,132(sp)
9d00b370:	8fb80080 	lw	t8,128(sp)
9d00b374:	8fb7007c 	lw	s7,124(sp)
9d00b378:	8fb60078 	lw	s6,120(sp)
9d00b37c:	8fb50074 	lw	s5,116(sp)
9d00b380:	8fb40070 	lw	s4,112(sp)
9d00b384:	8fb3006c 	lw	s3,108(sp)
9d00b388:	8fb20068 	lw	s2,104(sp)
9d00b38c:	8fb10064 	lw	s1,100(sp)
9d00b390:	8fb00060 	lw	s0,96(sp)
9d00b394:	8faf005c 	lw	t7,92(sp)
9d00b398:	8fae0058 	lw	t6,88(sp)
9d00b39c:	8fad0054 	lw	t5,84(sp)
9d00b3a0:	8fac0050 	lw	t4,80(sp)
9d00b3a4:	8fab004c 	lw	t3,76(sp)
9d00b3a8:	8faa0048 	lw	t2,72(sp)
9d00b3ac:	8fa90044 	lw	t1,68(sp)
9d00b3b0:	8fa80040 	lw	t0,64(sp)
9d00b3b4:	8fa7003c 	lw	a3,60(sp)
9d00b3b8:	8fa60038 	lw	a2,56(sp)
9d00b3bc:	8fa50034 	lw	a1,52(sp)
9d00b3c0:	8fa40030 	lw	a0,48(sp)
9d00b3c4:	8fa3002c 	lw	v1,44(sp)
9d00b3c8:	8fa20028 	lw	v0,40(sp)
9d00b3cc:	8fa10024 	lw	at,36(sp)
9d00b3d0:	41606000 	di
9d00b3d4:	000000c0 	ehb
9d00b3d8:	8fba00a4 	lw	k0,164(sp)
9d00b3dc:	8fbb009c 	lw	k1,156(sp)
9d00b3e0:	409a7000 	mtc0	k0,c0_epc
9d00b3e4:	8fba00a0 	lw	k0,160(sp)
9d00b3e8:	27bd00a8 	addiu	sp,sp,168
9d00b3ec:	409a6002 	mtc0	k0,c0_srsctl
9d00b3f0:	41dde800 	wrpgpr	sp,sp
9d00b3f4:	409b6000 	mtc0	k1,c0_status
9d00b3f8:	42000018 	eret
                // if their time has come up
                relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
                if(relInt <= relCurTime)
                {
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);
9d00b3fc:	afa30018 	sw	v1,24(sp)
9d00b400:	afa50014 	sw	a1,20(sp)
9d00b404:	0040f809 	jalr	v0
9d00b408:	afa60010 	sw	a2,16(sp)
9d00b40c:	aee20000 	sw	v0,0(s7)

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00b410:	8ee40000 	lw	a0,0(s7)
9d00b414:	8f828114 	lw	v0,-32492(gp)
9d00b418:	8fa60010 	lw	a2,16(sp)
9d00b41c:	8fa50014 	lw	a1,20(sp)
9d00b420:	00822023 	subu	a0,a0,v0
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d00b424:	0095102b 	sltu	v0,a0,s5
                    // call their routine to get their next interrupt time
                    gCoreTimerInfo[i].nextInt = gCoreTimerInfo[i].serivce(curTime);

                    // recalculate the relative time of thier next int
                    // so we can see if this is the next int we need to set
                    relInt = gCoreTimerInfo[i].nextInt - gLastBaseCount;
9d00b428:	8fa30018 	lw	v1,24(sp)
                }

                // see if this is the next interrupt we want to set
                // we are looking for the closest/lowest int to set.
                if(relInt < relNextInt)
9d00b42c:	0b402cc5 	j	9d00b314 <CoreTimerHandler+0x12c>
9d00b430:	0082a80b 	movn	s5,a0,v0

9d00b434 <millis>:
uint8_t ppsGlobalLock = false;

//************************************************************************
unsigned long millis()
{
	return(gTimer0_millis);
9d00b434:	8f82810c 	lw	v0,-32500(gp)
}
9d00b438:	03e00008 	jr	ra
9d00b43c:	00000000 	nop

9d00b440 <delay>:
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d00b440:	27bdffe0 	addiu	sp,sp,-32
9d00b444:	afb10018 	sw	s1,24(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
9d00b448:	8f91810c 	lw	s1,-32500(gp)
	while ((gTimer0_millis - startMillis) < ms)
9d00b44c:	8f82810c 	lw	v0,-32500(gp)
}

//************************************************************************
// Delay for a given number of milliseconds.
void delay(unsigned long ms)
{
9d00b450:	afb00014 	sw	s0,20(sp)
9d00b454:	afbf001c 	sw	ra,28(sp)
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d00b458:	00511023 	subu	v0,v0,s1
9d00b45c:	0044102b 	sltu	v0,v0,a0
9d00b460:	10400008 	beqz	v0,9d00b484 <delay+0x44>
9d00b464:	00808021 	move	s0,a0
	{
		_scheduleTask();
9d00b468:	0f402d61 	jal	9d00b584 <_scheduleTask>
9d00b46c:	00000000 	nop
void delay(unsigned long ms)
{
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d00b470:	8f82810c 	lw	v0,-32500(gp)
9d00b474:	00511023 	subu	v0,v0,s1
9d00b478:	0050102b 	sltu	v0,v0,s0
9d00b47c:	1440fffa 	bnez	v0,9d00b468 <delay+0x28>
9d00b480:	00000000 	nop
	{
		_scheduleTask();
	}
}
9d00b484:	8fbf001c 	lw	ra,28(sp)
9d00b488:	8fb10018 	lw	s1,24(sp)
9d00b48c:	8fb00014 	lw	s0,20(sp)
9d00b490:	03e00008 	jr	ra
9d00b494:	27bd0020 	addiu	sp,sp,32

9d00b498 <init>:
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d00b498:	3c0404c4 	lui	a0,0x4c4
}


//************************************************************************
void init()
{
9d00b49c:	27bdffe8 	addiu	sp,sp,-24
9d00b4a0:	afbf0014 	sw	ra,20(sp)
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif
#endif

	// Configure the processor for the proper number of wait states and caching.
	_configSystem(F_CPU);
9d00b4a4:	0f402c3c 	jal	9d00b0f0 <_configSystem>
9d00b4a8:	3484b400 	ori	a0,a0,0xb400

	// Enable multi-vector interrupts
	_enableMultiVectorInterrupts();
9d00b4ac:	0f402c5d 	jal	9d00b174 <_enableMultiVectorInterrupts>
9d00b4b0:	00000000 	nop

	// Initialize the core timer for use to maintain the system timer tick.
	_initCoreTimer(CORE_TICK_RATE);
9d00b4b4:	0f402c66 	jal	9d00b198 <_initCoreTimer>
9d00b4b8:	34049c40 	li	a0,0x9c40

    initIntVector();
9d00b4bc:	0f402bf0 	jal	9d00afc0 <initIntVector>
9d00b4c0:	00000000 	nop

	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
9d00b4c4:	00003021 	move	a2,zero
9d00b4c8:	00002021 	move	a0,zero
9d00b4cc:	0f402c1e 	jal	9d00b078 <setIntPriority>
9d00b4d0:	24050007 	li	a1,7
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
9d00b4d4:	3c059d01 	lui	a1,0x9d01
9d00b4d8:	24a5b1e8 	addiu	a1,a1,-19992
9d00b4dc:	0f402c05 	jal	9d00b014 <setIntVector>
9d00b4e0:	00002021 	move	a0,zero
	setIntEnable(_CORE_TIMER_IRQ);
9d00b4e4:	0f402c10 	jal	9d00b040 <setIntEnable>
9d00b4e8:	00002021 	move	a0,zero

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d00b4ec:	0f402c35 	jal	9d00b0d4 <getPeripheralClock>
9d00b4f0:	00000000 	nop

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d00b4f4:	3c030200 	lui	v1,0x200
	setIntPriority(_CORE_TIMER_VECTOR, _CT_IPL_IPC, _CT_SPL_IPC);
	setIntVector(_CORE_TIMER_VECTOR, CoreTimerHandler);
	setIntEnable(_CORE_TIMER_IRQ);

	// Save the peripheral bus frequency for later use.
	__PIC32_pbClk = getPeripheralClock();
9d00b4f8:	af828170 	sw	v0,-32400(gp)

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 
9d00b4fc:	4002b800 	mfc0	v0,c0_debug
9d00b500:	00031827 	nor	v1,zero,v1
9d00b504:	00431824 	and	v1,v0,v1
9d00b508:	4083b800 	mtc0	v1,c0_debug
9d00b50c:	000000c0 	ehb
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif
#endif

	delay(50);
9d00b510:	0f402d10 	jal	9d00b440 <delay>
9d00b514:	24040032 	li	a0,50
#if defined(__PIC32MX1XX__) || defined(__PIC32MX2XX__)
	CFGCONbits.JTAGEN = 0;
	//CFGCONbits.TDOEN = 0;
	//OSCCONbits.SOSCEN = 0;
#else
	DDPCONbits.JTAGEN	=	0;
9d00b518:	3c02bf81 	lui	v0,0xbf81
9d00b51c:	8c43f200 	lw	v1,-3584(v0)
9d00b520:	7c0318c4 	ins	v1,zero,0x3,0x1
9d00b524:	ac43f200 	sw	v1,-3584(v0)
#endif


#if (OPT_BOARD_INIT != 0)
void	_board_init(void);
	_board_init();
9d00b528:	0f402b2c 	jal	9d00acb0 <_board_init>
9d00b52c:	00000000 	nop
#endif

	//* Initialize the periodic task manager
	_initTaskManager();
9d00b530:	0f402d54 	jal	9d00b550 <_initTaskManager>
9d00b534:	00000000 	nop
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
#endif
}
9d00b538:	8fbf0014 	lw	ra,20(sp)
	//*	Issue #84
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
	p32_uart *	uart;
	uart = (p32_uart *)_SER0_BASE;
	uart->uxMode.clr = (1 << _UARTMODE_ON);
9d00b53c:	34038000 	li	v1,0x8000
9d00b540:	3c02bf80 	lui	v0,0xbf80
9d00b544:	ac436004 	sw	v1,24580(v0)
#endif
}
9d00b548:	03e00008 	jr	ra
9d00b54c:	27bd0018 	addiu	sp,sp,24

9d00b550 <_initTaskManager>:
void
_initTaskManager() {
	int		id;

	for (id = 0; id < NUM_TASKS; id++) {
		rgtaskTable[id].pfnTask = 0;
9d00b550:	3c03a001 	lui	v1,0xa001
9d00b554:	24629978 	addiu	v0,v1,-26248
9d00b558:	ac609978 	sw	zero,-26248(v1)
9d00b55c:	ac400014 	sw	zero,20(v0)
9d00b560:	ac400028 	sw	zero,40(v0)
9d00b564:	ac40003c 	sw	zero,60(v0)
9d00b568:	ac400050 	sw	zero,80(v0)
9d00b56c:	ac400064 	sw	zero,100(v0)
9d00b570:	ac400078 	sw	zero,120(v0)
9d00b574:	ac40008c 	sw	zero,140(v0)
	}

	tmsLastEvent = 0;
9d00b578:	af808124 	sw	zero,-32476(gp)
	tmsNextEvent = 0;

}
9d00b57c:	03e00008 	jr	ra
9d00b580:	af808120 	sw	zero,-32480(gp)

9d00b584 <_scheduleTask>:
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d00b584:	8f82811c 	lw	v0,-32484(gp)
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d00b588:	27bdffc8 	addiu	sp,sp,-56
9d00b58c:	afbf0034 	sw	ra,52(sp)
9d00b590:	afb50030 	sw	s5,48(sp)
9d00b594:	afb4002c 	sw	s4,44(sp)
9d00b598:	afb30028 	sw	s3,40(sp)
9d00b59c:	afb20024 	sw	s2,36(sp)
9d00b5a0:	afb10020 	sw	s1,32(sp)
	unsigned long	tmsCur;		//current system time
	unsigned long	tmsNxt;		//time for next event for this task
	unsigned long	dtmsNext;
	unsigned long	dtms;

	if (cntActiveTask == 0) {
9d00b5a4:	1440000a 	bnez	v0,9d00b5d0 <_scheduleTask+0x4c>
9d00b5a8:	afb0001c 	sw	s0,28(sp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d00b5ac:	8fbf0034 	lw	ra,52(sp)
9d00b5b0:	8fb50030 	lw	s5,48(sp)
9d00b5b4:	8fb4002c 	lw	s4,44(sp)
9d00b5b8:	8fb30028 	lw	s3,40(sp)
9d00b5bc:	8fb20024 	lw	s2,36(sp)
9d00b5c0:	8fb10020 	lw	s1,32(sp)
9d00b5c4:	8fb0001c 	lw	s0,28(sp)
9d00b5c8:	03e00008 	jr	ra
9d00b5cc:	27bd0038 	addiu	sp,sp,56

	if (cntActiveTask == 0) {
		return;
	}

	tmsCur = millis();
9d00b5d0:	0f402d0d 	jal	9d00b434 <millis>
9d00b5d4:	00000000 	nop

	/* The system millisecond timer will overflow every 49.71 days. The complexity of
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
9d00b5d8:	8f848120 	lw	a0,-32480(gp)
9d00b5dc:	8f838124 	lw	v1,-32476(gp)
9d00b5e0:	0083282b 	sltu	a1,a0,v1
9d00b5e4:	14a00048 	bnez	a1,9d00b708 <_scheduleTask+0x184>
9d00b5e8:	0043182b 	sltu	v1,v0,v1
9d00b5ec:	14600004 	bnez	v1,9d00b600 <_scheduleTask+0x7c>
9d00b5f0:	3c10a001 	lui	s0,0xa001
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
9d00b5f4:	0044202b 	sltu	a0,v0,a0
9d00b5f8:	1480ffec 	bnez	a0,9d00b5ac <_scheduleTask+0x28>
9d00b5fc:	3c10a001 	lui	s0,0xa001
9d00b600:	26109988 	addiu	s0,s0,-26232
**	xxxN..C..........................................Lxx
**		current time and next time have wrapped: (N < L) && (C >= N)
*/

void
_scheduleTask() {
9d00b604:	2413ffff 	li	s3,-1
9d00b608:	00008821 	move	s1,zero

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d00b60c:	2415fffe 	li	s5,-2

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d00b610:	3414fffe 	li	s4,0xfffe
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d00b614:	24120008 	li	s2,8
		/* If this isn't an active task, go to the next one.
		*/
		if ((rgtaskTable[id].pfnTask == 0) || 
9d00b618:	8e03fff0 	lw	v1,-16(s0)
9d00b61c:	5060002c 	beqzl	v1,9d00b6d0 <_scheduleTask+0x14c>
9d00b620:	26310001 	addiu	s1,s1,1
9d00b624:	96040000 	lhu	a0,0(s0)
9d00b628:	50800029 	beqzl	a0,9d00b6d0 <_scheduleTask+0x14c>
9d00b62c:	26310001 	addiu	s1,s1,1
		** occur if a user task function calls delay() or any other
		** function that causes _scheduleTask to be called recursively.
		** This prevents the task function from being called recursively
		** until the system crashes.
		*/
		if ((rgtaskTable[id].fsFlags & fsBusy) != 0) {
9d00b630:	96040002 	lhu	a0,2(s0)
9d00b634:	30840001 	andi	a0,a0,0x1
9d00b638:	54800025 	bnezl	a0,9d00b6d0 <_scheduleTask+0x14c>
9d00b63c:	26310001 	addiu	s1,s1,1
			continue;
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
9d00b640:	8e04fff8 	lw	a0,-8(s0)
		if ( ((tmsNxt >= tmsLastEvent) && 
9d00b644:	8f858124 	lw	a1,-32476(gp)
9d00b648:	0085302b 	sltu	a2,a0,a1
9d00b64c:	10c00032 	beqz	a2,9d00b718 <_scheduleTask+0x194>
9d00b650:	0044302b 	sltu	a2,v0,a0
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
9d00b654:	54c0001b 	bnezl	a2,9d00b6c4 <_scheduleTask+0x140>
9d00b658:	00822023 	subu	a0,a0,v0
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d00b65c:	0045282b 	sltu	a1,v0,a1
9d00b660:	50a00018 	beqzl	a1,9d00b6c4 <_scheduleTask+0x140>
9d00b664:	00822023 	subu	a0,a0,v0
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d00b668:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d00b66c:	8e07fff4 	lw	a3,-12(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d00b670:	8e05fffc 	lw	a1,-4(s0)
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
9d00b674:	34c60001 	ori	a2,a2,0x1
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {

			/* This task event has timed out. Update the event time for the
			** next event on this task.
			*/
			rgtaskTable[id].tmsNext += rgtaskTable[id].tmsPeriod;
9d00b678:	00e42021 	addu	a0,a3,a0
9d00b67c:	ae04fff8 	sw	a0,-8(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
9d00b680:	afa20010 	sw	v0,16(sp)
9d00b684:	02202021 	move	a0,s1
9d00b688:	0060f809 	jalr	v1
9d00b68c:	a6060002 	sh	a2,2(s0)
			rgtaskTable[id].fsFlags &= ~fsBusy;

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d00b690:	96030000 	lhu	v1,0(s0)

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d00b694:	96050002 	lhu	a1,2(s0)

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d00b698:	8fa20010 	lw	v0,16(sp)
9d00b69c:	2463ffff 	addiu	v1,v1,-1
9d00b6a0:	3063ffff 	andi	v1,v1,0xffff

			/* Call the event function.
			*/
			rgtaskTable[id].fsFlags |= fsBusy;
			(*rgtaskTable[id].pfnTask)(id, rgtaskTable[id].varTask);
			rgtaskTable[id].fsFlags &= ~fsBusy;
9d00b6a4:	00b52824 	and	a1,a1,s5

			/* Decrement the repeat count.
			*/
			if ((rgtaskTable[id].stTask > 0) &&
9d00b6a8:	0074202b 	sltu	a0,v1,s4
9d00b6ac:	10800003 	beqz	a0,9d00b6bc <_scheduleTask+0x138>
9d00b6b0:	a6050002 	sh	a1,2(s0)
				rgtaskTable[id].stTask -= 1;

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
9d00b6b4:	1060001c 	beqz	v1,9d00b728 <_scheduleTask+0x1a4>
9d00b6b8:	a6030000 	sh	v1,0(s0)
9d00b6bc:	8e04fff8 	lw	a0,-8(s0)
		}

		/* Compute delta of this event time from the current time and
		** remember it if it is less than the current delta.
		*/
		dtms = rgtaskTable[id].tmsNext - tmsCur;
9d00b6c0:	00822023 	subu	a0,a0,v0
		if (dtms < dtmsNext) {
9d00b6c4:	0093182b 	sltu	v1,a0,s3
9d00b6c8:	0083980b 	movn	s3,a0,v1
	** the table for all events that have elapsed and call their
	** associated functions, update their next event timers, and then
	** figure out when the next event time is.
	*/
	dtmsNext = 0xFFFFFFFF;
	for (id = 0; id < NUM_TASKS; id++) {
9d00b6cc:	26310001 	addiu	s1,s1,1
9d00b6d0:	1632ffd1 	bne	s1,s2,9d00b618 <_scheduleTask+0x94>
9d00b6d4:	26100014 	addiu	s0,s0,20

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d00b6d8:	8fbf0034 	lw	ra,52(sp)
	tmsLastEvent = tmsCur;

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
9d00b6dc:	02629821 	addu	s3,s3,v0
9d00b6e0:	af938120 	sw	s3,-32480(gp)
}
9d00b6e4:	8fb50030 	lw	s5,48(sp)
9d00b6e8:	8fb4002c 	lw	s4,44(sp)
9d00b6ec:	8fb30028 	lw	s3,40(sp)
9d00b6f0:	8fb20024 	lw	s2,36(sp)
9d00b6f4:	8fb10020 	lw	s1,32(sp)
9d00b6f8:	8fb0001c 	lw	s0,28(sp)
	}

	/* All done with event tasks. Update the last event time with
	** the current time.
	*/
	tmsLastEvent = tmsCur;
9d00b6fc:	af828124 	sw	v0,-32476(gp)

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d00b700:	03e00008 	jr	ra
9d00b704:	27bd0038 	addiu	sp,sp,56
	** this conditional is to account for the cases where either the next event time has
	** wrapped around or the current time has wrapped around.
	*/
	if ( ((tmsNextEvent >= tmsLastEvent) &&
				((tmsCur >= tmsLastEvent) && (tmsCur < tmsNextEvent))) ||
		 ((tmsNextEvent < tmsLastEvent) &&
9d00b708:	5460ffbb 	bnezl	v1,9d00b5f8 <_scheduleTask+0x74>
9d00b70c:	0044202b 	sltu	a0,v0,a0

	/* Compute when the next event time will be by adding the event
	** time delta to the current time.
	*/
	tmsNextEvent = tmsCur + dtmsNext;
}
9d00b710:	0b402d6c 	j	9d00b5b0 <_scheduleTask+0x2c>
9d00b714:	8fbf0034 	lw	ra,52(sp)
		}

		/* Check if this task's period has timed out.
		*/
		tmsNxt = rgtaskTable[id].tmsNext;
		if ( ((tmsNxt >= tmsLastEvent) && 
9d00b718:	50c0ffd4 	beqzl	a2,9d00b66c <_scheduleTask+0xe8>
9d00b71c:	96060002 	lhu	a2,2(s0)
						((tmsCur >= tmsNxt) || (tmsCur < tmsLastEvent))) ||
			 ((tmsNxt <  tmsLastEvent) && 
						((tmsCur >= tmsNxt) && (tmsCur < tmsLastEvent))) ) {
9d00b720:	0b402d98 	j	9d00b660 <_scheduleTask+0xdc>
9d00b724:	0045282b 	sltu	a1,v0,a1
				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
					cntActiveTask -= 1;
9d00b728:	8f83811c 	lw	v1,-32484(gp)

				/* The task state counter has gone to 0. This task is now
				** disabled.
				*/
				if (rgtaskTable[id].stTask == 0) {
					rgtaskTable[id].tmsNext = 0;
9d00b72c:	ae00fff8 	sw	zero,-8(s0)
					cntActiveTask -= 1;
9d00b730:	2463ffff 	addiu	v1,v1,-1
					continue;
9d00b734:	0b402db3 	j	9d00b6cc <_scheduleTask+0x148>
9d00b738:	af83811c 	sw	v1,-32484(gp)

9d00b73c <atexit>:
9d00b73c:	27bdffe8 	addiu	sp,sp,-24
9d00b740:	00802821 	move	a1,a0
9d00b744:	00003021 	move	a2,zero
9d00b748:	00002021 	move	a0,zero
9d00b74c:	afbf0014 	sw	ra,20(sp)
9d00b750:	0f403022 	jal	9d00c088 <__register_exitproc>
9d00b754:	00003821 	move	a3,zero
9d00b758:	8fbf0014 	lw	ra,20(sp)
9d00b75c:	03e00008 	jr	ra
9d00b760:	27bd0018 	addiu	sp,sp,24

9d00b764 <calloc>:
9d00b764:	3c03a000 	lui	v1,0xa000
9d00b768:	00801021 	move	v0,a0
9d00b76c:	8c640930 	lw	a0,2352(v1)
9d00b770:	27bdffe8 	addiu	sp,sp,-24
9d00b774:	00a03021 	move	a2,a1
9d00b778:	afbf0014 	sw	ra,20(sp)
9d00b77c:	0f402de4 	jal	9d00b790 <_calloc_r>
9d00b780:	00402821 	move	a1,v0
9d00b784:	8fbf0014 	lw	ra,20(sp)
9d00b788:	03e00008 	jr	ra
9d00b78c:	27bd0018 	addiu	sp,sp,24

9d00b790 <_calloc_r>:
9d00b790:	27bdffe8 	addiu	sp,sp,-24
9d00b794:	afb00010 	sw	s0,16(sp)
9d00b798:	afbf0014 	sw	ra,20(sp)
9d00b79c:	0f402e21 	jal	9d00b884 <_malloc_r>
9d00b7a0:	70c52802 	mul	a1,a2,a1
9d00b7a4:	1040001e 	beqz	v0,9d00b820 <_calloc_r+0x90>
9d00b7a8:	00408021 	move	s0,v0
9d00b7ac:	8c42fffc 	lw	v0,-4(v0)
9d00b7b0:	2406fffc 	li	a2,-4
9d00b7b4:	00c23024 	and	a2,a2,v0
9d00b7b8:	24c6fffc 	addiu	a2,a2,-4
9d00b7bc:	2cc20025 	sltiu	v0,a2,37
9d00b7c0:	10400014 	beqz	v0,9d00b814 <_calloc_r+0x84>
9d00b7c4:	2cc30014 	sltiu	v1,a2,20
9d00b7c8:	1460000e 	bnez	v1,9d00b804 <_calloc_r+0x74>
9d00b7cc:	02001021 	move	v0,s0
9d00b7d0:	2cc3001c 	sltiu	v1,a2,28
9d00b7d4:	ae000000 	sw	zero,0(s0)
9d00b7d8:	ae000004 	sw	zero,4(s0)
9d00b7dc:	14600009 	bnez	v1,9d00b804 <_calloc_r+0x74>
9d00b7e0:	26020008 	addiu	v0,s0,8
9d00b7e4:	24030024 	li	v1,36
9d00b7e8:	ae000008 	sw	zero,8(s0)
9d00b7ec:	ae00000c 	sw	zero,12(s0)
9d00b7f0:	14c30004 	bne	a2,v1,9d00b804 <_calloc_r+0x74>
9d00b7f4:	26020010 	addiu	v0,s0,16
9d00b7f8:	ae000010 	sw	zero,16(s0)
9d00b7fc:	ae000014 	sw	zero,20(s0)
9d00b800:	26020018 	addiu	v0,s0,24
9d00b804:	ac400000 	sw	zero,0(v0)
9d00b808:	ac400004 	sw	zero,4(v0)
9d00b80c:	0b402e08 	j	9d00b820 <_calloc_r+0x90>
9d00b810:	ac400008 	sw	zero,8(v0)
9d00b814:	02002021 	move	a0,s0
9d00b818:	0f402fd9 	jal	9d00bf64 <memset>
9d00b81c:	00002821 	move	a1,zero
9d00b820:	8fbf0014 	lw	ra,20(sp)
9d00b824:	02001021 	move	v0,s0
9d00b828:	8fb00010 	lw	s0,16(sp)
9d00b82c:	03e00008 	jr	ra
9d00b830:	27bd0018 	addiu	sp,sp,24

9d00b834 <malloc>:
9d00b834:	3c02a000 	lui	v0,0xa000
9d00b838:	00802821 	move	a1,a0
9d00b83c:	8c440930 	lw	a0,2352(v0)
9d00b840:	27bdffe8 	addiu	sp,sp,-24
9d00b844:	afbf0014 	sw	ra,20(sp)
9d00b848:	0f402e21 	jal	9d00b884 <_malloc_r>
9d00b84c:	00000000 	nop
9d00b850:	8fbf0014 	lw	ra,20(sp)
9d00b854:	03e00008 	jr	ra
9d00b858:	27bd0018 	addiu	sp,sp,24

9d00b85c <free>:
9d00b85c:	3c02a000 	lui	v0,0xa000
9d00b860:	00802821 	move	a1,a0
9d00b864:	8c440930 	lw	a0,2352(v0)
9d00b868:	27bdffe8 	addiu	sp,sp,-24
9d00b86c:	afbf0014 	sw	ra,20(sp)
9d00b870:	0f4030b0 	jal	9d00c2c0 <_free_r>
9d00b874:	00000000 	nop
9d00b878:	8fbf0014 	lw	ra,20(sp)
9d00b87c:	03e00008 	jr	ra
9d00b880:	27bd0018 	addiu	sp,sp,24

9d00b884 <_malloc_r>:
9d00b884:	24a2000b 	addiu	v0,a1,11
9d00b888:	27bdffc8 	addiu	sp,sp,-56
9d00b88c:	2c430017 	sltiu	v1,v0,23
9d00b890:	afb3001c 	sw	s3,28(sp)
9d00b894:	afb00010 	sw	s0,16(sp)
9d00b898:	afbf0034 	sw	ra,52(sp)
9d00b89c:	afbe0030 	sw	s8,48(sp)
9d00b8a0:	afb7002c 	sw	s7,44(sp)
9d00b8a4:	afb60028 	sw	s6,40(sp)
9d00b8a8:	afb50024 	sw	s5,36(sp)
9d00b8ac:	afb40020 	sw	s4,32(sp)
9d00b8b0:	afb20018 	sw	s2,24(sp)
9d00b8b4:	afb10014 	sw	s1,20(sp)
9d00b8b8:	00809821 	move	s3,a0
9d00b8bc:	14600005 	bnez	v1,9d00b8d4 <_malloc_r+0x50>
9d00b8c0:	24100010 	li	s0,16
9d00b8c4:	2410fff8 	li	s0,-8
9d00b8c8:	00508024 	and	s0,v0,s0
9d00b8cc:	06000004 	bltz	s0,9d00b8e0 <_malloc_r+0x5c>
9d00b8d0:	2402000c 	li	v0,12
9d00b8d4:	0205282b 	sltu	a1,s0,a1
9d00b8d8:	10a00003 	beqz	a1,9d00b8e8 <_malloc_r+0x64>
9d00b8dc:	2402000c 	li	v0,12
9d00b8e0:	0b402faa 	j	9d00bea8 <_malloc_r+0x624>
9d00b8e4:	ae620000 	sw	v0,0(s3)
9d00b8e8:	0f402fe2 	jal	9d00bf88 <__malloc_lock>
9d00b8ec:	02602021 	move	a0,s3
9d00b8f0:	2e0201f8 	sltiu	v0,s0,504
9d00b8f4:	1040000e 	beqz	v0,9d00b930 <_malloc_r+0xac>
9d00b8f8:	3c11a000 	lui	s1,0xa000
9d00b8fc:	26220508 	addiu	v0,s1,1288
9d00b900:	00501021 	addu	v0,v0,s0
9d00b904:	8c52000c 	lw	s2,12(v0)
9d00b908:	16420005 	bne	s2,v0,9d00b920 <_malloc_r+0x9c>
9d00b90c:	001020c2 	srl	a0,s0,0x3
9d00b910:	26420008 	addiu	v0,s2,8
9d00b914:	8e520014 	lw	s2,20(s2)
9d00b918:	12420038 	beq	s2,v0,9d00b9fc <_malloc_r+0x178>
9d00b91c:	24840002 	addiu	a0,a0,2
9d00b920:	8e420004 	lw	v0,4(s2)
9d00b924:	2403fffc 	li	v1,-4
9d00b928:	0b402e77 	j	9d00b9dc <_malloc_r+0x158>
9d00b92c:	00621024 	and	v0,v1,v0
9d00b930:	00102242 	srl	a0,s0,0x9
9d00b934:	14800003 	bnez	a0,9d00b944 <_malloc_r+0xc0>
9d00b938:	2c820005 	sltiu	v0,a0,5
9d00b93c:	0b402e68 	j	9d00b9a0 <_malloc_r+0x11c>
9d00b940:	001020c2 	srl	a0,s0,0x3
9d00b944:	10400004 	beqz	v0,9d00b958 <_malloc_r+0xd4>
9d00b948:	2c820015 	sltiu	v0,a0,21
9d00b94c:	00102182 	srl	a0,s0,0x6
9d00b950:	0b402e68 	j	9d00b9a0 <_malloc_r+0x11c>
9d00b954:	24840038 	addiu	a0,a0,56
9d00b958:	10400003 	beqz	v0,9d00b968 <_malloc_r+0xe4>
9d00b95c:	2c820055 	sltiu	v0,a0,85
9d00b960:	0b402e68 	j	9d00b9a0 <_malloc_r+0x11c>
9d00b964:	2484005b 	addiu	a0,a0,91
9d00b968:	10400004 	beqz	v0,9d00b97c <_malloc_r+0xf8>
9d00b96c:	2c820155 	sltiu	v0,a0,341
9d00b970:	00102302 	srl	a0,s0,0xc
9d00b974:	0b402e68 	j	9d00b9a0 <_malloc_r+0x11c>
9d00b978:	2484006e 	addiu	a0,a0,110
9d00b97c:	10400004 	beqz	v0,9d00b990 <_malloc_r+0x10c>
9d00b980:	2c820555 	sltiu	v0,a0,1365
9d00b984:	001023c2 	srl	a0,s0,0xf
9d00b988:	0b402e68 	j	9d00b9a0 <_malloc_r+0x11c>
9d00b98c:	24840077 	addiu	a0,a0,119
9d00b990:	10400003 	beqz	v0,9d00b9a0 <_malloc_r+0x11c>
9d00b994:	2404007e 	li	a0,126
9d00b998:	00102482 	srl	a0,s0,0x12
9d00b99c:	2484007c 	addiu	a0,a0,124
9d00b9a0:	000410c0 	sll	v0,a0,0x3
9d00b9a4:	26230508 	addiu	v1,s1,1288
9d00b9a8:	00621821 	addu	v1,v1,v0
9d00b9ac:	8c72000c 	lw	s2,12(v1)
9d00b9b0:	0b402e7c 	j	9d00b9f0 <_malloc_r+0x16c>
9d00b9b4:	2406fffc 	li	a2,-4
9d00b9b8:	00c21024 	and	v0,a2,v0
9d00b9bc:	00502823 	subu	a1,v0,s0
9d00b9c0:	28a70010 	slti	a3,a1,16
9d00b9c4:	14e00003 	bnez	a3,9d00b9d4 <_malloc_r+0x150>
9d00b9c8:	00000000 	nop
9d00b9cc:	0b402e7e 	j	9d00b9f8 <_malloc_r+0x174>
9d00b9d0:	2484ffff 	addiu	a0,a0,-1
9d00b9d4:	04a20006 	bltzl	a1,9d00b9f0 <_malloc_r+0x16c>
9d00b9d8:	8e52000c 	lw	s2,12(s2)
9d00b9dc:	8e43000c 	lw	v1,12(s2)
9d00b9e0:	8e440008 	lw	a0,8(s2)
9d00b9e4:	ac83000c 	sw	v1,12(a0)
9d00b9e8:	0b402e90 	j	9d00ba40 <_malloc_r+0x1bc>
9d00b9ec:	ac640008 	sw	a0,8(v1)
9d00b9f0:	5643fff1 	bnel	s2,v1,9d00b9b8 <_malloc_r+0x134>
9d00b9f4:	8e420004 	lw	v0,4(s2)
9d00b9f8:	24840001 	addiu	a0,a0,1
9d00b9fc:	26310508 	addiu	s1,s1,1288
9d00ba00:	26230008 	addiu	v1,s1,8
9d00ba04:	8c720008 	lw	s2,8(v1)
9d00ba08:	12430051 	beq	s2,v1,9d00bb50 <_malloc_r+0x2cc>
9d00ba0c:	2405fffc 	li	a1,-4
9d00ba10:	8e420004 	lw	v0,4(s2)
9d00ba14:	00a21024 	and	v0,a1,v0
9d00ba18:	00502823 	subu	a1,v0,s0
9d00ba1c:	28a60010 	slti	a2,a1,16
9d00ba20:	54c00005 	bnezl	a2,9d00ba38 <_malloc_r+0x1b4>
9d00ba24:	ac63000c 	sw	v1,12(v1)
9d00ba28:	02501021 	addu	v0,s2,s0
9d00ba2c:	36100001 	ori	s0,s0,0x1
9d00ba30:	0b402ef7 	j	9d00bbdc <_malloc_r+0x358>
9d00ba34:	ae500004 	sw	s0,4(s2)
9d00ba38:	04a00006 	bltz	a1,9d00ba54 <_malloc_r+0x1d0>
9d00ba3c:	ac630008 	sw	v1,8(v1)
9d00ba40:	02421021 	addu	v0,s2,v0
9d00ba44:	8c430004 	lw	v1,4(v0)
9d00ba48:	34630001 	ori	v1,v1,0x1
9d00ba4c:	0b402fb2 	j	9d00bec8 <_malloc_r+0x644>
9d00ba50:	ac430004 	sw	v1,4(v0)
9d00ba54:	2c450200 	sltiu	a1,v0,512
9d00ba58:	10a0000c 	beqz	a1,9d00ba8c <_malloc_r+0x208>
9d00ba5c:	00023242 	srl	a2,v0,0x9
9d00ba60:	000210c2 	srl	v0,v0,0x3
9d00ba64:	00022883 	sra	a1,v0,0x2
9d00ba68:	24060001 	li	a2,1
9d00ba6c:	00a62804 	sllv	a1,a2,a1
9d00ba70:	8e260004 	lw	a2,4(s1)
9d00ba74:	000210c0 	sll	v0,v0,0x3
9d00ba78:	02221021 	addu	v0,s1,v0
9d00ba7c:	00c52825 	or	a1,a2,a1
9d00ba80:	ae250004 	sw	a1,4(s1)
9d00ba84:	0b402ed0 	j	9d00bb40 <_malloc_r+0x2bc>
9d00ba88:	8c450008 	lw	a1,8(v0)
9d00ba8c:	2cc50005 	sltiu	a1,a2,5
9d00ba90:	10a00004 	beqz	a1,9d00baa4 <_malloc_r+0x220>
9d00ba94:	2cc50015 	sltiu	a1,a2,21
9d00ba98:	00023182 	srl	a2,v0,0x6
9d00ba9c:	0b402ebb 	j	9d00baec <_malloc_r+0x268>
9d00baa0:	24c60038 	addiu	a2,a2,56
9d00baa4:	10a00003 	beqz	a1,9d00bab4 <_malloc_r+0x230>
9d00baa8:	2cc50055 	sltiu	a1,a2,85
9d00baac:	0b402ebb 	j	9d00baec <_malloc_r+0x268>
9d00bab0:	24c6005b 	addiu	a2,a2,91
9d00bab4:	10a00004 	beqz	a1,9d00bac8 <_malloc_r+0x244>
9d00bab8:	2cc50155 	sltiu	a1,a2,341
9d00babc:	00023302 	srl	a2,v0,0xc
9d00bac0:	0b402ebb 	j	9d00baec <_malloc_r+0x268>
9d00bac4:	24c6006e 	addiu	a2,a2,110
9d00bac8:	10a00004 	beqz	a1,9d00badc <_malloc_r+0x258>
9d00bacc:	2cc50555 	sltiu	a1,a2,1365
9d00bad0:	000233c2 	srl	a2,v0,0xf
9d00bad4:	0b402ebb 	j	9d00baec <_malloc_r+0x268>
9d00bad8:	24c60077 	addiu	a2,a2,119
9d00badc:	10a00003 	beqz	a1,9d00baec <_malloc_r+0x268>
9d00bae0:	2406007e 	li	a2,126
9d00bae4:	00023482 	srl	a2,v0,0x12
9d00bae8:	24c6007c 	addiu	a2,a2,124
9d00baec:	000638c0 	sll	a3,a2,0x3
9d00baf0:	02273821 	addu	a3,s1,a3
9d00baf4:	8ce50008 	lw	a1,8(a3)
9d00baf8:	14a7000b 	bne	a1,a3,9d00bb28 <_malloc_r+0x2a4>
9d00bafc:	2408fffc 	li	t0,-4
9d00bb00:	24020001 	li	v0,1
9d00bb04:	00063083 	sra	a2,a2,0x2
9d00bb08:	00c23004 	sllv	a2,v0,a2
9d00bb0c:	8e220004 	lw	v0,4(s1)
9d00bb10:	00463025 	or	a2,v0,a2
9d00bb14:	ae260004 	sw	a2,4(s1)
9d00bb18:	0b402ed0 	j	9d00bb40 <_malloc_r+0x2bc>
9d00bb1c:	00a01021 	move	v0,a1
9d00bb20:	50a70007 	beql	a1,a3,9d00bb40 <_malloc_r+0x2bc>
9d00bb24:	8ca2000c 	lw	v0,12(a1)
9d00bb28:	8ca60004 	lw	a2,4(a1)
9d00bb2c:	01063024 	and	a2,t0,a2
9d00bb30:	0046302b 	sltu	a2,v0,a2
9d00bb34:	54c0fffa 	bnezl	a2,9d00bb20 <_malloc_r+0x29c>
9d00bb38:	8ca50008 	lw	a1,8(a1)
9d00bb3c:	8ca2000c 	lw	v0,12(a1)
9d00bb40:	ae42000c 	sw	v0,12(s2)
9d00bb44:	ae450008 	sw	a1,8(s2)
9d00bb48:	ac520008 	sw	s2,8(v0)
9d00bb4c:	acb2000c 	sw	s2,12(a1)
9d00bb50:	24050001 	li	a1,1
9d00bb54:	00041083 	sra	v0,a0,0x2
9d00bb58:	00451004 	sllv	v0,a1,v0
9d00bb5c:	8e250004 	lw	a1,4(s1)
9d00bb60:	00a2302b 	sltu	a2,a1,v0
9d00bb64:	54c00053 	bnezl	a2,9d00bcb4 <_malloc_r+0x430>
9d00bb68:	8e340008 	lw	s4,8(s1)
9d00bb6c:	00453024 	and	a2,v0,a1
9d00bb70:	14c00008 	bnez	a2,9d00bb94 <_malloc_r+0x310>
9d00bb74:	240afffc 	li	t2,-4
9d00bb78:	2406fffc 	li	a2,-4
9d00bb7c:	00862024 	and	a0,a0,a2
9d00bb80:	00021040 	sll	v0,v0,0x1
9d00bb84:	00453024 	and	a2,v0,a1
9d00bb88:	10c0fffd 	beqz	a2,9d00bb80 <_malloc_r+0x2fc>
9d00bb8c:	24840004 	addiu	a0,a0,4
9d00bb90:	240afffc 	li	t2,-4
9d00bb94:	000448c0 	sll	t1,a0,0x3
9d00bb98:	02294821 	addu	t1,s1,t1
9d00bb9c:	01203821 	move	a3,t1
9d00bba0:	00803021 	move	a2,a0
9d00bba4:	0b402f0b 	j	9d00bc2c <_malloc_r+0x3a8>
9d00bba8:	8cf2000c 	lw	s2,12(a3)
9d00bbac:	01484024 	and	t0,t2,t0
9d00bbb0:	01102823 	subu	a1,t0,s0
9d00bbb4:	28ab0010 	slti	t3,a1,16
9d00bbb8:	15600011 	bnez	t3,9d00bc00 <_malloc_r+0x37c>
9d00bbbc:	00000000 	nop
9d00bbc0:	8e44000c 	lw	a0,12(s2)
9d00bbc4:	8e460008 	lw	a2,8(s2)
9d00bbc8:	02501021 	addu	v0,s2,s0
9d00bbcc:	36100001 	ori	s0,s0,0x1
9d00bbd0:	ae500004 	sw	s0,4(s2)
9d00bbd4:	acc4000c 	sw	a0,12(a2)
9d00bbd8:	ac860008 	sw	a2,8(a0)
9d00bbdc:	ac62000c 	sw	v0,12(v1)
9d00bbe0:	ac620008 	sw	v0,8(v1)
9d00bbe4:	ac43000c 	sw	v1,12(v0)
9d00bbe8:	ac430008 	sw	v1,8(v0)
9d00bbec:	34a30001 	ori	v1,a1,0x1
9d00bbf0:	ac430004 	sw	v1,4(v0)
9d00bbf4:	00451021 	addu	v0,v0,a1
9d00bbf8:	0b402fb2 	j	9d00bec8 <_malloc_r+0x644>
9d00bbfc:	ac450000 	sw	a1,0(v0)
9d00bc00:	04a2000a 	bltzl	a1,9d00bc2c <_malloc_r+0x3a8>
9d00bc04:	8e52000c 	lw	s2,12(s2)
9d00bc08:	02481021 	addu	v0,s2,t0
9d00bc0c:	8c430004 	lw	v1,4(v0)
9d00bc10:	34630001 	ori	v1,v1,0x1
9d00bc14:	ac430004 	sw	v1,4(v0)
9d00bc18:	8e42000c 	lw	v0,12(s2)
9d00bc1c:	8e430008 	lw	v1,8(s2)
9d00bc20:	ac62000c 	sw	v0,12(v1)
9d00bc24:	0b402fb2 	j	9d00bec8 <_malloc_r+0x644>
9d00bc28:	ac430008 	sw	v1,8(v0)
9d00bc2c:	5647ffdf 	bnel	s2,a3,9d00bbac <_malloc_r+0x328>
9d00bc30:	8e480004 	lw	t0,4(s2)
9d00bc34:	24c60001 	addiu	a2,a2,1
9d00bc38:	30c50003 	andi	a1,a2,0x3
9d00bc3c:	14a0ffd9 	bnez	a1,9d00bba4 <_malloc_r+0x320>
9d00bc40:	24e70008 	addiu	a3,a3,8
9d00bc44:	01202821 	move	a1,t1
9d00bc48:	30870003 	andi	a3,a0,0x3
9d00bc4c:	14e00006 	bnez	a3,9d00bc68 <_malloc_r+0x3e4>
9d00bc50:	24a7fff8 	addiu	a3,a1,-8
9d00bc54:	8e250004 	lw	a1,4(s1)
9d00bc58:	00022027 	nor	a0,zero,v0
9d00bc5c:	00a42024 	and	a0,a1,a0
9d00bc60:	0b402f1d 	j	9d00bc74 <_malloc_r+0x3f0>
9d00bc64:	ae240004 	sw	a0,4(s1)
9d00bc68:	8ca50000 	lw	a1,0(a1)
9d00bc6c:	10a7fff6 	beq	a1,a3,9d00bc48 <_malloc_r+0x3c4>
9d00bc70:	2484ffff 	addiu	a0,a0,-1
9d00bc74:	8e250004 	lw	a1,4(s1)
9d00bc78:	00021040 	sll	v0,v0,0x1
9d00bc7c:	00a2202b 	sltu	a0,a1,v0
9d00bc80:	5480000c 	bnezl	a0,9d00bcb4 <_malloc_r+0x430>
9d00bc84:	8e340008 	lw	s4,8(s1)
9d00bc88:	10400009 	beqz	v0,9d00bcb0 <_malloc_r+0x42c>
9d00bc8c:	00c02021 	move	a0,a2
9d00bc90:	0b402f28 	j	9d00bca0 <_malloc_r+0x41c>
9d00bc94:	00453024 	and	a2,v0,a1
9d00bc98:	00021040 	sll	v0,v0,0x1
9d00bc9c:	00453024 	and	a2,v0,a1
9d00bca0:	14c0ffbd 	bnez	a2,9d00bb98 <_malloc_r+0x314>
9d00bca4:	000448c0 	sll	t1,a0,0x3
9d00bca8:	0b402f26 	j	9d00bc98 <_malloc_r+0x414>
9d00bcac:	24840004 	addiu	a0,a0,4
9d00bcb0:	8e340008 	lw	s4,8(s1)
9d00bcb4:	2415fffc 	li	s5,-4
9d00bcb8:	8e820004 	lw	v0,4(s4)
9d00bcbc:	02a2a824 	and	s5,s5,v0
9d00bcc0:	02b0102b 	sltu	v0,s5,s0
9d00bcc4:	14400004 	bnez	v0,9d00bcd8 <_malloc_r+0x454>
9d00bcc8:	02b01023 	subu	v0,s5,s0
9d00bccc:	28430010 	slti	v1,v0,16
9d00bcd0:	50600077 	beqzl	v1,9d00beb0 <_malloc_r+0x62c>
9d00bcd4:	8e320008 	lw	s2,8(s1)
9d00bcd8:	3c02a000 	lui	v0,0xa000
9d00bcdc:	8c560a28 	lw	s6,2600(v0)
9d00bce0:	3c1ea000 	lui	s8,0xa000
9d00bce4:	8fc3093c 	lw	v1,2364(s8)
9d00bce8:	26d60010 	addiu	s6,s6,16
9d00bcec:	2402ffff 	li	v0,-1
9d00bcf0:	10620004 	beq	v1,v0,9d00bd04 <_malloc_r+0x480>
9d00bcf4:	02d0b021 	addu	s6,s6,s0
9d00bcf8:	26d6007f 	addiu	s6,s6,127
9d00bcfc:	2402ff80 	li	v0,-128
9d00bd00:	02c2b024 	and	s6,s6,v0
9d00bd04:	02602021 	move	a0,s3
9d00bd08:	0f402fe6 	jal	9d00bf98 <_sbrk_r>
9d00bd0c:	02c02821 	move	a1,s6
9d00bd10:	00409021 	move	s2,v0
9d00bd14:	2402ffff 	li	v0,-1
9d00bd18:	12420056 	beq	s2,v0,9d00be74 <_malloc_r+0x5f0>
9d00bd1c:	02951021 	addu	v0,s4,s5
9d00bd20:	0242182b 	sltu	v1,s2,v0
9d00bd24:	10600004 	beqz	v1,9d00bd38 <_malloc_r+0x4b4>
9d00bd28:	3c17a001 	lui	s7,0xa001
9d00bd2c:	56910052 	bnel	s4,s1,9d00be78 <_malloc_r+0x5f4>
9d00bd30:	8e220008 	lw	v0,8(s1)
9d00bd34:	3c17a001 	lui	s7,0xa001
9d00bd38:	8ee39a18 	lw	v1,-26088(s7)
9d00bd3c:	02c31821 	addu	v1,s6,v1
9d00bd40:	16420009 	bne	s2,v0,9d00bd68 <_malloc_r+0x4e4>
9d00bd44:	aee39a18 	sw	v1,-26088(s7)
9d00bd48:	3244007f 	andi	a0,s2,0x7f
9d00bd4c:	54800007 	bnezl	a0,9d00bd6c <_malloc_r+0x4e8>
9d00bd50:	8fc5093c 	lw	a1,2364(s8)
9d00bd54:	8e220008 	lw	v0,8(s1)
9d00bd58:	02d5a821 	addu	s5,s6,s5
9d00bd5c:	36b50001 	ori	s5,s5,0x1
9d00bd60:	0b402f92 	j	9d00be48 <_malloc_r+0x5c4>
9d00bd64:	ac550004 	sw	s5,4(v0)
9d00bd68:	8fc5093c 	lw	a1,2364(s8)
9d00bd6c:	2404ffff 	li	a0,-1
9d00bd70:	14a40004 	bne	a1,a0,9d00bd84 <_malloc_r+0x500>
9d00bd74:	02431821 	addu	v1,s2,v1
9d00bd78:	3c02a000 	lui	v0,0xa000
9d00bd7c:	0b402f63 	j	9d00bd8c <_malloc_r+0x508>
9d00bd80:	ac52093c 	sw	s2,2364(v0)
9d00bd84:	00621023 	subu	v0,v1,v0
9d00bd88:	aee29a18 	sw	v0,-26088(s7)
9d00bd8c:	32430007 	andi	v1,s2,0x7
9d00bd90:	10600004 	beqz	v1,9d00bda4 <_malloc_r+0x520>
9d00bd94:	00001021 	move	v0,zero
9d00bd98:	24020008 	li	v0,8
9d00bd9c:	00431023 	subu	v0,v0,v1
9d00bda0:	02429021 	addu	s2,s2,v0
9d00bda4:	0256b021 	addu	s6,s2,s6
9d00bda8:	24420080 	addiu	v0,v0,128
9d00bdac:	32d6007f 	andi	s6,s6,0x7f
9d00bdb0:	0056b023 	subu	s6,v0,s6
9d00bdb4:	02602021 	move	a0,s3
9d00bdb8:	0f402fe6 	jal	9d00bf98 <_sbrk_r>
9d00bdbc:	02c02821 	move	a1,s6
9d00bdc0:	2403ffff 	li	v1,-1
9d00bdc4:	14430003 	bne	v0,v1,9d00bdd4 <_malloc_r+0x550>
9d00bdc8:	8ee39a18 	lw	v1,-26088(s7)
9d00bdcc:	02401021 	move	v0,s2
9d00bdd0:	0000b021 	move	s6,zero
9d00bdd4:	00521023 	subu	v0,v0,s2
9d00bdd8:	ae320008 	sw	s2,8(s1)
9d00bddc:	02c31821 	addu	v1,s6,v1
9d00bde0:	0056b021 	addu	s6,v0,s6
9d00bde4:	36d60001 	ori	s6,s6,0x1
9d00bde8:	aee39a18 	sw	v1,-26088(s7)
9d00bdec:	12910016 	beq	s4,s1,9d00be48 <_malloc_r+0x5c4>
9d00bdf0:	ae560004 	sw	s6,4(s2)
9d00bdf4:	2ea20010 	sltiu	v0,s5,16
9d00bdf8:	10400004 	beqz	v0,9d00be0c <_malloc_r+0x588>
9d00bdfc:	2402fff8 	li	v0,-8
9d00be00:	24020001 	li	v0,1
9d00be04:	0b402f9d 	j	9d00be74 <_malloc_r+0x5f0>
9d00be08:	ae420004 	sw	v0,4(s2)
9d00be0c:	26b5fff4 	addiu	s5,s5,-12
9d00be10:	02a2a824 	and	s5,s5,v0
9d00be14:	8e820004 	lw	v0,4(s4)
9d00be18:	24030005 	li	v1,5
9d00be1c:	30420001 	andi	v0,v0,0x1
9d00be20:	02a21025 	or	v0,s5,v0
9d00be24:	ae820004 	sw	v0,4(s4)
9d00be28:	02951021 	addu	v0,s4,s5
9d00be2c:	2eb50010 	sltiu	s5,s5,16
9d00be30:	ac430004 	sw	v1,4(v0)
9d00be34:	16a00004 	bnez	s5,9d00be48 <_malloc_r+0x5c4>
9d00be38:	ac430008 	sw	v1,8(v0)
9d00be3c:	02602021 	move	a0,s3
9d00be40:	0f4030b0 	jal	9d00c2c0 <_free_r>
9d00be44:	26850008 	addiu	a1,s4,8
9d00be48:	3c03a000 	lui	v1,0xa000
9d00be4c:	8ee29a18 	lw	v0,-26088(s7)
9d00be50:	8c640a2c 	lw	a0,2604(v1)
9d00be54:	0082202b 	sltu	a0,a0,v0
9d00be58:	54800001 	bnezl	a0,9d00be60 <_malloc_r+0x5dc>
9d00be5c:	ac620a2c 	sw	v0,2604(v1)
9d00be60:	3c03a000 	lui	v1,0xa000
9d00be64:	8c640a30 	lw	a0,2608(v1)
9d00be68:	0082202b 	sltu	a0,a0,v0
9d00be6c:	54800001 	bnezl	a0,9d00be74 <_malloc_r+0x5f0>
9d00be70:	ac620a30 	sw	v0,2608(v1)
9d00be74:	8e220008 	lw	v0,8(s1)
9d00be78:	2403fffc 	li	v1,-4
9d00be7c:	8c420004 	lw	v0,4(v0)
9d00be80:	00621024 	and	v0,v1,v0
9d00be84:	0050182b 	sltu	v1,v0,s0
9d00be88:	14600005 	bnez	v1,9d00bea0 <_malloc_r+0x61c>
9d00be8c:	00000000 	nop
9d00be90:	00501023 	subu	v0,v0,s0
9d00be94:	28430010 	slti	v1,v0,16
9d00be98:	50600005 	beqzl	v1,9d00beb0 <_malloc_r+0x62c>
9d00be9c:	8e320008 	lw	s2,8(s1)
9d00bea0:	0f402fe4 	jal	9d00bf90 <__malloc_unlock>
9d00bea4:	02602021 	move	a0,s3
9d00bea8:	0b402fb5 	j	9d00bed4 <_malloc_r+0x650>
9d00beac:	00001021 	move	v0,zero
9d00beb0:	36030001 	ori	v1,s0,0x1
9d00beb4:	34420001 	ori	v0,v0,0x1
9d00beb8:	02508021 	addu	s0,s2,s0
9d00bebc:	ae430004 	sw	v1,4(s2)
9d00bec0:	ae300008 	sw	s0,8(s1)
9d00bec4:	ae020004 	sw	v0,4(s0)
9d00bec8:	0f402fe4 	jal	9d00bf90 <__malloc_unlock>
9d00becc:	02602021 	move	a0,s3
9d00bed0:	26420008 	addiu	v0,s2,8
9d00bed4:	8fbf0034 	lw	ra,52(sp)
9d00bed8:	8fbe0030 	lw	s8,48(sp)
9d00bedc:	8fb7002c 	lw	s7,44(sp)
9d00bee0:	8fb60028 	lw	s6,40(sp)
9d00bee4:	8fb50024 	lw	s5,36(sp)
9d00bee8:	8fb40020 	lw	s4,32(sp)
9d00beec:	8fb3001c 	lw	s3,28(sp)
9d00bef0:	8fb20018 	lw	s2,24(sp)
9d00bef4:	8fb10014 	lw	s1,20(sp)
9d00bef8:	8fb00010 	lw	s0,16(sp)
9d00befc:	03e00008 	jr	ra
9d00bf00:	27bd0038 	addiu	sp,sp,56

9d00bf04 <memcmp>:
9d00bf04:	0b402fca 	j	9d00bf28 <memcmp+0x24>
9d00bf08:	00000000 	nop
9d00bf0c:	90a20000 	lbu	v0,0(a1)
9d00bf10:	10620003 	beq	v1,v0,9d00bf20 <memcmp+0x1c>
9d00bf14:	24c6ffff 	addiu	a2,a2,-1
9d00bf18:	03e00008 	jr	ra
9d00bf1c:	00621023 	subu	v0,v1,v0
9d00bf20:	24840001 	addiu	a0,a0,1
9d00bf24:	24a50001 	addiu	a1,a1,1
9d00bf28:	54c0fff8 	bnezl	a2,9d00bf0c <memcmp+0x8>
9d00bf2c:	90830000 	lbu	v1,0(a0)
9d00bf30:	03e00008 	jr	ra
9d00bf34:	00001021 	move	v0,zero

9d00bf38 <memcpy>:
9d00bf38:	00801021 	move	v0,a0
9d00bf3c:	0b402fd5 	j	9d00bf54 <memcpy+0x1c>
9d00bf40:	00801821 	move	v1,a0
9d00bf44:	24c6ffff 	addiu	a2,a2,-1
9d00bf48:	24a50001 	addiu	a1,a1,1
9d00bf4c:	a0640000 	sb	a0,0(v1)
9d00bf50:	24630001 	addiu	v1,v1,1
9d00bf54:	54c0fffb 	bnezl	a2,9d00bf44 <memcpy+0xc>
9d00bf58:	90a40000 	lbu	a0,0(a1)
9d00bf5c:	03e00008 	jr	ra
9d00bf60:	00000000 	nop

9d00bf64 <memset>:
9d00bf64:	00801021 	move	v0,a0
9d00bf68:	0b402fde 	j	9d00bf78 <memset+0x14>
9d00bf6c:	00801821 	move	v1,a0
9d00bf70:	24c6ffff 	addiu	a2,a2,-1
9d00bf74:	24630001 	addiu	v1,v1,1
9d00bf78:	54c0fffd 	bnezl	a2,9d00bf70 <memset+0xc>
9d00bf7c:	a0650000 	sb	a1,0(v1)
9d00bf80:	03e00008 	jr	ra
9d00bf84:	00000000 	nop

9d00bf88 <__malloc_lock>:
9d00bf88:	03e00008 	jr	ra
9d00bf8c:	00000000 	nop

9d00bf90 <__malloc_unlock>:
9d00bf90:	03e00008 	jr	ra
9d00bf94:	00000000 	nop

9d00bf98 <_sbrk_r>:
9d00bf98:	27bdffe0 	addiu	sp,sp,-32
9d00bf9c:	afb10018 	sw	s1,24(sp)
9d00bfa0:	afb00014 	sw	s0,20(sp)
9d00bfa4:	00808821 	move	s1,a0
9d00bfa8:	3c10a000 	lui	s0,0xa000
9d00bfac:	00a02021 	move	a0,a1
9d00bfb0:	afbf001c 	sw	ra,28(sp)
9d00bfb4:	0f403236 	jal	9d00c8d8 <sbrk>
9d00bfb8:	ae000a74 	sw	zero,2676(s0)
9d00bfbc:	2403ffff 	li	v1,-1
9d00bfc0:	14430005 	bne	v0,v1,9d00bfd8 <_sbrk_r+0x40>
9d00bfc4:	8fbf001c 	lw	ra,28(sp)
9d00bfc8:	8e030a74 	lw	v1,2676(s0)
9d00bfcc:	54600001 	bnezl	v1,9d00bfd4 <_sbrk_r+0x3c>
9d00bfd0:	ae230000 	sw	v1,0(s1)
9d00bfd4:	8fbf001c 	lw	ra,28(sp)
9d00bfd8:	8fb10018 	lw	s1,24(sp)
9d00bfdc:	8fb00014 	lw	s0,20(sp)
9d00bfe0:	03e00008 	jr	ra
9d00bfe4:	27bd0020 	addiu	sp,sp,32

9d00bfe8 <strcmp>:
9d00bfe8:	00a41025 	or	v0,a1,a0
9d00bfec:	30420001 	andi	v0,v0,0x1
9d00bff0:	1440000e 	bnez	v0,9d00c02c <strcmp+0x44>
9d00bff4:	90830000 	lbu	v1,0(a0)
9d00bff8:	10600012 	beqz	v1,9d00c044 <strcmp+0x5c>
9d00bffc:	90a20000 	lbu	v0,0(a1)
9d00c000:	24840002 	addiu	a0,a0,2
9d00c004:	1462000f 	bne	v1,v0,9d00c044 <strcmp+0x5c>
9d00c008:	9086ffff 	lbu	a2,-1(a0)
9d00c00c:	10c00005 	beqz	a2,9d00c024 <strcmp+0x3c>
9d00c010:	90a20001 	lbu	v0,1(a1)
9d00c014:	14c20003 	bne	a2,v0,9d00c024 <strcmp+0x3c>
9d00c018:	90830000 	lbu	v1,0(a0)
9d00c01c:	0b402ffe 	j	9d00bff8 <strcmp+0x10>
9d00c020:	24a50002 	addiu	a1,a1,2
9d00c024:	03e00008 	jr	ra
9d00c028:	00c21023 	subu	v0,a2,v0
9d00c02c:	90a20000 	lbu	v0,0(a1)
9d00c030:	24840001 	addiu	a0,a0,1
9d00c034:	10600003 	beqz	v1,9d00c044 <strcmp+0x5c>
9d00c038:	24a50001 	addiu	a1,a1,1
9d00c03c:	5062fffb 	beql	v1,v0,9d00c02c <strcmp+0x44>
9d00c040:	90830000 	lbu	v1,0(a0)
9d00c044:	03e00008 	jr	ra
9d00c048:	00621023 	subu	v0,v1,v0

9d00c04c <strcpy>:
9d00c04c:	00801021 	move	v0,a0
9d00c050:	00801821 	move	v1,a0
9d00c054:	80a40000 	lb	a0,0(a1)
9d00c058:	24a50001 	addiu	a1,a1,1
9d00c05c:	a0640000 	sb	a0,0(v1)
9d00c060:	1480fffc 	bnez	a0,9d00c054 <strcpy+0x8>
9d00c064:	24630001 	addiu	v1,v1,1
9d00c068:	03e00008 	jr	ra
9d00c06c:	00000000 	nop

9d00c070 <strlen>:
9d00c070:	24820001 	addiu	v0,a0,1
9d00c074:	90830000 	lbu	v1,0(a0)
9d00c078:	1460fffe 	bnez	v1,9d00c074 <strlen+0x4>
9d00c07c:	24840001 	addiu	a0,a0,1
9d00c080:	03e00008 	jr	ra
9d00c084:	00821023 	subu	v0,a0,v0

9d00c088 <__register_exitproc>:
9d00c088:	27bdffd0 	addiu	sp,sp,-48
9d00c08c:	3c02a000 	lui	v0,0xa000
9d00c090:	afb10024 	sw	s1,36(sp)
9d00c094:	8c510934 	lw	s1,2356(v0)
9d00c098:	afb00020 	sw	s0,32(sp)
9d00c09c:	afbf002c 	sw	ra,44(sp)
9d00c0a0:	8e220148 	lw	v0,328(s1)
9d00c0a4:	afb20028 	sw	s2,40(sp)
9d00c0a8:	14400003 	bnez	v0,9d00c0b8 <__register_exitproc+0x30>
9d00c0ac:	00808021 	move	s0,a0
9d00c0b0:	2622014c 	addiu	v0,s1,332
9d00c0b4:	ae220148 	sw	v0,328(s1)
9d00c0b8:	8c430004 	lw	v1,4(v0)
9d00c0bc:	28630020 	slti	v1,v1,32
9d00c0c0:	14600014 	bnez	v1,9d00c114 <__register_exitproc+0x8c>
9d00c0c4:	00000000 	nop
9d00c0c8:	3c029d01 	lui	v0,0x9d01
9d00c0cc:	2442b834 	addiu	v0,v0,-18380
9d00c0d0:	1040002c 	beqz	v0,9d00c184 <__register_exitproc+0xfc>
9d00c0d4:	2412ffff 	li	s2,-1
9d00c0d8:	24040190 	li	a0,400
9d00c0dc:	afa50010 	sw	a1,16(sp)
9d00c0e0:	afa60014 	sw	a2,20(sp)
9d00c0e4:	0f402e0d 	jal	9d00b834 <malloc>
9d00c0e8:	afa70018 	sw	a3,24(sp)
9d00c0ec:	8fa50010 	lw	a1,16(sp)
9d00c0f0:	8fa60014 	lw	a2,20(sp)
9d00c0f4:	10400023 	beqz	v0,9d00c184 <__register_exitproc+0xfc>
9d00c0f8:	8fa70018 	lw	a3,24(sp)
9d00c0fc:	8e230148 	lw	v1,328(s1)
9d00c100:	ac400004 	sw	zero,4(v0)
9d00c104:	ac430000 	sw	v1,0(v0)
9d00c108:	ae220148 	sw	v0,328(s1)
9d00c10c:	ac400188 	sw	zero,392(v0)
9d00c110:	ac40018c 	sw	zero,396(v0)
9d00c114:	12000014 	beqz	s0,9d00c168 <__register_exitproc+0xe0>
9d00c118:	8c430004 	lw	v1,4(v0)
9d00c11c:	24640022 	addiu	a0,v1,34
9d00c120:	00042080 	sll	a0,a0,0x2
9d00c124:	00442021 	addu	a0,v0,a0
9d00c128:	ac860000 	sw	a2,0(a0)
9d00c12c:	24040001 	li	a0,1
9d00c130:	00642004 	sllv	a0,a0,v1
9d00c134:	8c460188 	lw	a2,392(v0)
9d00c138:	24630042 	addiu	v1,v1,66
9d00c13c:	00031880 	sll	v1,v1,0x2
9d00c140:	00431821 	addu	v1,v0,v1
9d00c144:	00c43025 	or	a2,a2,a0
9d00c148:	ac670000 	sw	a3,0(v1)
9d00c14c:	24030002 	li	v1,2
9d00c150:	16030004 	bne	s0,v1,9d00c164 <__register_exitproc+0xdc>
9d00c154:	ac460188 	sw	a2,392(v0)
9d00c158:	8c43018c 	lw	v1,396(v0)
9d00c15c:	00642025 	or	a0,v1,a0
9d00c160:	ac44018c 	sw	a0,396(v0)
9d00c164:	8c430004 	lw	v1,4(v0)
9d00c168:	00009021 	move	s2,zero
9d00c16c:	24640002 	addiu	a0,v1,2
9d00c170:	00042080 	sll	a0,a0,0x2
9d00c174:	00442021 	addu	a0,v0,a0
9d00c178:	24630001 	addiu	v1,v1,1
9d00c17c:	ac850000 	sw	a1,0(a0)
9d00c180:	ac430004 	sw	v1,4(v0)
9d00c184:	8fbf002c 	lw	ra,44(sp)
9d00c188:	02401021 	move	v0,s2
9d00c18c:	8fb20028 	lw	s2,40(sp)
9d00c190:	8fb10024 	lw	s1,36(sp)
9d00c194:	8fb00020 	lw	s0,32(sp)
9d00c198:	03e00008 	jr	ra
9d00c19c:	27bd0030 	addiu	sp,sp,48

9d00c1a0 <_malloc_trim_r>:
9d00c1a0:	27bdffd0 	addiu	sp,sp,-48
9d00c1a4:	afb20024 	sw	s2,36(sp)
9d00c1a8:	3c12a000 	lui	s2,0xa000
9d00c1ac:	26520508 	addiu	s2,s2,1288
9d00c1b0:	afb30028 	sw	s3,40(sp)
9d00c1b4:	afb10020 	sw	s1,32(sp)
9d00c1b8:	afb0001c 	sw	s0,28(sp)
9d00c1bc:	afa50010 	sw	a1,16(sp)
9d00c1c0:	afbf002c 	sw	ra,44(sp)
9d00c1c4:	0f402fe2 	jal	9d00bf88 <__malloc_lock>
9d00c1c8:	00808021 	move	s0,a0
9d00c1cc:	8e420008 	lw	v0,8(s2)
9d00c1d0:	2413fffc 	li	s3,-4
9d00c1d4:	8fa50010 	lw	a1,16(sp)
9d00c1d8:	8c420004 	lw	v0,4(v0)
9d00c1dc:	02629824 	and	s3,s3,v0
9d00c1e0:	2671006f 	addiu	s1,s3,111
9d00c1e4:	02258823 	subu	s1,s1,a1
9d00c1e8:	001189c2 	srl	s1,s1,0x7
9d00c1ec:	2631ffff 	addiu	s1,s1,-1
9d00c1f0:	001189c0 	sll	s1,s1,0x7
9d00c1f4:	2a220080 	slti	v0,s1,128
9d00c1f8:	1440001c 	bnez	v0,9d00c26c <_malloc_trim_r+0xcc>
9d00c1fc:	00000000 	nop
9d00c200:	02002021 	move	a0,s0
9d00c204:	0f402fe6 	jal	9d00bf98 <_sbrk_r>
9d00c208:	00002821 	move	a1,zero
9d00c20c:	8e430008 	lw	v1,8(s2)
9d00c210:	00731821 	addu	v1,v1,s3
9d00c214:	14430015 	bne	v0,v1,9d00c26c <_malloc_trim_r+0xcc>
9d00c218:	00000000 	nop
9d00c21c:	02002021 	move	a0,s0
9d00c220:	0f402fe6 	jal	9d00bf98 <_sbrk_r>
9d00c224:	00112823 	negu	a1,s1
9d00c228:	2403ffff 	li	v1,-1
9d00c22c:	54430013 	bnel	v0,v1,9d00c27c <_malloc_trim_r+0xdc>
9d00c230:	8e420008 	lw	v0,8(s2)
9d00c234:	02002021 	move	a0,s0
9d00c238:	0f402fe6 	jal	9d00bf98 <_sbrk_r>
9d00c23c:	00002821 	move	a1,zero
9d00c240:	8e430008 	lw	v1,8(s2)
9d00c244:	00432023 	subu	a0,v0,v1
9d00c248:	28850010 	slti	a1,a0,16
9d00c24c:	14a00007 	bnez	a1,9d00c26c <_malloc_trim_r+0xcc>
9d00c250:	3c05a000 	lui	a1,0xa000
9d00c254:	8ca5093c 	lw	a1,2364(a1)
9d00c258:	34840001 	ori	a0,a0,0x1
9d00c25c:	ac640004 	sw	a0,4(v1)
9d00c260:	00451023 	subu	v0,v0,a1
9d00c264:	3c05a001 	lui	a1,0xa001
9d00c268:	aca29a18 	sw	v0,-26088(a1)
9d00c26c:	0f402fe4 	jal	9d00bf90 <__malloc_unlock>
9d00c270:	02002021 	move	a0,s0
9d00c274:	0b4030a9 	j	9d00c2a4 <_malloc_trim_r+0x104>
9d00c278:	00001021 	move	v0,zero
9d00c27c:	02719823 	subu	s3,s3,s1
9d00c280:	36730001 	ori	s3,s3,0x1
9d00c284:	ac530004 	sw	s3,4(v0)
9d00c288:	3c02a001 	lui	v0,0xa001
9d00c28c:	8c439a18 	lw	v1,-26088(v0)
9d00c290:	02002021 	move	a0,s0
9d00c294:	00718823 	subu	s1,v1,s1
9d00c298:	0f402fe4 	jal	9d00bf90 <__malloc_unlock>
9d00c29c:	ac519a18 	sw	s1,-26088(v0)
9d00c2a0:	24020001 	li	v0,1
9d00c2a4:	8fbf002c 	lw	ra,44(sp)
9d00c2a8:	8fb30028 	lw	s3,40(sp)
9d00c2ac:	8fb20024 	lw	s2,36(sp)
9d00c2b0:	8fb10020 	lw	s1,32(sp)
9d00c2b4:	8fb0001c 	lw	s0,28(sp)
9d00c2b8:	03e00008 	jr	ra
9d00c2bc:	27bd0030 	addiu	sp,sp,48

9d00c2c0 <_free_r>:
9d00c2c0:	27bdffe0 	addiu	sp,sp,-32
9d00c2c4:	afb00018 	sw	s0,24(sp)
9d00c2c8:	afbf001c 	sw	ra,28(sp)
9d00c2cc:	10a00093 	beqz	a1,9d00c51c <_free_r+0x25c>
9d00c2d0:	00808021 	move	s0,a0
9d00c2d4:	0f402fe2 	jal	9d00bf88 <__malloc_lock>
9d00c2d8:	afa50010 	sw	a1,16(sp)
9d00c2dc:	8fa50010 	lw	a1,16(sp)
9d00c2e0:	2403fffe 	li	v1,-2
9d00c2e4:	2408fffc 	li	t0,-4
9d00c2e8:	24a2fff8 	addiu	v0,a1,-8
9d00c2ec:	8c490004 	lw	t1,4(v0)
9d00c2f0:	01231824 	and	v1,t1,v1
9d00c2f4:	00433021 	addu	a2,v0,v1
9d00c2f8:	8cc40004 	lw	a0,4(a2)
9d00c2fc:	01044024 	and	t0,t0,a0
9d00c300:	3c04a000 	lui	a0,0xa000
9d00c304:	24840508 	addiu	a0,a0,1288
9d00c308:	8c870008 	lw	a3,8(a0)
9d00c30c:	14c70017 	bne	a2,a3,9d00c36c <_free_r+0xac>
9d00c310:	31290001 	andi	t1,t1,0x1
9d00c314:	15200008 	bnez	t1,9d00c338 <_free_r+0x78>
9d00c318:	01031821 	addu	v1,t0,v1
9d00c31c:	8ca5fff8 	lw	a1,-8(a1)
9d00c320:	00451023 	subu	v0,v0,a1
9d00c324:	8c460008 	lw	a2,8(v0)
9d00c328:	00651821 	addu	v1,v1,a1
9d00c32c:	8c45000c 	lw	a1,12(v0)
9d00c330:	acc5000c 	sw	a1,12(a2)
9d00c334:	aca60008 	sw	a2,8(a1)
9d00c338:	34650001 	ori	a1,v1,0x1
9d00c33c:	ac450004 	sw	a1,4(v0)
9d00c340:	ac820008 	sw	v0,8(a0)
9d00c344:	3c02a000 	lui	v0,0xa000
9d00c348:	8c480938 	lw	t0,2360(v0)
9d00c34c:	0068182b 	sltu	v1,v1,t0
9d00c350:	14600070 	bnez	v1,9d00c514 <_free_r+0x254>
9d00c354:	3c02a000 	lui	v0,0xa000
9d00c358:	8c450a28 	lw	a1,2600(v0)
9d00c35c:	0f403068 	jal	9d00c1a0 <_malloc_trim_r>
9d00c360:	02002021 	move	a0,s0
9d00c364:	0b403145 	j	9d00c514 <_free_r+0x254>
9d00c368:	00000000 	nop
9d00c36c:	acc80004 	sw	t0,4(a2)
9d00c370:	1520000c 	bnez	t1,9d00c3a4 <_free_r+0xe4>
9d00c374:	00003821 	move	a3,zero
9d00c378:	8ca5fff8 	lw	a1,-8(a1)
9d00c37c:	24890008 	addiu	t1,a0,8
9d00c380:	00451023 	subu	v0,v0,a1
9d00c384:	00651821 	addu	v1,v1,a1
9d00c388:	8c450008 	lw	a1,8(v0)
9d00c38c:	10a90005 	beq	a1,t1,9d00c3a4 <_free_r+0xe4>
9d00c390:	24070001 	li	a3,1
9d00c394:	8c47000c 	lw	a3,12(v0)
9d00c398:	aca7000c 	sw	a3,12(a1)
9d00c39c:	ace50008 	sw	a1,8(a3)
9d00c3a0:	00003821 	move	a3,zero
9d00c3a4:	00c82821 	addu	a1,a2,t0
9d00c3a8:	8ca50004 	lw	a1,4(a1)
9d00c3ac:	30a50001 	andi	a1,a1,0x1
9d00c3b0:	14a00011 	bnez	a1,9d00c3f8 <_free_r+0x138>
9d00c3b4:	34650001 	ori	a1,v1,0x1
9d00c3b8:	00681821 	addu	v1,v1,t0
9d00c3bc:	14e0000a 	bnez	a3,9d00c3e8 <_free_r+0x128>
9d00c3c0:	8cc50008 	lw	a1,8(a2)
9d00c3c4:	24880008 	addiu	t0,a0,8
9d00c3c8:	54a80008 	bnel	a1,t0,9d00c3ec <_free_r+0x12c>
9d00c3cc:	8cc6000c 	lw	a2,12(a2)
9d00c3d0:	aca2000c 	sw	v0,12(a1)
9d00c3d4:	aca20008 	sw	v0,8(a1)
9d00c3d8:	ac45000c 	sw	a1,12(v0)
9d00c3dc:	ac450008 	sw	a1,8(v0)
9d00c3e0:	0b4030fd 	j	9d00c3f4 <_free_r+0x134>
9d00c3e4:	24070001 	li	a3,1
9d00c3e8:	8cc6000c 	lw	a2,12(a2)
9d00c3ec:	aca6000c 	sw	a2,12(a1)
9d00c3f0:	acc50008 	sw	a1,8(a2)
9d00c3f4:	34650001 	ori	a1,v1,0x1
9d00c3f8:	ac450004 	sw	a1,4(v0)
9d00c3fc:	00432821 	addu	a1,v0,v1
9d00c400:	14e00044 	bnez	a3,9d00c514 <_free_r+0x254>
9d00c404:	aca30000 	sw	v1,0(a1)
9d00c408:	2c650200 	sltiu	a1,v1,512
9d00c40c:	10a00010 	beqz	a1,9d00c450 <_free_r+0x190>
9d00c410:	00033242 	srl	a2,v1,0x9
9d00c414:	000318c2 	srl	v1,v1,0x3
9d00c418:	00032883 	sra	a1,v1,0x2
9d00c41c:	24060001 	li	a2,1
9d00c420:	00a62804 	sllv	a1,a2,a1
9d00c424:	8c860004 	lw	a2,4(a0)
9d00c428:	000318c0 	sll	v1,v1,0x3
9d00c42c:	00c52825 	or	a1,a2,a1
9d00c430:	ac850004 	sw	a1,4(a0)
9d00c434:	00832021 	addu	a0,a0,v1
9d00c438:	8c830008 	lw	v1,8(a0)
9d00c43c:	ac44000c 	sw	a0,12(v0)
9d00c440:	ac430008 	sw	v1,8(v0)
9d00c444:	ac62000c 	sw	v0,12(v1)
9d00c448:	0b403145 	j	9d00c514 <_free_r+0x254>
9d00c44c:	ac820008 	sw	v0,8(a0)
9d00c450:	2cc50005 	sltiu	a1,a2,5
9d00c454:	10a00004 	beqz	a1,9d00c468 <_free_r+0x1a8>
9d00c458:	2cc50015 	sltiu	a1,a2,21
9d00c45c:	00033182 	srl	a2,v1,0x6
9d00c460:	0b40312c 	j	9d00c4b0 <_free_r+0x1f0>
9d00c464:	24c60038 	addiu	a2,a2,56
9d00c468:	10a00003 	beqz	a1,9d00c478 <_free_r+0x1b8>
9d00c46c:	2cc50055 	sltiu	a1,a2,85
9d00c470:	0b40312c 	j	9d00c4b0 <_free_r+0x1f0>
9d00c474:	24c6005b 	addiu	a2,a2,91
9d00c478:	10a00004 	beqz	a1,9d00c48c <_free_r+0x1cc>
9d00c47c:	2cc50155 	sltiu	a1,a2,341
9d00c480:	00033302 	srl	a2,v1,0xc
9d00c484:	0b40312c 	j	9d00c4b0 <_free_r+0x1f0>
9d00c488:	24c6006e 	addiu	a2,a2,110
9d00c48c:	10a00004 	beqz	a1,9d00c4a0 <_free_r+0x1e0>
9d00c490:	2cc50555 	sltiu	a1,a2,1365
9d00c494:	000333c2 	srl	a2,v1,0xf
9d00c498:	0b40312c 	j	9d00c4b0 <_free_r+0x1f0>
9d00c49c:	24c60077 	addiu	a2,a2,119
9d00c4a0:	10a00003 	beqz	a1,9d00c4b0 <_free_r+0x1f0>
9d00c4a4:	2406007e 	li	a2,126
9d00c4a8:	00033482 	srl	a2,v1,0x12
9d00c4ac:	24c6007c 	addiu	a2,a2,124
9d00c4b0:	000638c0 	sll	a3,a2,0x3
9d00c4b4:	00873821 	addu	a3,a0,a3
9d00c4b8:	8ce50008 	lw	a1,8(a3)
9d00c4bc:	14a7000b 	bne	a1,a3,9d00c4ec <_free_r+0x22c>
9d00c4c0:	2408fffc 	li	t0,-4
9d00c4c4:	24030001 	li	v1,1
9d00c4c8:	00063083 	sra	a2,a2,0x2
9d00c4cc:	00c33004 	sllv	a2,v1,a2
9d00c4d0:	8c830004 	lw	v1,4(a0)
9d00c4d4:	00663025 	or	a2,v1,a2
9d00c4d8:	ac860004 	sw	a2,4(a0)
9d00c4dc:	0b403141 	j	9d00c504 <_free_r+0x244>
9d00c4e0:	00a01821 	move	v1,a1
9d00c4e4:	50a70007 	beql	a1,a3,9d00c504 <_free_r+0x244>
9d00c4e8:	8ca3000c 	lw	v1,12(a1)
9d00c4ec:	8ca40004 	lw	a0,4(a1)
9d00c4f0:	01042024 	and	a0,t0,a0
9d00c4f4:	0064202b 	sltu	a0,v1,a0
9d00c4f8:	5480fffa 	bnezl	a0,9d00c4e4 <_free_r+0x224>
9d00c4fc:	8ca50008 	lw	a1,8(a1)
9d00c500:	8ca3000c 	lw	v1,12(a1)
9d00c504:	ac43000c 	sw	v1,12(v0)
9d00c508:	ac450008 	sw	a1,8(v0)
9d00c50c:	aca2000c 	sw	v0,12(a1)
9d00c510:	ac620008 	sw	v0,8(v1)
9d00c514:	0f402fe4 	jal	9d00bf90 <__malloc_unlock>
9d00c518:	02002021 	move	a0,s0
9d00c51c:	8fbf001c 	lw	ra,28(sp)
9d00c520:	8fb00018 	lw	s0,24(sp)
9d00c524:	03e00008 	jr	ra
9d00c528:	27bd0020 	addiu	sp,sp,32

9d00c52c <__cxa_guard_acquire>:
9d00c52c:	80830000 	lb	v1,0(a0)
9d00c530:	14600006 	bnez	v1,9d00c54c <__cxa_guard_acquire+0x20>
9d00c534:	00001021 	move	v0,zero
9d00c538:	80830001 	lb	v1,1(a0)
9d00c53c:	24020001 	li	v0,1
9d00c540:	046e0000 	tnei	v1,0
9d00c544:	24030001 	li	v1,1
9d00c548:	a0830001 	sb	v1,1(a0)
9d00c54c:	03e00008 	jr	ra
9d00c550:	00000000 	nop

9d00c554 <__cxa_guard_release>:
9d00c554:	24020001 	li	v0,1
9d00c558:	a0800001 	sb	zero,1(a0)
9d00c55c:	03e00008 	jr	ra
9d00c560:	a0820000 	sb	v0,0(a0)

9d00c564 <_general_exception_context>:
9d00c564:	27bdffa8 	addiu	sp,sp,-88
9d00c568:	afa10004 	sw	at,4(sp)
9d00c56c:	afa20008 	sw	v0,8(sp)
9d00c570:	afa3000c 	sw	v1,12(sp)
9d00c574:	afa40010 	sw	a0,16(sp)
9d00c578:	afa50014 	sw	a1,20(sp)
9d00c57c:	afa60018 	sw	a2,24(sp)
9d00c580:	afa7001c 	sw	a3,28(sp)
9d00c584:	afa80020 	sw	t0,32(sp)
9d00c588:	afa90024 	sw	t1,36(sp)
9d00c58c:	afaa0028 	sw	t2,40(sp)
9d00c590:	afab002c 	sw	t3,44(sp)
9d00c594:	afac0030 	sw	t4,48(sp)
9d00c598:	afad0034 	sw	t5,52(sp)
9d00c59c:	afae0038 	sw	t6,56(sp)
9d00c5a0:	afaf003c 	sw	t7,60(sp)
9d00c5a4:	afb80040 	sw	t8,64(sp)
9d00c5a8:	afb90044 	sw	t9,68(sp)
9d00c5ac:	afbf0048 	sw	ra,72(sp)
9d00c5b0:	00004012 	mflo	t0
9d00c5b4:	afa8004c 	sw	t0,76(sp)
9d00c5b8:	00004010 	mfhi	t0
9d00c5bc:	afa80050 	sw	t0,80(sp)
9d00c5c0:	40046800 	mfc0	a0,c0_cause
9d00c5c4:	40056000 	mfc0	a1,c0_status
9d00c5c8:	0f4007b2 	jal	9d001ec8 <_general_exception_handler>
9d00c5cc:	00000000 	nop
9d00c5d0:	8fa80050 	lw	t0,80(sp)
9d00c5d4:	01000011 	mthi	t0
9d00c5d8:	8fa8004c 	lw	t0,76(sp)
9d00c5dc:	01000013 	mtlo	t0
9d00c5e0:	8fa10004 	lw	at,4(sp)
9d00c5e4:	8fa20008 	lw	v0,8(sp)
9d00c5e8:	8fa3000c 	lw	v1,12(sp)
9d00c5ec:	8fa40010 	lw	a0,16(sp)
9d00c5f0:	8fa50014 	lw	a1,20(sp)
9d00c5f4:	8fa60018 	lw	a2,24(sp)
9d00c5f8:	8fa7001c 	lw	a3,28(sp)
9d00c5fc:	8fa80020 	lw	t0,32(sp)
9d00c600:	8fa90024 	lw	t1,36(sp)
9d00c604:	8faa0028 	lw	t2,40(sp)
9d00c608:	8fab002c 	lw	t3,44(sp)
9d00c60c:	8fac0030 	lw	t4,48(sp)
9d00c610:	8fad0034 	lw	t5,52(sp)
9d00c614:	8fae0038 	lw	t6,56(sp)
9d00c618:	8faf003c 	lw	t7,60(sp)
9d00c61c:	8fb80040 	lw	t8,64(sp)
9d00c620:	8fb90044 	lw	t9,68(sp)
9d00c624:	8fbf0048 	lw	ra,72(sp)
9d00c628:	27bd0058 	addiu	sp,sp,88
9d00c62c:	000000c0 	ehb
9d00c630:	42000018 	eret

9d00c634 <_on_reset>:
9d00c634:	03e00008 	jr	ra
9d00c638:	00000000 	nop

9d00c63c <_on_bootstrap>:
9d00c63c:	03e00008 	jr	ra
9d00c640:	00000000 	nop

9d00c644 <_nmi_handler>:
9d00c644:	401a6000 	mfc0	k0,c0_status
9d00c648:	3c1bffbf 	lui	k1,0xffbf
9d00c64c:	377bffff 	ori	k1,k1,0xffff
9d00c650:	035bd024 	and	k0,k0,k1
9d00c654:	409a6000 	mtc0	k0,c0_status
9d00c658:	42000018 	eret

9d00c65c <_stub_sbd_memlayout>:
9d00c65c:	3c03a001 	lui	v1,0xa001
9d00c660:	24629a44 	addiu	v0,v1,-26044
9d00c664:	24040001 	li	a0,1
9d00c668:	ac440008 	sw	a0,8(v0)
9d00c66c:	3c04a001 	lui	a0,0xa001
9d00c670:	24849b28 	addiu	a0,a0,-25816
9d00c674:	ac649a44 	sw	a0,-26044(v1)
9d00c678:	3c030000 	lui	v1,0x0
9d00c67c:	24632000 	addiu	v1,v1,8192
9d00c680:	03e00008 	jr	ra
9d00c684:	ac430004 	sw	v1,4(v0)

9d00c688 <_sbrk_init>:
9d00c688:	27bdffd8 	addiu	sp,sp,-40
9d00c68c:	afb00010 	sw	s0,16(sp)
9d00c690:	3c10a001 	lui	s0,0xa001
9d00c694:	8e029a40 	lw	v0,-26048(s0)
9d00c698:	afbf0024 	sw	ra,36(sp)
9d00c69c:	afb40020 	sw	s4,32(sp)
9d00c6a0:	afb3001c 	sw	s3,28(sp)
9d00c6a4:	afb20018 	sw	s2,24(sp)
9d00c6a8:	10400009 	beqz	v0,9d00c6d0 <_sbrk_init+0x48>
9d00c6ac:	afb10014 	sw	s1,20(sp)
9d00c6b0:	8fbf0024 	lw	ra,36(sp)
9d00c6b4:	8fb40020 	lw	s4,32(sp)
9d00c6b8:	8fb3001c 	lw	s3,28(sp)
9d00c6bc:	8fb20018 	lw	s2,24(sp)
9d00c6c0:	8fb10014 	lw	s1,20(sp)
9d00c6c4:	8fb00010 	lw	s0,16(sp)
9d00c6c8:	03e00008 	jr	ra
9d00c6cc:	27bd0028 	addiu	sp,sp,40
9d00c6d0:	3c13a000 	lui	s3,0xa000
9d00c6d4:	8e630a34 	lw	v1,2612(s3)
9d00c6d8:	50600040 	beqzl	v1,9d00c7dc <_sbrk_init+0x154>
9d00c6dc:	3c03a001 	lui	v1,0xa001
9d00c6e0:	3c14a000 	lui	s4,0xa000
9d00c6e4:	8e820a38 	lw	v0,2616(s4)
9d00c6e8:	10400039 	beqz	v0,9d00c7d0 <_sbrk_init+0x148>
9d00c6ec:	00000000 	nop
9d00c6f0:	00038f82 	srl	s1,v1,0x1e
9d00c6f4:	00029782 	srl	s2,v0,0x1e
9d00c6f8:	7c44e000 	ext	a0,v0,0x0,0x1d
9d00c6fc:	7c65e000 	ext	a1,v1,0x0,0x1d
9d00c700:	3a310002 	xori	s1,s1,0x2
9d00c704:	3a520002 	xori	s2,s2,0x2
9d00c708:	00b1180a 	movz	v1,a1,s1
9d00c70c:	0092100a 	movz	v0,a0,s2
9d00c710:	00608821 	move	s1,v1
9d00c714:	0f403197 	jal	9d00c65c <_stub_sbd_memlayout>
9d00c718:	00409021 	move	s2,v0
9d00c71c:	8c430000 	lw	v1,0(v0)
9d00c720:	8c420004 	lw	v0,4(v0)
9d00c724:	0223202b 	sltu	a0,s1,v1
9d00c728:	10800024 	beqz	a0,9d00c7bc <_sbrk_init+0x134>
9d00c72c:	00621021 	addu	v0,v1,v0
9d00c730:	3c04a001 	lui	a0,0xa001
9d00c734:	24849b28 	addiu	a0,a0,-25816
9d00c738:	7c84e000 	ext	a0,a0,0x0,0x1d
9d00c73c:	0064202b 	sltu	a0,v1,a0
9d00c740:	1480ffdb 	bnez	a0,9d00c6b0 <_sbrk_init+0x28>
9d00c744:	00608821 	move	s1,v1
9d00c748:	0251182b 	sltu	v1,s2,s1
9d00c74c:	14600005 	bnez	v1,9d00c764 <_sbrk_init+0xdc>
9d00c750:	0222182b 	sltu	v1,s1,v0
9d00c754:	0242182b 	sltu	v1,s2,v0
9d00c758:	54600005 	bnezl	v1,9d00c770 <_sbrk_init+0xe8>
9d00c75c:	3c02a001 	lui	v0,0xa001
9d00c760:	0222182b 	sltu	v1,s1,v0
9d00c764:	1060ffd2 	beqz	v1,9d00c6b0 <_sbrk_init+0x28>
9d00c768:	00409021 	move	s2,v0
9d00c76c:	3c02a001 	lui	v0,0xa001
9d00c770:	24429b28 	addiu	v0,v0,-25816
9d00c774:	00021742 	srl	v0,v0,0x1d
9d00c778:	24030005 	li	v1,5
9d00c77c:	14430019 	bne	v0,v1,9d00c7e4 <_sbrk_init+0x15c>
9d00c780:	24030004 	li	v1,4
9d00c784:	3c02a000 	lui	v0,0xa000
9d00c788:	02228825 	or	s1,s1,v0
9d00c78c:	02429025 	or	s2,s2,v0
9d00c790:	ae710a34 	sw	s1,2612(s3)
9d00c794:	ae920a38 	sw	s2,2616(s4)
9d00c798:	ae119a40 	sw	s1,-26048(s0)
9d00c79c:	8fbf0024 	lw	ra,36(sp)
9d00c7a0:	8fb40020 	lw	s4,32(sp)
9d00c7a4:	8fb3001c 	lw	s3,28(sp)
9d00c7a8:	8fb20018 	lw	s2,24(sp)
9d00c7ac:	8fb10014 	lw	s1,20(sp)
9d00c7b0:	8fb00010 	lw	s0,16(sp)
9d00c7b4:	03e00008 	jr	ra
9d00c7b8:	27bd0028 	addiu	sp,sp,40
9d00c7bc:	0222202b 	sltu	a0,s1,v0
9d00c7c0:	5480ffe2 	bnezl	a0,9d00c74c <_sbrk_init+0xc4>
9d00c7c4:	0251182b 	sltu	v1,s2,s1
9d00c7c8:	0b4031cd 	j	9d00c734 <_sbrk_init+0xac>
9d00c7cc:	3c04a001 	lui	a0,0xa001
9d00c7d0:	03a01021 	move	v0,sp
9d00c7d4:	0b4031bc 	j	9d00c6f0 <_sbrk_init+0x68>
9d00c7d8:	2442f800 	addiu	v0,v0,-2048
9d00c7dc:	0b4031b8 	j	9d00c6e0 <_sbrk_init+0x58>
9d00c7e0:	24639b28 	addiu	v1,v1,-25816
9d00c7e4:	14430007 	bne	v0,v1,9d00c804 <_sbrk_init+0x17c>
9d00c7e8:	3c028000 	lui	v0,0x8000
9d00c7ec:	02228825 	or	s1,s1,v0
9d00c7f0:	02421025 	or	v0,s2,v0
9d00c7f4:	ae710a34 	sw	s1,2612(s3)
9d00c7f8:	ae820a38 	sw	v0,2616(s4)
9d00c7fc:	0b4031e7 	j	9d00c79c <_sbrk_init+0x114>
9d00c800:	ae119a40 	sw	s1,-26048(s0)
9d00c804:	02408821 	move	s1,s2
9d00c808:	ae720a34 	sw	s2,2612(s3)
9d00c80c:	0b4031e7 	j	9d00c79c <_sbrk_init+0x114>
9d00c810:	ae119a40 	sw	s1,-26048(s0)

9d00c814 <_sbrk>:
9d00c814:	27bdffe0 	addiu	sp,sp,-32
9d00c818:	afb00018 	sw	s0,24(sp)
9d00c81c:	3c10a001 	lui	s0,0xa001
9d00c820:	8e029a40 	lw	v0,-26048(s0)
9d00c824:	1040000e 	beqz	v0,9d00c860 <_sbrk+0x4c>
9d00c828:	afbf001c 	sw	ra,28(sp)
9d00c82c:	1880001a 	blez	a0,9d00c898 <_sbrk+0x84>
9d00c830:	00441821 	addu	v1,v0,a0
9d00c834:	0062202b 	sltu	a0,v1,v0
9d00c838:	1480000e 	bnez	a0,9d00c874 <_sbrk+0x60>
9d00c83c:	3c04a000 	lui	a0,0xa000
9d00c840:	8c840a38 	lw	a0,2616(a0)
9d00c844:	0083202b 	sltu	a0,a0,v1
9d00c848:	1480000a 	bnez	a0,9d00c874 <_sbrk+0x60>
9d00c84c:	8fbf001c 	lw	ra,28(sp)
9d00c850:	ae039a40 	sw	v1,-26048(s0)
9d00c854:	8fb00018 	lw	s0,24(sp)
9d00c858:	03e00008 	jr	ra
9d00c85c:	27bd0020 	addiu	sp,sp,32
9d00c860:	0f4031a2 	jal	9d00c688 <_sbrk_init>
9d00c864:	afa40010 	sw	a0,16(sp)
9d00c868:	8e029a40 	lw	v0,-26048(s0)
9d00c86c:	1440ffef 	bnez	v0,9d00c82c <_sbrk+0x18>
9d00c870:	8fa40010 	lw	a0,16(sp)
9d00c874:	0f40368c 	jal	9d00da30 <__errno>
9d00c878:	00000000 	nop
9d00c87c:	8fbf001c 	lw	ra,28(sp)
9d00c880:	2403000c 	li	v1,12
9d00c884:	ac430000 	sw	v1,0(v0)
9d00c888:	8fb00018 	lw	s0,24(sp)
9d00c88c:	2402ffff 	li	v0,-1
9d00c890:	03e00008 	jr	ra
9d00c894:	27bd0020 	addiu	sp,sp,32
9d00c898:	0043202b 	sltu	a0,v0,v1
9d00c89c:	14800005 	bnez	a0,9d00c8b4 <_sbrk+0xa0>
9d00c8a0:	3c04a000 	lui	a0,0xa000
9d00c8a4:	8c840a34 	lw	a0,2612(a0)
9d00c8a8:	0064202b 	sltu	a0,v1,a0
9d00c8ac:	1080ffe8 	beqz	a0,9d00c850 <_sbrk+0x3c>
9d00c8b0:	8fbf001c 	lw	ra,28(sp)
9d00c8b4:	0f40368c 	jal	9d00da30 <__errno>
9d00c8b8:	00000000 	nop
9d00c8bc:	8fbf001c 	lw	ra,28(sp)
9d00c8c0:	24030016 	li	v1,22
9d00c8c4:	ac430000 	sw	v1,0(v0)
9d00c8c8:	8fb00018 	lw	s0,24(sp)
9d00c8cc:	2402ffff 	li	v0,-1
9d00c8d0:	03e00008 	jr	ra
9d00c8d4:	27bd0020 	addiu	sp,sp,32

9d00c8d8 <sbrk>:
9d00c8d8:	27bdffe0 	addiu	sp,sp,-32
9d00c8dc:	afb10018 	sw	s1,24(sp)
9d00c8e0:	afb00014 	sw	s0,20(sp)
9d00c8e4:	afbf001c 	sw	ra,28(sp)
9d00c8e8:	0f403205 	jal	9d00c814 <_sbrk>
9d00c8ec:	00808821 	move	s1,a0
9d00c8f0:	1a200007 	blez	s1,9d00c910 <sbrk+0x38>
9d00c8f4:	00408021 	move	s0,v0
9d00c8f8:	2402ffff 	li	v0,-1
9d00c8fc:	12020004 	beq	s0,v0,9d00c910 <sbrk+0x38>
9d00c900:	02002021 	move	a0,s0
9d00c904:	00002821 	move	a1,zero
9d00c908:	0f402fd9 	jal	9d00bf64 <memset>
9d00c90c:	02203021 	move	a2,s1
9d00c910:	8fbf001c 	lw	ra,28(sp)
9d00c914:	02001021 	move	v0,s0
9d00c918:	8fb10018 	lw	s1,24(sp)
9d00c91c:	8fb00014 	lw	s0,20(sp)
9d00c920:	03e00008 	jr	ra
9d00c924:	27bd0020 	addiu	sp,sp,32

9d00c928 <ReadCoreTimer>:
9d00c928:	03e00008 	jr	ra
9d00c92c:	40024800 	mfc0	v0,c0_count

9d00c930 <_EthAckPacket>:
9d00c930:	8ca20000 	lw	v0,0(a1)
9d00c934:	27bdffb0 	addiu	sp,sp,-80
9d00c938:	afbe0048 	sw	s8,72(sp)
9d00c93c:	afb30034 	sw	s3,52(sp)
9d00c940:	afb20030 	sw	s2,48(sp)
9d00c944:	00809821 	move	s3,a0
9d00c948:	afbf004c 	sw	ra,76(sp)
9d00c94c:	afb70044 	sw	s7,68(sp)
9d00c950:	afb60040 	sw	s6,64(sp)
9d00c954:	afb5003c 	sw	s5,60(sp)
9d00c958:	afb40038 	sw	s4,56(sp)
9d00c95c:	afb1002c 	sw	s1,44(sp)
9d00c960:	afb00028 	sw	s0,40(sp)
9d00c964:	00a0f021 	move	s8,a1
9d00c968:	00c01821 	move	v1,a2
9d00c96c:	8fb20060 	lw	s2,96(sp)
9d00c970:	10400019 	beqz	v0,9d00c9d8 <_EthAckPacket+0xa8>
9d00c974:	24040001 	li	a0,1
9d00c978:	00002821 	move	a1,zero
9d00c97c:	0000b821 	move	s7,zero
9d00c980:	00008021 	move	s0,zero
9d00c984:	3c158000 	lui	s5,0x8000
9d00c988:	3c16a000 	lui	s6,0xa000
9d00c98c:	3c114000 	lui	s1,0x4000
9d00c990:	7e74e000 	ext	s4,s3,0x0,0x1d
9d00c994:	8c440004 	lw	a0,4(v0)
9d00c998:	04830007 	bgezl	a0,9d00c9b8 <_EthAckPacket+0x88>
9d00c99c:	00408021 	move	s0,v0
9d00c9a0:	1260001a 	beqz	s3,9d00ca0c <_EthAckPacket+0xdc>
9d00c9a4:	00000000 	nop
9d00c9a8:	8c440008 	lw	a0,8(v0)
9d00c9ac:	10940017 	beq	a0,s4,9d00ca0c <_EthAckPacket+0xdc>
9d00c9b0:	00000000 	nop
9d00c9b4:	00408021 	move	s0,v0
9d00c9b8:	8c420000 	lw	v0,0(v0)
9d00c9bc:	1440fff5 	bnez	v0,9d00c994 <_EthAckPacket+0x64>
9d00c9c0:	00000000 	nop
9d00c9c4:	16e00004 	bnez	s7,9d00c9d8 <_EthAckPacket+0xa8>
9d00c9c8:	00002021 	move	a0,zero
9d00c9cc:	24040002 	li	a0,2
9d00c9d0:	24020001 	li	v0,1
9d00c9d4:	0045200a 	movz	a0,v0,a1
9d00c9d8:	8fbf004c 	lw	ra,76(sp)
9d00c9dc:	00801021 	move	v0,a0
9d00c9e0:	8fbe0048 	lw	s8,72(sp)
9d00c9e4:	8fb70044 	lw	s7,68(sp)
9d00c9e8:	8fb60040 	lw	s6,64(sp)
9d00c9ec:	8fb5003c 	lw	s5,60(sp)
9d00c9f0:	8fb40038 	lw	s4,56(sp)
9d00c9f4:	8fb30034 	lw	s3,52(sp)
9d00c9f8:	8fb20030 	lw	s2,48(sp)
9d00c9fc:	8fb1002c 	lw	s1,44(sp)
9d00ca00:	8fb00028 	lw	s0,40(sp)
9d00ca04:	03e00008 	jr	ra
9d00ca08:	27bd0050 	addiu	sp,sp,80
9d00ca0c:	8c440004 	lw	a0,4(v0)
9d00ca10:	30840080 	andi	a0,a0,0x80
9d00ca14:	1480ffeb 	bnez	a0,9d00c9c4 <_EthAckPacket+0x94>
9d00ca18:	24050001 	li	a1,1
9d00ca1c:	00002821 	move	a1,zero
9d00ca20:	8c480000 	lw	t0,0(v0)
9d00ca24:	8c440004 	lw	a0,4(v0)
9d00ca28:	30840080 	andi	a0,a0,0x80
9d00ca2c:	1480fffd 	bnez	a0,9d00ca24 <_EthAckPacket+0xf4>
9d00ca30:	00000000 	nop
9d00ca34:	8c640004 	lw	a0,4(v1)
9d00ca38:	10800023 	beqz	a0,9d00cac8 <_EthAckPacket+0x198>
9d00ca3c:	ac400000 	sw	zero,0(v0)
9d00ca40:	24460004 	addiu	a2,v0,4
9d00ca44:	7cc6e000 	ext	a2,a2,0x0,0x1d
9d00ca48:	ac820000 	sw	v0,0(a0)
9d00ca4c:	ac860014 	sw	a2,20(a0)
9d00ca50:	ac620004 	sw	v0,4(v1)
9d00ca54:	10e00014 	beqz	a3,9d00caa8 <_EthAckPacket+0x178>
9d00ca58:	00000000 	nop
9d00ca5c:	8c440004 	lw	a0,4(v0)
9d00ca60:	30840400 	andi	a0,a0,0x400
9d00ca64:	10800016 	beqz	a0,9d00cac0 <_EthAckPacket+0x190>
9d00ca68:	8c440008 	lw	a0,8(v0)
9d00ca6c:	00952025 	or	a0,a0,s5
9d00ca70:	24a90001 	addiu	t1,a1,1
9d00ca74:	afa20010 	sw	v0,16(sp)
9d00ca78:	afa3001c 	sw	v1,28(sp)
9d00ca7c:	afa70020 	sw	a3,32(sp)
9d00ca80:	afa80014 	sw	t0,20(sp)
9d00ca84:	afa90018 	sw	t1,24(sp)
9d00ca88:	00e0f809 	jalr	a3
9d00ca8c:	02403021 	move	a2,s2
9d00ca90:	8fa90018 	lw	t1,24(sp)
9d00ca94:	8fa80014 	lw	t0,20(sp)
9d00ca98:	8fa70020 	lw	a3,32(sp)
9d00ca9c:	8fa3001c 	lw	v1,28(sp)
9d00caa0:	8fa20010 	lw	v0,16(sp)
9d00caa4:	01202821 	move	a1,t1
9d00caa8:	8c420004 	lw	v0,4(v0)
9d00caac:	00511024 	and	v0,v0,s1
9d00cab0:	14400008 	bnez	v0,9d00cad4 <_EthAckPacket+0x1a4>
9d00cab4:	01001021 	move	v0,t0
9d00cab8:	0b403289 	j	9d00ca24 <_EthAckPacket+0xf4>
9d00cabc:	8c480000 	lw	t0,0(v0)
9d00cac0:	0b40329c 	j	9d00ca70 <_EthAckPacket+0x140>
9d00cac4:	00962025 	or	a0,a0,s6
9d00cac8:	ac620004 	sw	v0,4(v1)
9d00cacc:	0b403295 	j	9d00ca54 <_EthAckPacket+0x124>
9d00cad0:	ac620000 	sw	v0,0(v1)
9d00cad4:	12000009 	beqz	s0,9d00cafc <_EthAckPacket+0x1cc>
9d00cad8:	00000000 	nop
9d00cadc:	16600009 	bnez	s3,9d00cb04 <_EthAckPacket+0x1d4>
9d00cae0:	ae080000 	sw	t0,0(s0)
9d00cae4:	01001021 	move	v0,t0
9d00cae8:	26f70001 	addiu	s7,s7,1
9d00caec:	1440ffa9 	bnez	v0,9d00c994 <_EthAckPacket+0x64>
9d00caf0:	24050001 	li	a1,1
9d00caf4:	0b403271 	j	9d00c9c4 <_EthAckPacket+0x94>
9d00caf8:	00000000 	nop
9d00cafc:	1260fff9 	beqz	s3,9d00cae4 <_EthAckPacket+0x1b4>
9d00cb00:	afc80000 	sw	t0,0(s8)
9d00cb04:	0b403276 	j	9d00c9d8 <_EthAckPacket+0xa8>
9d00cb08:	00002021 	move	a0,zero

9d00cb0c <_EthRxAckBuffer>:
9d00cb0c:	27bdffc8 	addiu	sp,sp,-56
9d00cb10:	afb00030 	sw	s0,48(sp)
9d00cb14:	3c10a000 	lui	s0,0xa000
9d00cb18:	00a03821 	move	a3,a1
9d00cb1c:	afa60010 	sw	a2,16(sp)
9d00cb20:	26050a54 	addiu	a1,s0,2644
9d00cb24:	27a60018 	addiu	a2,sp,24
9d00cb28:	afbf0034 	sw	ra,52(sp)
9d00cb2c:	afa00018 	sw	zero,24(sp)
9d00cb30:	afa0001c 	sw	zero,28(sp)
9d00cb34:	afa00020 	sw	zero,32(sp)
9d00cb38:	0f40324c 	jal	9d00c930 <_EthAckPacket>
9d00cb3c:	afa00024 	sw	zero,36(sp)
9d00cb40:	8fa30018 	lw	v1,24(sp)
9d00cb44:	8fa8001c 	lw	t0,28(sp)
9d00cb48:	3c0ca000 	lui	t4,0xa000
9d00cb4c:	258f0a4c 	addiu	t7,t4,2636
9d00cb50:	8fa60024 	lw	a2,36(sp)
9d00cb54:	8fab0020 	lw	t3,32(sp)
9d00cb58:	8de50004 	lw	a1,4(t7)
9d00cb5c:	8d980a4c 	lw	t8,2636(t4)
9d00cb60:	3c0ebf89 	lui	t6,0xbf89
9d00cb64:	240a0001 	li	t2,1
9d00cb68:	10680021 	beq	v1,t0,9d00cbf0 <_EthRxAckBuffer+0xe4>
9d00cb6c:	240d0001 	li	t5,1
9d00cb70:	10600022 	beqz	v1,9d00cbfc <_EthRxAckBuffer+0xf0>
9d00cb74:	8c640000 	lw	a0,0(v1)
9d00cb78:	8c670004 	lw	a3,4(v1)
9d00cb7c:	30e70200 	andi	a3,a3,0x200
9d00cb80:	10e0002f 	beqz	a3,9d00cc40 <_EthRxAckBuffer+0x134>
9d00cb84:	00000000 	nop
9d00cb88:	8c670004 	lw	a3,4(v1)
9d00cb8c:	ac600000 	sw	zero,0(v1)
9d00cb90:	7c075ac4 	ins	a3,zero,0xb,0x1
9d00cb94:	ac670004 	sw	a3,4(v1)
9d00cb98:	8c690004 	lw	t1,4(v1)
9d00cb9c:	8c670004 	lw	a3,4(v1)
9d00cba0:	7d2902c0 	ext	t1,t1,0xb,0x1
9d00cba4:	7d27f784 	ins	a3,t1,0x1e,0x1
9d00cba8:	ac670004 	sw	a3,4(v1)
9d00cbac:	8c690004 	lw	t1,4(v1)
9d00cbb0:	8c670004 	lw	a3,4(v1)
9d00cbb4:	7d290780 	ext	t1,t1,0x1e,0x1
9d00cbb8:	7d27ffc4 	ins	a3,t1,0x1f,0x1
9d00cbbc:	ac670004 	sw	a3,4(v1)
9d00cbc0:	8c670004 	lw	a3,4(v1)
9d00cbc4:	7d4739c4 	ins	a3,t2,0x7,0x1
9d00cbc8:	ac670004 	sw	a3,4(v1)
9d00cbcc:	10c0002a 	beqz	a2,9d00cc78 <_EthRxAckBuffer+0x16c>
9d00cbd0:	24670004 	addiu	a3,v1,4
9d00cbd4:	7ce7e000 	ext	a3,a3,0x0,0x1d
9d00cbd8:	acc30000 	sw	v1,0(a2)
9d00cbdc:	acc70014 	sw	a3,20(a2)
9d00cbe0:	00603021 	move	a2,v1
9d00cbe4:	00801821 	move	v1,a0
9d00cbe8:	1468ffe1 	bne	v1,t0,9d00cb70 <_EthRxAckBuffer+0x64>
9d00cbec:	00000000 	nop
9d00cbf0:	00004021 	move	t0,zero
9d00cbf4:	1460ffe0 	bnez	v1,9d00cb78 <_EthRxAckBuffer+0x6c>
9d00cbf8:	00002021 	move	a0,zero
9d00cbfc:	afa60024 	sw	a2,36(sp)
9d00cc00:	afab0020 	sw	t3,32(sp)
9d00cc04:	ade50004 	sw	a1,4(t7)
9d00cc08:	ad980a4c 	sw	t8,2636(t4)
9d00cc0c:	afa40018 	sw	a0,24(sp)
9d00cc10:	11600007 	beqz	t3,9d00cc30 <_EthRxAckBuffer+0x124>
9d00cc14:	afa8001c 	sw	t0,28(sp)
9d00cc18:	26040a54 	addiu	a0,s0,2644
9d00cc1c:	27a50020 	addiu	a1,sp,32
9d00cc20:	24060001 	li	a2,1
9d00cc24:	0f40358b 	jal	9d00d62c <_EthAppendBusyList>
9d00cc28:	afa20028 	sw	v0,40(sp)
9d00cc2c:	8fa20028 	lw	v0,40(sp)
9d00cc30:	8fbf0034 	lw	ra,52(sp)
9d00cc34:	8fb00030 	lw	s0,48(sp)
9d00cc38:	03e00008 	jr	ra
9d00cc3c:	27bd0038 	addiu	sp,sp,56
9d00cc40:	10a00011 	beqz	a1,9d00cc88 <_EthRxAckBuffer+0x17c>
9d00cc44:	ac600000 	sw	zero,0(v1)
9d00cc48:	24670004 	addiu	a3,v1,4
9d00cc4c:	7ce7e000 	ext	a3,a3,0x0,0x1d
9d00cc50:	aca30000 	sw	v1,0(a1)
9d00cc54:	aca70014 	sw	a3,20(a1)
9d00cc58:	8c670004 	lw	a3,4(v1)
9d00cc5c:	00602821 	move	a1,v1
9d00cc60:	30e31000 	andi	v1,a3,0x1000
9d00cc64:	5460ffe0 	bnezl	v1,9d00cbe8 <_EthRxAckBuffer+0xdc>
9d00cc68:	00801821 	move	v1,a0
9d00cc6c:	adcd9008 	sw	t5,-28664(t6)
9d00cc70:	0b4032fa 	j	9d00cbe8 <_EthRxAckBuffer+0xdc>
9d00cc74:	00801821 	move	v1,a0
9d00cc78:	00605821 	move	t3,v1
9d00cc7c:	00603021 	move	a2,v1
9d00cc80:	0b4032fa 	j	9d00cbe8 <_EthRxAckBuffer+0xdc>
9d00cc84:	00801821 	move	v1,a0
9d00cc88:	0b403316 	j	9d00cc58 <_EthRxAckBuffer+0x14c>
9d00cc8c:	0060c021 	move	t8,v1

9d00cc90 <EthRxAcknowledgeBuffer>:
9d00cc90:	27bdffe8 	addiu	sp,sp,-24
9d00cc94:	afbf0014 	sw	ra,20(sp)
9d00cc98:	0f4032c3 	jal	9d00cb0c <_EthRxAckBuffer>
9d00cc9c:	00000000 	nop
9d00cca0:	8fbf0014 	lw	ra,20(sp)
9d00cca4:	03e00008 	jr	ra
9d00cca8:	27bd0018 	addiu	sp,sp,24

9d00ccac <EthTxAcknowledgeBuffer>:
9d00ccac:	27bdffe0 	addiu	sp,sp,-32
9d00ccb0:	afa60010 	sw	a2,16(sp)
9d00ccb4:	00a03821 	move	a3,a1
9d00ccb8:	3c06a000 	lui	a2,0xa000
9d00ccbc:	3c05a000 	lui	a1,0xa000
9d00ccc0:	24a50a44 	addiu	a1,a1,2628
9d00ccc4:	afbf001c 	sw	ra,28(sp)
9d00ccc8:	0f40324c 	jal	9d00c930 <_EthAckPacket>
9d00cccc:	24c60a3c 	addiu	a2,a2,2620
9d00ccd0:	8fbf001c 	lw	ra,28(sp)
9d00ccd4:	03e00008 	jr	ra
9d00ccd8:	27bd0020 	addiu	sp,sp,32

9d00ccdc <EthDescriptorsPoolAdd>:
9d00ccdc:	27bdffd0 	addiu	sp,sp,-48
9d00cce0:	afb30020 	sw	s3,32(sp)
9d00cce4:	afb2001c 	sw	s2,28(sp)
9d00cce8:	afb10018 	sw	s1,24(sp)
9d00ccec:	afb00014 	sw	s0,20(sp)
9d00ccf0:	afbf002c 	sw	ra,44(sp)
9d00ccf4:	afb50028 	sw	s5,40(sp)
9d00ccf8:	afb40024 	sw	s4,36(sp)
9d00ccfc:	00c08021 	move	s0,a2
9d00cd00:	00809021 	move	s2,a0
9d00cd04:	00e08821 	move	s1,a3
9d00cd08:	10c00006 	beqz	a2,9d00cd24 <EthDescriptorsPoolAdd+0x48>
9d00cd0c:	00009821 	move	s3,zero
9d00cd10:	24020002 	li	v0,2
9d00cd14:	10a2002a 	beq	a1,v0,9d00cdc0 <EthDescriptorsPoolAdd+0xe4>
9d00cd18:	24020001 	li	v0,1
9d00cd1c:	10a2000b 	beq	a1,v0,9d00cd4c <EthDescriptorsPoolAdd+0x70>
9d00cd20:	3c15a000 	lui	s5,0xa000
9d00cd24:	8fbf002c 	lw	ra,44(sp)
9d00cd28:	02601021 	move	v0,s3
9d00cd2c:	8fb50028 	lw	s5,40(sp)
9d00cd30:	8fb40024 	lw	s4,36(sp)
9d00cd34:	8fb30020 	lw	s3,32(sp)
9d00cd38:	8fb2001c 	lw	s2,28(sp)
9d00cd3c:	8fb10018 	lw	s1,24(sp)
9d00cd40:	8fb00014 	lw	s0,20(sp)
9d00cd44:	03e00008 	jr	ra
9d00cd48:	27bd0030 	addiu	sp,sp,48
9d00cd4c:	3c14a000 	lui	s4,0xa000
9d00cd50:	26b50a54 	addiu	s5,s5,2644
9d00cd54:	26940a4c 	addiu	s4,s4,2636
9d00cd58:	8ea20000 	lw	v0,0(s5)
9d00cd5c:	1040001d 	beqz	v0,9d00cdd4 <EthDescriptorsPoolAdd+0xf8>
9d00cd60:	24040001 	li	a0,1
9d00cd64:	16400009 	bnez	s2,9d00cd8c <EthDescriptorsPoolAdd+0xb0>
9d00cd68:	00009821 	move	s3,zero
9d00cd6c:	0b40334a 	j	9d00cd28 <EthDescriptorsPoolAdd+0x4c>
9d00cd70:	8fbf002c 	lw	ra,44(sp)
9d00cd74:	ac620000 	sw	v0,0(v1)
9d00cd78:	ac640014 	sw	a0,20(v1)
9d00cd7c:	ae820004 	sw	v0,4(s4)
9d00cd80:	26730001 	addiu	s3,s3,1
9d00cd84:	1253ffe8 	beq	s2,s3,9d00cd28 <EthDescriptorsPoolAdd+0x4c>
9d00cd88:	8fbf002c 	lw	ra,44(sp)
9d00cd8c:	24040001 	li	a0,1
9d00cd90:	24050018 	li	a1,24
9d00cd94:	0200f809 	jalr	s0
9d00cd98:	02203021 	move	a2,s1
9d00cd9c:	24430004 	addiu	v1,v0,4
9d00cda0:	1040ffe0 	beqz	v0,9d00cd24 <EthDescriptorsPoolAdd+0x48>
9d00cda4:	7c64e000 	ext	a0,v1,0x0,0x1d
9d00cda8:	8e830004 	lw	v1,4(s4)
9d00cdac:	1460fff1 	bnez	v1,9d00cd74 <EthDescriptorsPoolAdd+0x98>
9d00cdb0:	ac400000 	sw	zero,0(v0)
9d00cdb4:	ae820004 	sw	v0,4(s4)
9d00cdb8:	0b403360 	j	9d00cd80 <EthDescriptorsPoolAdd+0xa4>
9d00cdbc:	ae820000 	sw	v0,0(s4)
9d00cdc0:	3c15a000 	lui	s5,0xa000
9d00cdc4:	3c14a000 	lui	s4,0xa000
9d00cdc8:	26b50a44 	addiu	s5,s5,2628
9d00cdcc:	0b403356 	j	9d00cd58 <EthDescriptorsPoolAdd+0x7c>
9d00cdd0:	26940a3c 	addiu	s4,s4,2620
9d00cdd4:	24050018 	li	a1,24
9d00cdd8:	0200f809 	jalr	s0
9d00cddc:	02203021 	move	a2,s1
9d00cde0:	1040ffd0 	beqz	v0,9d00cd24 <EthDescriptorsPoolAdd+0x48>
9d00cde4:	00009821 	move	s3,zero
9d00cde8:	8ea30000 	lw	v1,0(s5)
9d00cdec:	8ea40004 	lw	a0,4(s5)
9d00cdf0:	24650004 	addiu	a1,v1,4
9d00cdf4:	7ca5e000 	ext	a1,a1,0x0,0x1d
9d00cdf8:	ac430000 	sw	v1,0(v0)
9d00cdfc:	ac450014 	sw	a1,20(v0)
9d00ce00:	1480ffd8 	bnez	a0,9d00cd64 <EthDescriptorsPoolAdd+0x88>
9d00ce04:	aea20000 	sw	v0,0(s5)
9d00ce08:	0b403359 	j	9d00cd64 <EthDescriptorsPoolAdd+0x88>
9d00ce0c:	aea20004 	sw	v0,4(s5)

9d00ce10 <EthInit>:
9d00ce10:	27bdffe8 	addiu	sp,sp,-24
9d00ce14:	2404006c 	li	a0,108
9d00ce18:	afbf0014 	sw	ra,20(sp)
9d00ce1c:	0f403656 	jal	9d00d958 <INTEnable>
9d00ce20:	00002821 	move	a1,zero
9d00ce24:	3c02bf89 	lui	v0,0xbf89
9d00ce28:	34038300 	li	v1,0x8300
9d00ce2c:	ac439004 	sw	v1,-28668(v0)
9d00ce30:	3c02bf89 	lui	v0,0xbf89
9d00ce34:	8c4390e0 	lw	v1,-28448(v0)
9d00ce38:	30630080 	andi	v1,v1,0x80
9d00ce3c:	1460fffd 	bnez	v1,9d00ce34 <EthInit+0x24>
9d00ce40:	34038000 	li	v1,0x8000
9d00ce44:	3c04bf89 	lui	a0,0xbf89
9d00ce48:	ac839008 	sw	v1,-28664(a0)
9d00ce4c:	3c03bf89 	lui	v1,0xbf89
9d00ce50:	906390e2 	lbu	v1,-28446(v1)
9d00ce54:	306300ff 	andi	v1,v1,0xff
9d00ce58:	10600006 	beqz	v1,9d00ce74 <EthInit+0x64>
9d00ce5c:	24050001 	li	a1,1
9d00ce60:	ac859008 	sw	a1,-28664(a0)
9d00ce64:	904390e2 	lbu	v1,-28446(v0)
9d00ce68:	306300ff 	andi	v1,v1,0xff
9d00ce6c:	1460fffc 	bnez	v1,9d00ce60 <EthInit+0x50>
9d00ce70:	00000000 	nop
9d00ce74:	0f40364b 	jal	9d00d92c <INTClearFlag>
9d00ce78:	2404006c 	li	a0,108
9d00ce7c:	2403ffff 	li	v1,-1
9d00ce80:	3c02bf89 	lui	v0,0xbf89
9d00ce84:	3c05bf89 	lui	a1,0xbf89
9d00ce88:	ac4390d4 	sw	v1,-28460(v0)
9d00ce8c:	8fbf0014 	lw	ra,20(sp)
9d00ce90:	aca39024 	sw	v1,-28636(a1)
9d00ce94:	3c05bf89 	lui	a1,0xbf89
9d00ce98:	aca39034 	sw	v1,-28620(a1)
9d00ce9c:	3c04bf89 	lui	a0,0xbf89
9d00cea0:	34038000 	li	v1,0x8000
9d00cea4:	ac839200 	sw	v1,-28160(a0)
9d00cea8:	ac809200 	sw	zero,-28160(a0)
9d00ceac:	3c03bf89 	lui	v1,0xbf89
9d00ceb0:	24040600 	li	a0,1536
9d00ceb4:	00001021 	move	v0,zero
9d00ceb8:	ac649250 	sw	a0,-28080(v1)
9d00cebc:	03e00008 	jr	ra
9d00cec0:	27bd0018 	addiu	sp,sp,24

9d00cec4 <EthMACOpen>:
9d00cec4:	30860040 	andi	a2,a0,0x40
9d00cec8:	24020011 	li	v0,17
9d00cecc:	24070001 	li	a3,1
9d00ced0:	30830002 	andi	v1,a0,0x2
9d00ced4:	10600007 	beqz	v1,9d00cef4 <EthMACOpen+0x30>
9d00ced8:	00e6100a 	movz	v0,a3,a2
9d00cedc:	30a60004 	andi	a2,a1,0x4
9d00cee0:	34430008 	ori	v1,v0,0x8
9d00cee4:	0066100b 	movn	v0,v1,a2
9d00cee8:	30a50008 	andi	a1,a1,0x8
9d00ceec:	34430004 	ori	v1,v0,0x4
9d00cef0:	0065100b 	movn	v0,v1,a1
9d00cef4:	30860004 	andi	a2,a0,0x4
9d00cef8:	30870020 	andi	a3,a0,0x20
9d00cefc:	240340b2 	li	v1,16562
9d00cf00:	240540b6 	li	a1,16566
9d00cf04:	0067280a 	movz	a1,v1,a3
9d00cf08:	2cc70001 	sltiu	a3,a2,1
9d00cf0c:	00a72825 	or	a1,a1,a3
9d00cf10:	24030012 	li	v1,18
9d00cf14:	24070015 	li	a3,21
9d00cf18:	00e6180a 	movz	v1,a3,a2
9d00cf1c:	3c07bf89 	lui	a3,0xbf89
9d00cf20:	ace29200 	sw	v0,-28160(a3)
9d00cf24:	3c02bf89 	lui	v0,0xbf89
9d00cf28:	ac459210 	sw	a1,-28144(v0)
9d00cf2c:	3c02bf89 	lui	v0,0xbf89
9d00cf30:	ac439220 	sw	v1,-28128(v0)
9d00cf34:	24030c12 	li	v1,3090
9d00cf38:	3c02bf89 	lui	v0,0xbf89
9d00cf3c:	ac439230 	sw	v1,-28112(v0)
9d00cf40:	30860400 	andi	a2,a0,0x400
9d00cf44:	2403370f 	li	v1,14095
9d00cf48:	3c02bf89 	lui	v0,0xbf89
9d00cf4c:	ac439240 	sw	v1,-28096(v0)
9d00cf50:	10c00007 	beqz	a2,9d00cf70 <EthMACOpen+0xac>
9d00cf54:	30840008 	andi	a0,a0,0x8
9d00cf58:	24020100 	li	v0,256
9d00cf5c:	3c03bf89 	lui	v1,0xbf89
9d00cf60:	0004100a 	movz	v0,zero,a0
9d00cf64:	24040800 	li	a0,2048
9d00cf68:	ac649260 	sw	a0,-28064(v1)
9d00cf6c:	ac629260 	sw	v0,-28064(v1)
9d00cf70:	03e00008 	jr	ra
9d00cf74:	00000000 	nop

9d00cf78 <EthMACSetAddress>:
9d00cf78:	27bdffe0 	addiu	sp,sp,-32
9d00cf7c:	00802821 	move	a1,a0
9d00cf80:	24060006 	li	a2,6
9d00cf84:	afbf001c 	sw	ra,28(sp)
9d00cf88:	0f402fce 	jal	9d00bf38 <memcpy>
9d00cf8c:	27a40010 	addiu	a0,sp,16
9d00cf90:	97a50010 	lhu	a1,16(sp)
9d00cf94:	97a40012 	lhu	a0,18(sp)
9d00cf98:	97a30014 	lhu	v1,20(sp)
9d00cf9c:	3c02bf89 	lui	v0,0xbf89
9d00cfa0:	8fbf001c 	lw	ra,28(sp)
9d00cfa4:	ac459320 	sw	a1,-27872(v0)
9d00cfa8:	3c02bf89 	lui	v0,0xbf89
9d00cfac:	ac449310 	sw	a0,-27888(v0)
9d00cfb0:	3c02bf89 	lui	v0,0xbf89
9d00cfb4:	ac439300 	sw	v1,-27904(v0)
9d00cfb8:	03e00008 	jr	ra
9d00cfbc:	27bd0020 	addiu	sp,sp,32

9d00cfc0 <EthRxBuffersAppend>:
9d00cfc0:	27bdffe0 	addiu	sp,sp,-32
9d00cfc4:	afbf001c 	sw	ra,28(sp)
9d00cfc8:	afb00018 	sw	s0,24(sp)
9d00cfcc:	afa00010 	sw	zero,16(sp)
9d00cfd0:	14a00003 	bnez	a1,9d00cfe0 <EthRxBuffersAppend+0x20>
9d00cfd4:	afa00014 	sw	zero,20(sp)
9d00cfd8:	3c057fff 	lui	a1,0x7fff
9d00cfdc:	34a5ffff 	ori	a1,a1,0xffff
9d00cfe0:	8c830000 	lw	v1,0(a0)
9d00cfe4:	10600080 	beqz	v1,9d00d1e8 <EthRxBuffersAppend+0x228>
9d00cfe8:	3c0fa000 	lui	t7,0xa000
9d00cfec:	25f00a4c 	addiu	s0,t7,2636
9d00cff0:	8de20a4c 	lw	v0,2636(t7)
9d00cff4:	8e0b0004 	lw	t3,4(s0)
9d00cff8:	30cd0001 	andi	t5,a2,0x1
9d00cffc:	8fb80010 	lw	t8,16(sp)
9d00d000:	00003821 	move	a3,zero
9d00d004:	240e0180 	li	t6,384
9d00d008:	240a0001 	li	t2,1
9d00d00c:	30c60002 	andi	a2,a2,0x2
9d00d010:	104b0025 	beq	v0,t3,9d00d0a8 <EthRxBuffersAppend+0xe8>
9d00d014:	240c0004 	li	t4,4
9d00d018:	10400026 	beqz	v0,9d00d0b4 <EthRxBuffersAppend+0xf4>
9d00d01c:	8c480000 	lw	t0,0(v0)
9d00d020:	7c69e000 	ext	t1,v1,0x0,0x1d
9d00d024:	ac490008 	sw	t1,8(v0)
9d00d028:	ac4e0004 	sw	t6,4(v0)
9d00d02c:	11a00004 	beqz	t5,9d00d040 <EthRxBuffersAppend+0x80>
9d00d030:	00000000 	nop
9d00d034:	8c490004 	lw	t1,4(v0)
9d00d038:	7d494a44 	ins	t1,t2,0x9,0x1
9d00d03c:	ac490004 	sw	t1,4(v0)
9d00d040:	10c00005 	beqz	a2,9d00d058 <EthRxBuffersAppend+0x98>
9d00d044:	00034f42 	srl	t1,v1,0x1d
9d00d048:	8c490004 	lw	t1,4(v0)
9d00d04c:	7d496304 	ins	t1,t2,0xc,0x1
9d00d050:	ac490004 	sw	t1,4(v0)
9d00d054:	00034f42 	srl	t1,v1,0x1d
9d00d058:	112c003a 	beq	t1,t4,9d00d144 <EthRxBuffersAppend+0x184>
9d00d05c:	00000000 	nop
9d00d060:	04630066 	bgezl	v1,9d00d1fc <EthRxBuffersAppend+0x23c>
9d00d064:	ade80a4c 	sw	t0,2636(t7)
9d00d068:	10e0003c 	beqz	a3,9d00d15c <EthRxBuffersAppend+0x19c>
9d00d06c:	ac400000 	sw	zero,0(v0)
9d00d070:	24430004 	addiu	v1,v0,4
9d00d074:	7c63e000 	ext	v1,v1,0x0,0x1d
9d00d078:	24840004 	addiu	a0,a0,4
9d00d07c:	ace30014 	sw	v1,20(a3)
9d00d080:	8c830000 	lw	v1,0(a0)
9d00d084:	10600039 	beqz	v1,9d00d16c <EthRxBuffersAppend+0x1ac>
9d00d088:	ace20000 	sw	v0,0(a3)
9d00d08c:	24a5ffff 	addiu	a1,a1,-1
9d00d090:	50a00037 	beqzl	a1,9d00d170 <EthRxBuffersAppend+0x1b0>
9d00d094:	ade80a4c 	sw	t0,2636(t7)
9d00d098:	00403821 	move	a3,v0
9d00d09c:	01001021 	move	v0,t0
9d00d0a0:	144bffdd 	bne	v0,t3,9d00d018 <EthRxBuffersAppend+0x58>
9d00d0a4:	00000000 	nop
9d00d0a8:	00005821 	move	t3,zero
9d00d0ac:	1440ffdc 	bnez	v0,9d00d020 <EthRxBuffersAppend+0x60>
9d00d0b0:	00004021 	move	t0,zero
9d00d0b4:	ade80a4c 	sw	t0,2636(t7)
9d00d0b8:	ae0b0004 	sw	t3,4(s0)
9d00d0bc:	afa70014 	sw	a3,20(sp)
9d00d0c0:	afb80010 	sw	t8,16(sp)
9d00d0c4:	24020004 	li	v0,4
9d00d0c8:	10600051 	beqz	v1,9d00d210 <EthRxBuffersAppend+0x250>
9d00d0cc:	8fa30010 	lw	v1,16(sp)
9d00d0d0:	10a0002a 	beqz	a1,9d00d17c <EthRxBuffersAppend+0x1bc>
9d00d0d4:	0060c021 	move	t8,v1
9d00d0d8:	8fa70014 	lw	a3,20(sp)
9d00d0dc:	8de80a4c 	lw	t0,2636(t7)
9d00d0e0:	10e3000d 	beq	a3,v1,9d00d118 <EthRxBuffersAppend+0x158>
9d00d0e4:	8e040004 	lw	a0,4(s0)
9d00d0e8:	24650004 	addiu	a1,v1,4
9d00d0ec:	8c660000 	lw	a2,0(v1)
9d00d0f0:	1060000e 	beqz	v1,9d00d12c <EthRxBuffersAppend+0x16c>
9d00d0f4:	7ca5e000 	ext	a1,a1,0x0,0x1d
9d00d0f8:	10800037 	beqz	a0,9d00d1d8 <EthRxBuffersAppend+0x218>
9d00d0fc:	ac600000 	sw	zero,0(v1)
9d00d100:	ac830000 	sw	v1,0(a0)
9d00d104:	ac850014 	sw	a1,20(a0)
9d00d108:	00602021 	move	a0,v1
9d00d10c:	00c01821 	move	v1,a2
9d00d110:	54e3fff6 	bnel	a3,v1,9d00d0ec <EthRxBuffersAppend+0x12c>
9d00d114:	24650004 	addiu	a1,v1,4
9d00d118:	24650004 	addiu	a1,v1,4
9d00d11c:	00003021 	move	a2,zero
9d00d120:	00003821 	move	a3,zero
9d00d124:	1460fff4 	bnez	v1,9d00d0f8 <EthRxBuffersAppend+0x138>
9d00d128:	7ca5e000 	ext	a1,a1,0x0,0x1d
9d00d12c:	8fbf001c 	lw	ra,28(sp)
9d00d130:	ae040004 	sw	a0,4(s0)
9d00d134:	ade80a4c 	sw	t0,2636(t7)
9d00d138:	8fb00018 	lw	s0,24(sp)
9d00d13c:	03e00008 	jr	ra
9d00d140:	27bd0020 	addiu	sp,sp,32
9d00d144:	8c430004 	lw	v1,4(v0)
9d00d148:	ac400000 	sw	zero,0(v0)
9d00d14c:	7d435284 	ins	v1,t2,0xa,0x1
9d00d150:	ac430004 	sw	v1,4(v0)
9d00d154:	14e0ffc7 	bnez	a3,9d00d074 <EthRxBuffersAppend+0xb4>
9d00d158:	24430004 	addiu	v1,v0,4
9d00d15c:	24840004 	addiu	a0,a0,4
9d00d160:	8c830000 	lw	v1,0(a0)
9d00d164:	1460ffc9 	bnez	v1,9d00d08c <EthRxBuffersAppend+0xcc>
9d00d168:	0040c021 	move	t8,v0
9d00d16c:	ade80a4c 	sw	t0,2636(t7)
9d00d170:	ae0b0004 	sw	t3,4(s0)
9d00d174:	afa20014 	sw	v0,20(sp)
9d00d178:	afb80010 	sw	t8,16(sp)
9d00d17c:	1300001b 	beqz	t8,9d00d1ec <EthRxBuffersAppend+0x22c>
9d00d180:	8fbf001c 	lw	ra,28(sp)
9d00d184:	3c10a000 	lui	s0,0xa000
9d00d188:	26040a54 	addiu	a0,s0,2644
9d00d18c:	27a50010 	addiu	a1,sp,16
9d00d190:	0f40358b 	jal	9d00d62c <_EthAppendBusyList>
9d00d194:	24060001 	li	a2,1
9d00d198:	3c02bf89 	lui	v0,0xbf89
9d00d19c:	8c439030 	lw	v1,-28624(v0)
9d00d1a0:	14600006 	bnez	v1,9d00d1bc <EthRxBuffersAppend+0x1fc>
9d00d1a4:	8fbf001c 	lw	ra,28(sp)
9d00d1a8:	8e030a54 	lw	v1,2644(s0)
9d00d1ac:	24630004 	addiu	v1,v1,4
9d00d1b0:	7c63e000 	ext	v1,v1,0x0,0x1d
9d00d1b4:	ac439030 	sw	v1,-28624(v0)
9d00d1b8:	8fbf001c 	lw	ra,28(sp)
9d00d1bc:	3c02bf89 	lui	v0,0xbf89
9d00d1c0:	24030100 	li	v1,256
9d00d1c4:	ac439008 	sw	v1,-28664(v0)
9d00d1c8:	8fb00018 	lw	s0,24(sp)
9d00d1cc:	00001021 	move	v0,zero
9d00d1d0:	03e00008 	jr	ra
9d00d1d4:	27bd0020 	addiu	sp,sp,32
9d00d1d8:	00604021 	move	t0,v1
9d00d1dc:	00602021 	move	a0,v1
9d00d1e0:	0b403444 	j	9d00d110 <EthRxBuffersAppend+0x150>
9d00d1e4:	00c01821 	move	v1,a2
9d00d1e8:	8fbf001c 	lw	ra,28(sp)
9d00d1ec:	00001021 	move	v0,zero
9d00d1f0:	8fb00018 	lw	s0,24(sp)
9d00d1f4:	03e00008 	jr	ra
9d00d1f8:	27bd0020 	addiu	sp,sp,32
9d00d1fc:	ae0b0004 	sw	t3,4(s0)
9d00d200:	afa70014 	sw	a3,20(sp)
9d00d204:	afb80010 	sw	t8,16(sp)
9d00d208:	0b403432 	j	9d00d0c8 <EthRxBuffersAppend+0x108>
9d00d20c:	24020005 	li	v0,5
9d00d210:	8fb80010 	lw	t8,16(sp)
9d00d214:	1700ffdc 	bnez	t8,9d00d188 <EthRxBuffersAppend+0x1c8>
9d00d218:	3c10a000 	lui	s0,0xa000
9d00d21c:	0b40347b 	j	9d00d1ec <EthRxBuffersAppend+0x22c>
9d00d220:	8fbf001c 	lw	ra,28(sp)

9d00d224 <EthRxFiltersSet>:
9d00d224:	3c02bf89 	lui	v0,0xbf89
9d00d228:	ac4490a8 	sw	a0,-28504(v0)
9d00d22c:	03e00008 	jr	ra
9d00d230:	00000000 	nop

9d00d234 <EthRxFiltersClr>:
9d00d234:	3c02bf89 	lui	v0,0xbf89
9d00d238:	ac4490a4 	sw	a0,-28508(v0)
9d00d23c:	03e00008 	jr	ra
9d00d240:	00000000 	nop

9d00d244 <EthRxGetPacket>:
9d00d244:	10800005 	beqz	a0,9d00d25c <EthRxGetPacket+0x18>
9d00d248:	3c02a000 	lui	v0,0xa000
9d00d24c:	a8800007 	swl	zero,7(a0)
9d00d250:	b8800004 	swr	zero,4(a0)
9d00d254:	a0800008 	sb	zero,8(a0)
9d00d258:	a0800009 	sb	zero,9(a0)
9d00d25c:	8c430a54 	lw	v1,2644(v0)
9d00d260:	10600015 	beqz	v1,9d00d2b8 <EthRxGetPacket+0x74>
9d00d264:	24020001 	li	v0,1
9d00d268:	8c670004 	lw	a3,4(v1)
9d00d26c:	30e70080 	andi	a3,a3,0x80
9d00d270:	10e00007 	beqz	a3,9d00d290 <EthRxGetPacket+0x4c>
9d00d274:	24020002 	li	v0,2
9d00d278:	0b4034ef 	j	9d00d3bc <EthRxGetPacket+0x178>
9d00d27c:	00000000 	nop
9d00d280:	8c620004 	lw	v0,4(v1)
9d00d284:	30420080 	andi	v0,v0,0x80
9d00d288:	1440000b 	bnez	v0,9d00d2b8 <EthRxGetPacket+0x74>
9d00d28c:	24020002 	li	v0,2
9d00d290:	8c620004 	lw	v0,4(v1)
9d00d294:	04430006 	bgezl	v0,9d00d2b0 <EthRxGetPacket+0x6c>
9d00d298:	8c630000 	lw	v1,0(v1)
9d00d29c:	8c620004 	lw	v0,4(v1)
9d00d2a0:	30420800 	andi	v0,v0,0x800
9d00d2a4:	10400006 	beqz	v0,9d00d2c0 <EthRxGetPacket+0x7c>
9d00d2a8:	00000000 	nop
9d00d2ac:	8c630000 	lw	v1,0(v1)
9d00d2b0:	1460fff3 	bnez	v1,9d00d280 <EthRxGetPacket+0x3c>
9d00d2b4:	24020001 	li	v0,1
9d00d2b8:	03e00008 	jr	ra
9d00d2bc:	00000000 	nop
9d00d2c0:	10c00003 	beqz	a2,9d00d2d0 <EthRxGetPacket+0x8c>
9d00d2c4:	00606821 	move	t5,v1
9d00d2c8:	2462000c 	addiu	v0,v1,12
9d00d2cc:	acc20000 	sw	v0,0(a2)
9d00d2d0:	00803021 	move	a2,a0
9d00d2d4:	00004021 	move	t0,zero
9d00d2d8:	00003821 	move	a3,zero
9d00d2dc:	3c0ca000 	lui	t4,0xa000
9d00d2e0:	3c0b8000 	lui	t3,0x8000
9d00d2e4:	10c0001c 	beqz	a2,9d00d358 <EthRxGetPacket+0x114>
9d00d2e8:	3c0a4000 	lui	t2,0x4000
9d00d2ec:	8c620004 	lw	v0,4(v1)
9d00d2f0:	30420400 	andi	v0,v0,0x400
9d00d2f4:	1040001c 	beqz	v0,9d00d368 <EthRxGetPacket+0x124>
9d00d2f8:	8c620008 	lw	v0,8(v1)
9d00d2fc:	004b1025 	or	v0,v0,t3
9d00d300:	a8c20007 	swl	v0,7(a2)
9d00d304:	b8c20004 	swr	v0,4(a2)
9d00d308:	8c620004 	lw	v0,4(v1)
9d00d30c:	25080001 	addiu	t0,t0,1
9d00d310:	7c425400 	ext	v0,v0,0x10,0xb
9d00d314:	00024a02 	srl	t1,v0,0x8
9d00d318:	a0c20008 	sb	v0,8(a2)
9d00d31c:	a0c90009 	sb	t1,9(a2)
9d00d320:	88c20003 	lwl	v0,3(a2)
9d00d324:	98c20000 	lwr	v0,0(a2)
9d00d328:	00403021 	move	a2,v0
9d00d32c:	24e70001 	addiu	a3,a3,1
9d00d330:	8c620004 	lw	v0,4(v1)
9d00d334:	30420080 	andi	v0,v0,0x80
9d00d338:	1440fffd 	bnez	v0,9d00d330 <EthRxGetPacket+0xec>
9d00d33c:	00000000 	nop
9d00d340:	8c620004 	lw	v0,4(v1)
9d00d344:	004a1024 	and	v0,v0,t2
9d00d348:	14400009 	bnez	v0,9d00d370 <EthRxGetPacket+0x12c>
9d00d34c:	00000000 	nop
9d00d350:	14c0ffe6 	bnez	a2,9d00d2ec <EthRxGetPacket+0xa8>
9d00d354:	8c630000 	lw	v1,0(v1)
9d00d358:	14a0fff5 	bnez	a1,9d00d330 <EthRxGetPacket+0xec>
9d00d35c:	24e70001 	addiu	a3,a3,1
9d00d360:	03e00008 	jr	ra
9d00d364:	00001021 	move	v0,zero
9d00d368:	0b4034c0 	j	9d00d300 <EthRxGetPacket+0xbc>
9d00d36c:	004c1025 	or	v0,v0,t4
9d00d370:	54a00001 	bnezl	a1,9d00d378 <EthRxGetPacket+0x134>
9d00d374:	aca70000 	sw	a3,0(a1)
9d00d378:	10c00005 	beqz	a2,9d00d390 <EthRxGetPacket+0x14c>
9d00d37c:	00000000 	nop
9d00d380:	a8c00007 	swl	zero,7(a2)
9d00d384:	b8c00004 	swr	zero,4(a2)
9d00d388:	a0c00008 	sb	zero,8(a2)
9d00d38c:	a0c00009 	sb	zero,9(a2)
9d00d390:	1080ffc9 	beqz	a0,9d00d2b8 <EthRxGetPacket+0x74>
9d00d394:	00001021 	move	v0,zero
9d00d398:	14e8ffc7 	bne	a3,t0,9d00d2b8 <EthRxGetPacket+0x74>
9d00d39c:	24020007 	li	v0,7
9d00d3a0:	8da30004 	lw	v1,4(t5)
9d00d3a4:	24040001 	li	a0,1
9d00d3a8:	00001021 	move	v0,zero
9d00d3ac:	7c835ac4 	ins	v1,a0,0xb,0x1
9d00d3b0:	ada30004 	sw	v1,4(t5)
9d00d3b4:	03e00008 	jr	ra
9d00d3b8:	00000000 	nop
9d00d3bc:	03e00008 	jr	ra
9d00d3c0:	00000000 	nop

9d00d3c4 <EthRxGetBuffer>:
9d00d3c4:	27bdffd8 	addiu	sp,sp,-40
9d00d3c8:	afb00020 	sw	s0,32(sp)
9d00d3cc:	00a03021 	move	a2,a1
9d00d3d0:	00808021 	move	s0,a0
9d00d3d4:	27a50010 	addiu	a1,sp,16
9d00d3d8:	27a40014 	addiu	a0,sp,20
9d00d3dc:	afbf0024 	sw	ra,36(sp)
9d00d3e0:	0f403491 	jal	9d00d244 <EthRxGetPacket>
9d00d3e4:	afa00014 	sw	zero,20(sp)
9d00d3e8:	8fa30018 	lw	v1,24(sp)
9d00d3ec:	8fbf0024 	lw	ra,36(sp)
9d00d3f0:	ae030000 	sw	v1,0(s0)
9d00d3f4:	8fb00020 	lw	s0,32(sp)
9d00d3f8:	03e00008 	jr	ra
9d00d3fc:	27bd0028 	addiu	sp,sp,40

9d00d400 <EthRxSetBufferSize>:
9d00d400:	2482000f 	addiu	v0,a0,15
9d00d404:	28830000 	slti	v1,a0,0
9d00d408:	0043200b 	movn	a0,v0,v1
9d00d40c:	00042103 	sra	a0,a0,0x4
9d00d410:	10800005 	beqz	a0,9d00d428 <EthRxSetBufferSize+0x28>
9d00d414:	24020006 	li	v0,6
9d00d418:	3c02bf89 	lui	v0,0xbf89
9d00d41c:	00042100 	sll	a0,a0,0x4
9d00d420:	ac449010 	sw	a0,-28656(v0)
9d00d424:	00001021 	move	v0,zero
9d00d428:	03e00008 	jr	ra
9d00d42c:	00000000 	nop

9d00d430 <_EthTxSchedBuffer>:
9d00d430:	04800003 	bltz	a0,9d00d440 <_EthTxSchedBuffer+0x10>
9d00d434:	24020005 	li	v0,5
9d00d438:	03e00008 	jr	ra
9d00d43c:	00000000 	nop
9d00d440:	3c02a000 	lui	v0,0xa000
9d00d444:	24470a3c 	addiu	a3,v0,2620
9d00d448:	8c430a3c 	lw	v1,2620(v0)
9d00d44c:	8ce80004 	lw	t0,4(a3)
9d00d450:	5068001d 	beql	v1,t0,9d00d4c8 <_EthTxSchedBuffer+0x98>
9d00d454:	ace00004 	sw	zero,4(a3)
9d00d458:	8c670000 	lw	a3,0(v1)
9d00d45c:	ac470a3c 	sw	a3,2620(v0)
9d00d460:	1060fff5 	beqz	v1,9d00d438 <_EthTxSchedBuffer+0x8>
9d00d464:	24020004 	li	v0,4
9d00d468:	00052c00 	sll	a1,a1,0x10
9d00d46c:	7c87e000 	ext	a3,a0,0x0,0x1d
9d00d470:	34a50180 	ori	a1,a1,0x180
9d00d474:	00042742 	srl	a0,a0,0x1d
9d00d478:	ac670008 	sw	a3,8(v1)
9d00d47c:	ac650004 	sw	a1,4(v1)
9d00d480:	1082000b 	beq	a0,v0,9d00d4b0 <_EthTxSchedBuffer+0x80>
9d00d484:	00000000 	nop
9d00d488:	8cc20004 	lw	v0,4(a2)
9d00d48c:	10400010 	beqz	v0,9d00d4d0 <_EthTxSchedBuffer+0xa0>
9d00d490:	ac600000 	sw	zero,0(v1)
9d00d494:	24640004 	addiu	a0,v1,4
9d00d498:	7c84e000 	ext	a0,a0,0x0,0x1d
9d00d49c:	ac430000 	sw	v1,0(v0)
9d00d4a0:	ac440014 	sw	a0,20(v0)
9d00d4a4:	00001021 	move	v0,zero
9d00d4a8:	03e00008 	jr	ra
9d00d4ac:	acc30004 	sw	v1,4(a2)
9d00d4b0:	8c620004 	lw	v0,4(v1)
9d00d4b4:	24040001 	li	a0,1
9d00d4b8:	7c825284 	ins	v0,a0,0xa,0x1
9d00d4bc:	ac620004 	sw	v0,4(v1)
9d00d4c0:	0b403523 	j	9d00d48c <_EthTxSchedBuffer+0x5c>
9d00d4c4:	8cc20004 	lw	v0,4(a2)
9d00d4c8:	0b403518 	j	9d00d460 <_EthTxSchedBuffer+0x30>
9d00d4cc:	ac400a3c 	sw	zero,2620(v0)
9d00d4d0:	acc30004 	sw	v1,4(a2)
9d00d4d4:	03e00008 	jr	ra
9d00d4d8:	acc30000 	sw	v1,0(a2)

9d00d4dc <_EthTxSchedList>:
9d00d4dc:	8c820000 	lw	v0,0(a0)
9d00d4e0:	27bdffe8 	addiu	sp,sp,-24
9d00d4e4:	afbf0014 	sw	ra,20(sp)
9d00d4e8:	afb00010 	sw	s0,16(sp)
9d00d4ec:	10400015 	beqz	v0,9d00d544 <_EthTxSchedList+0x68>
9d00d4f0:	00802821 	move	a1,a0
9d00d4f4:	8c430004 	lw	v1,4(v0)
9d00d4f8:	24070001 	li	a3,1
9d00d4fc:	3c10a000 	lui	s0,0xa000
9d00d500:	7ce3ffc4 	ins	v1,a3,0x1f,0x1
9d00d504:	ac430004 	sw	v1,4(v0)
9d00d508:	8c820004 	lw	v0,4(a0)
9d00d50c:	00003021 	move	a2,zero
9d00d510:	26040a44 	addiu	a0,s0,2628
9d00d514:	8c430004 	lw	v1,4(v0)
9d00d518:	7ce3f784 	ins	v1,a3,0x1e,0x1
9d00d51c:	ac430004 	sw	v1,4(v0)
9d00d520:	0f40358b 	jal	9d00d62c <_EthAppendBusyList>
9d00d524:	00000000 	nop
9d00d528:	3c02bf89 	lui	v0,0xbf89
9d00d52c:	8c439020 	lw	v1,-28640(v0)
9d00d530:	10600008 	beqz	v1,9d00d554 <_EthTxSchedList+0x78>
9d00d534:	8e030a44 	lw	v1,2628(s0)
9d00d538:	24030200 	li	v1,512
9d00d53c:	3c02bf89 	lui	v0,0xbf89
9d00d540:	ac439008 	sw	v1,-28664(v0)
9d00d544:	8fbf0014 	lw	ra,20(sp)
9d00d548:	8fb00010 	lw	s0,16(sp)
9d00d54c:	03e00008 	jr	ra
9d00d550:	27bd0018 	addiu	sp,sp,24
9d00d554:	24630004 	addiu	v1,v1,4
9d00d558:	7c63e000 	ext	v1,v1,0x0,0x1d
9d00d55c:	ac439020 	sw	v1,-28640(v0)
9d00d560:	0b40354f 	j	9d00d53c <_EthTxSchedList+0x60>
9d00d564:	24030200 	li	v1,512

9d00d568 <EthTxSendBuffer>:
9d00d568:	27bdffd8 	addiu	sp,sp,-40
9d00d56c:	30a5ffff 	andi	a1,a1,0xffff
9d00d570:	27a60010 	addiu	a2,sp,16
9d00d574:	afbf0024 	sw	ra,36(sp)
9d00d578:	afa00010 	sw	zero,16(sp)
9d00d57c:	0f40350c 	jal	9d00d430 <_EthTxSchedBuffer>
9d00d580:	afa00014 	sw	zero,20(sp)
9d00d584:	10400022 	beqz	v0,9d00d610 <EthTxSendBuffer+0xa8>
9d00d588:	8fa30010 	lw	v1,16(sp)
9d00d58c:	10600019 	beqz	v1,9d00d5f4 <EthTxSendBuffer+0x8c>
9d00d590:	3c08a000 	lui	t0,0xa000
9d00d594:	8fa70014 	lw	a3,20(sp)
9d00d598:	250a0a3c 	addiu	t2,t0,2620
9d00d59c:	8d440004 	lw	a0,4(t2)
9d00d5a0:	1067000d 	beq	v1,a3,9d00d5d8 <EthTxSendBuffer+0x70>
9d00d5a4:	8d090a3c 	lw	t1,2620(t0)
9d00d5a8:	24650004 	addiu	a1,v1,4
9d00d5ac:	8c660000 	lw	a2,0(v1)
9d00d5b0:	1060000e 	beqz	v1,9d00d5ec <EthTxSendBuffer+0x84>
9d00d5b4:	7ca5e000 	ext	a1,a1,0x0,0x1d
9d00d5b8:	10800011 	beqz	a0,9d00d600 <EthTxSendBuffer+0x98>
9d00d5bc:	ac600000 	sw	zero,0(v1)
9d00d5c0:	ac830000 	sw	v1,0(a0)
9d00d5c4:	ac850014 	sw	a1,20(a0)
9d00d5c8:	00602021 	move	a0,v1
9d00d5cc:	00c01821 	move	v1,a2
9d00d5d0:	5467fff6 	bnel	v1,a3,9d00d5ac <EthTxSendBuffer+0x44>
9d00d5d4:	24650004 	addiu	a1,v1,4
9d00d5d8:	24650004 	addiu	a1,v1,4
9d00d5dc:	00003021 	move	a2,zero
9d00d5e0:	00003821 	move	a3,zero
9d00d5e4:	1460fff4 	bnez	v1,9d00d5b8 <EthTxSendBuffer+0x50>
9d00d5e8:	7ca5e000 	ext	a1,a1,0x0,0x1d
9d00d5ec:	ad440004 	sw	a0,4(t2)
9d00d5f0:	ad090a3c 	sw	t1,2620(t0)
9d00d5f4:	8fbf0024 	lw	ra,36(sp)
9d00d5f8:	03e00008 	jr	ra
9d00d5fc:	27bd0028 	addiu	sp,sp,40
9d00d600:	00604821 	move	t1,v1
9d00d604:	00602021 	move	a0,v1
9d00d608:	0b403574 	j	9d00d5d0 <EthTxSendBuffer+0x68>
9d00d60c:	00c01821 	move	v1,a2
9d00d610:	27a40010 	addiu	a0,sp,16
9d00d614:	0f403537 	jal	9d00d4dc <_EthTxSchedList>
9d00d618:	afa20018 	sw	v0,24(sp)
9d00d61c:	8fbf0024 	lw	ra,36(sp)
9d00d620:	8fa20018 	lw	v0,24(sp)
9d00d624:	03e00008 	jr	ra
9d00d628:	27bd0028 	addiu	sp,sp,40

9d00d62c <_EthAppendBusyList>:
9d00d62c:	8ca30000 	lw	v1,0(a1)
9d00d630:	8ca20004 	lw	v0,4(a1)
9d00d634:	10620049 	beq	v1,v0,9d00d75c <_EthAppendBusyList+0x130>
9d00d638:	8c890004 	lw	t1,4(a0)
9d00d63c:	8c670000 	lw	a3,0(v1)
9d00d640:	aca70000 	sw	a3,0(a1)
9d00d644:	8c680004 	lw	t0,4(v1)
9d00d648:	3c0bbf89 	lui	t3,0xbf89
9d00d64c:	240a0001 	li	t2,1
9d00d650:	7c0839c4 	ins	t0,zero,0x7,0x1
9d00d654:	ac680004 	sw	t0,4(v1)
9d00d658:	50470017 	beql	v0,a3,9d00d6b8 <_EthAppendBusyList+0x8c>
9d00d65c:	aca00004 	sw	zero,4(a1)
9d00d660:	8ce20000 	lw	v0,0(a3)
9d00d664:	10e00016 	beqz	a3,9d00d6c0 <_EthAppendBusyList+0x94>
9d00d668:	aca20000 	sw	v0,0(a1)
9d00d66c:	8c820004 	lw	v0,4(a0)
9d00d670:	10400034 	beqz	v0,9d00d744 <_EthAppendBusyList+0x118>
9d00d674:	ace00000 	sw	zero,0(a3)
9d00d678:	24e80004 	addiu	t0,a3,4
9d00d67c:	7d08e000 	ext	t0,t0,0x0,0x1d
9d00d680:	ac470000 	sw	a3,0(v0)
9d00d684:	ac480014 	sw	t0,20(v0)
9d00d688:	ac870004 	sw	a3,4(a0)
9d00d68c:	50c00006 	beqzl	a2,9d00d6a8 <_EthAppendBusyList+0x7c>
9d00d690:	8ca70000 	lw	a3,0(a1)
9d00d694:	8ce20004 	lw	v0,4(a3)
9d00d698:	30421000 	andi	v0,v0,0x1000
9d00d69c:	50400001 	beqzl	v0,9d00d6a4 <_EthAppendBusyList+0x78>
9d00d6a0:	ad6a9008 	sw	t2,-28664(t3)
9d00d6a4:	8ca70000 	lw	a3,0(a1)
9d00d6a8:	8ca20004 	lw	v0,4(a1)
9d00d6ac:	5447ffed 	bnel	v0,a3,9d00d664 <_EthAppendBusyList+0x38>
9d00d6b0:	8ce20000 	lw	v0,0(a3)
9d00d6b4:	aca00004 	sw	zero,4(a1)
9d00d6b8:	14e0ffec 	bnez	a3,9d00d66c <_EthAppendBusyList+0x40>
9d00d6bc:	aca00000 	sw	zero,0(a1)
9d00d6c0:	8c6a0004 	lw	t2,4(v1)
9d00d6c4:	8c680008 	lw	t0,8(v1)
9d00d6c8:	8c67000c 	lw	a3,12(v1)
9d00d6cc:	8c650010 	lw	a1,16(v1)
9d00d6d0:	8d220014 	lw	v0,20(t1)
9d00d6d4:	ac620014 	sw	v0,20(v1)
9d00d6d8:	ad2a0004 	sw	t2,4(t1)
9d00d6dc:	ad280008 	sw	t0,8(t1)
9d00d6e0:	ad27000c 	sw	a3,12(t1)
9d00d6e4:	ad250010 	sw	a1,16(t1)
9d00d6e8:	ad220014 	sw	v0,20(t1)
9d00d6ec:	8c820004 	lw	v0,4(a0)
9d00d6f0:	ac600004 	sw	zero,4(v1)
9d00d6f4:	10400016 	beqz	v0,9d00d750 <_EthAppendBusyList+0x124>
9d00d6f8:	ac600000 	sw	zero,0(v1)
9d00d6fc:	24650004 	addiu	a1,v1,4
9d00d700:	7ca5e000 	ext	a1,a1,0x0,0x1d
9d00d704:	ac430000 	sw	v1,0(v0)
9d00d708:	ac450014 	sw	a1,20(v0)
9d00d70c:	ac830004 	sw	v1,4(a0)
9d00d710:	8d220004 	lw	v0,4(t1)
9d00d714:	24030001 	li	v1,1
9d00d718:	7c6239c4 	ins	v0,v1,0x7,0x1
9d00d71c:	ad220004 	sw	v0,4(t1)
9d00d720:	10c00006 	beqz	a2,9d00d73c <_EthAppendBusyList+0x110>
9d00d724:	00000000 	nop
9d00d728:	8d220004 	lw	v0,4(t1)
9d00d72c:	30421000 	andi	v0,v0,0x1000
9d00d730:	14400002 	bnez	v0,9d00d73c <_EthAppendBusyList+0x110>
9d00d734:	3c02bf89 	lui	v0,0xbf89
9d00d738:	ac439008 	sw	v1,-28664(v0)
9d00d73c:	03e00008 	jr	ra
9d00d740:	00000000 	nop
9d00d744:	ac870004 	sw	a3,4(a0)
9d00d748:	0b4035a3 	j	9d00d68c <_EthAppendBusyList+0x60>
9d00d74c:	ac870000 	sw	a3,0(a0)
9d00d750:	ac830004 	sw	v1,4(a0)
9d00d754:	0b4035c4 	j	9d00d710 <_EthAppendBusyList+0xe4>
9d00d758:	ac830000 	sw	v1,0(a0)
9d00d75c:	aca00004 	sw	zero,4(a1)
9d00d760:	aca00000 	sw	zero,0(a1)
9d00d764:	00001021 	move	v0,zero
9d00d768:	0b403591 	j	9d00d644 <_EthAppendBusyList+0x18>
9d00d76c:	00003821 	move	a3,zero

9d00d770 <EthMIIMReadStart>:
9d00d770:	3c03bf89 	lui	v1,0xbf89
9d00d774:	8c6292d0 	lw	v0,-27952(v1)
9d00d778:	30420001 	andi	v0,v0,0x1
9d00d77c:	1440fffd 	bnez	v0,9d00d774 <EthMIIMReadStart+0x4>
9d00d780:	3c02bf89 	lui	v0,0xbf89
9d00d784:	00052a00 	sll	a1,a1,0x8
9d00d788:	00a42025 	or	a0,a1,a0
9d00d78c:	ac4492a0 	sw	a0,-28000(v0)
9d00d790:	24030001 	li	v1,1
9d00d794:	3c02bf89 	lui	v0,0xbf89
9d00d798:	ac439290 	sw	v1,-28016(v0)
	...
9d00d7a8:	03e00008 	jr	ra
9d00d7ac:	00000000 	nop

9d00d7b0 <EthMIIMReadResult>:
9d00d7b0:	3c03bf89 	lui	v1,0xbf89
9d00d7b4:	8c6292d0 	lw	v0,-27952(v1)
9d00d7b8:	30420001 	andi	v0,v0,0x1
9d00d7bc:	1440fffd 	bnez	v0,9d00d7b4 <EthMIIMReadResult+0x4>
9d00d7c0:	3c02bf89 	lui	v0,0xbf89
9d00d7c4:	ac409290 	sw	zero,-28016(v0)
9d00d7c8:	3c02bf89 	lui	v0,0xbf89
9d00d7cc:	8c4292c0 	lw	v0,-27968(v0)
9d00d7d0:	03e00008 	jr	ra
9d00d7d4:	3042ffff 	andi	v0,v0,0xffff

9d00d7d8 <EthMIIMWriteStart>:
9d00d7d8:	30c6ffff 	andi	a2,a2,0xffff
9d00d7dc:	3c03bf89 	lui	v1,0xbf89
9d00d7e0:	8c6292d0 	lw	v0,-27952(v1)
9d00d7e4:	30420001 	andi	v0,v0,0x1
9d00d7e8:	1440fffd 	bnez	v0,9d00d7e0 <EthMIIMWriteStart+0x8>
9d00d7ec:	3c02bf89 	lui	v0,0xbf89
9d00d7f0:	00052a00 	sll	a1,a1,0x8
9d00d7f4:	00a42025 	or	a0,a1,a0
9d00d7f8:	ac4492a0 	sw	a0,-28000(v0)
9d00d7fc:	3c02bf89 	lui	v0,0xbf89
9d00d800:	ac4692b0 	sw	a2,-27984(v0)
9d00d804:	00000000 	nop
9d00d808:	03e00008 	jr	ra
9d00d80c:	00000000 	nop

9d00d810 <EthMIIMConfig>:
9d00d810:	00041082 	srl	v0,a0,0x2
9d00d814:	3c09bf89 	lui	t1,0xbf89
9d00d818:	34038000 	li	v1,0x8000
9d00d81c:	00a2102b 	sltu	v0,a1,v0
9d00d820:	ad239280 	sw	v1,-28032(t1)
9d00d824:	24030004 	li	v1,4
9d00d828:	ad209280 	sw	zero,-28032(t1)
9d00d82c:	10400010 	beqz	v0,9d00d870 <EthMIIMConfig+0x60>
9d00d830:	00000000 	nop
9d00d834:	3c029d01 	lui	v0,0x9d01
9d00d838:	2442df16 	addiu	v0,v0,-8426
9d00d83c:	24030001 	li	v1,1
9d00d840:	24070008 	li	a3,8
9d00d844:	84460000 	lh	a2,0(v0)
9d00d848:	0086001b 	divu	zero,a0,a2
9d00d84c:	00c001f4 	teq	a2,zero,0x7
9d00d850:	00003012 	mflo	a2
9d00d854:	00a6302b 	sltu	a2,a1,a2
9d00d858:	10c00008 	beqz	a2,9d00d87c <EthMIIMConfig+0x6c>
9d00d85c:	24420002 	addiu	v0,v0,2
9d00d860:	24630001 	addiu	v1,v1,1
9d00d864:	5467fff8 	bnel	v1,a3,9d00d848 <EthMIIMConfig+0x38>
9d00d868:	84460000 	lh	a2,0(v0)
9d00d86c:	24030020 	li	v1,32
9d00d870:	ad239280 	sw	v1,-28032(t1)
9d00d874:	03e00008 	jr	ra
9d00d878:	00000000 	nop
9d00d87c:	24630001 	addiu	v1,v1,1
9d00d880:	00031880 	sll	v1,v1,0x2
9d00d884:	ad239280 	sw	v1,-28032(t1)
9d00d888:	03e00008 	jr	ra
9d00d88c:	00000000 	nop

9d00d890 <SoftReset>:
9d00d890:	27bdffe8 	addiu	sp,sp,-24
9d00d894:	afbf0014 	sw	ra,20(sp)
9d00d898:	0f403642 	jal	9d00d908 <INTDisableInterrupts>
9d00d89c:	00000000 	nop
9d00d8a0:	3c02bf88 	lui	v0,0xbf88
9d00d8a4:	8c433000 	lw	v1,12288(v0)
9d00d8a8:	7c630300 	ext	v1,v1,0xc,0x1
9d00d8ac:	14600008 	bnez	v1,9d00d8d0 <SoftReset+0x40>
9d00d8b0:	3c03aa99 	lui	v1,0xaa99
9d00d8b4:	24041000 	li	a0,4096
9d00d8b8:	3c03bf88 	lui	v1,0xbf88
9d00d8bc:	ac643008 	sw	a0,12296(v1)
9d00d8c0:	8c433000 	lw	v1,12288(v0)
9d00d8c4:	30630800 	andi	v1,v1,0x800
9d00d8c8:	1460fffd 	bnez	v1,9d00d8c0 <SoftReset+0x30>
9d00d8cc:	3c03aa99 	lui	v1,0xaa99
9d00d8d0:	3c02bf81 	lui	v0,0xbf81
9d00d8d4:	24636655 	addiu	v1,v1,26197
9d00d8d8:	ac40f230 	sw	zero,-3536(v0)
9d00d8dc:	ac43f230 	sw	v1,-3536(v0)
9d00d8e0:	3c035566 	lui	v1,0x5566
9d00d8e4:	346399aa 	ori	v1,v1,0x99aa
9d00d8e8:	ac43f230 	sw	v1,-3536(v0)
9d00d8ec:	3c02bf81 	lui	v0,0xbf81
9d00d8f0:	24030001 	li	v1,1
9d00d8f4:	ac43f618 	sw	v1,-2536(v0)
9d00d8f8:	3c02bf81 	lui	v0,0xbf81
9d00d8fc:	8c42f610 	lw	v0,-2544(v0)
9d00d900:	0b403640 	j	9d00d900 <SoftReset+0x70>
9d00d904:	00000000 	nop

9d00d908 <INTDisableInterrupts>:
9d00d908:	03e00008 	jr	ra
9d00d90c:	41626000 	di	v0

9d00d910 <INTRestoreInterrupts>:
9d00d910:	30840001 	andi	a0,a0,0x1
9d00d914:	14800003 	bnez	a0,9d00d924 <INTRestoreInterrupts+0x14>
9d00d918:	00000000 	nop
9d00d91c:	03e00008 	jr	ra
9d00d920:	41606000 	di
9d00d924:	03e00008 	jr	ra
9d00d928:	41606020 	ei

9d00d92c <INTClearFlag>:
9d00d92c:	00041080 	sll	v0,a0,0x2
9d00d930:	00042100 	sll	a0,a0,0x4
9d00d934:	00822023 	subu	a0,a0,v0
9d00d938:	3c029d01 	lui	v0,0x9d01
9d00d93c:	2442df24 	addiu	v0,v0,-8412
9d00d940:	00822021 	addu	a0,a0,v0
9d00d944:	8c820000 	lw	v0,0(a0)
9d00d948:	8c830008 	lw	v1,8(a0)
9d00d94c:	ac430004 	sw	v1,4(v0)
9d00d950:	03e00008 	jr	ra
9d00d954:	00000000 	nop

9d00d958 <INTEnable>:
9d00d958:	14a0000b 	bnez	a1,9d00d988 <INTEnable+0x30>
9d00d95c:	00041080 	sll	v0,a0,0x2
9d00d960:	00042100 	sll	a0,a0,0x4
9d00d964:	00822023 	subu	a0,a0,v0
9d00d968:	3c029d01 	lui	v0,0x9d01
9d00d96c:	2442df24 	addiu	v0,v0,-8412
9d00d970:	00442021 	addu	a0,v0,a0
9d00d974:	8c820004 	lw	v0,4(a0)
9d00d978:	8c830008 	lw	v1,8(a0)
9d00d97c:	ac430004 	sw	v1,4(v0)
9d00d980:	03e00008 	jr	ra
9d00d984:	00000000 	nop
9d00d988:	00042100 	sll	a0,a0,0x4
9d00d98c:	00822023 	subu	a0,a0,v0
9d00d990:	3c029d01 	lui	v0,0x9d01
9d00d994:	2442df24 	addiu	v0,v0,-8412
9d00d998:	00442021 	addu	a0,v0,a0
9d00d99c:	8c820004 	lw	v0,4(a0)
9d00d9a0:	8c830008 	lw	v1,8(a0)
9d00d9a4:	ac430008 	sw	v1,8(v0)
9d00d9a8:	03e00008 	jr	ra
9d00d9ac:	00000000 	nop

9d00d9b0 <PORTSetPinsDigitalIn>:
9d00d9b0:	00041080 	sll	v0,a0,0x2
9d00d9b4:	00042100 	sll	a0,a0,0x4
9d00d9b8:	00822023 	subu	a0,a0,v0
9d00d9bc:	3c029d01 	lui	v0,0x9d01
9d00d9c0:	2442e6f8 	addiu	v0,v0,-6408
9d00d9c4:	00822021 	addu	a0,a0,v0
9d00d9c8:	8c830000 	lw	v1,0(a0)
9d00d9cc:	8c820008 	lw	v0,8(a0)
9d00d9d0:	ac650008 	sw	a1,8(v1)
9d00d9d4:	10400004 	beqz	v0,9d00d9e8 <PORTSetPinsDigitalIn+0x38>
9d00d9d8:	00000000 	nop
9d00d9dc:	8c830004 	lw	v1,4(a0)
9d00d9e0:	00a32824 	and	a1,a1,v1
9d00d9e4:	ac450008 	sw	a1,8(v0)
9d00d9e8:	03e00008 	jr	ra
9d00d9ec:	00000000 	nop

9d00d9f0 <PORTSetPinsDigitalOut>:
9d00d9f0:	00041080 	sll	v0,a0,0x2
9d00d9f4:	00042100 	sll	a0,a0,0x4
9d00d9f8:	00822023 	subu	a0,a0,v0
9d00d9fc:	3c029d01 	lui	v0,0x9d01
9d00da00:	2442e6f8 	addiu	v0,v0,-6408
9d00da04:	00822021 	addu	a0,a0,v0
9d00da08:	8c830000 	lw	v1,0(a0)
9d00da0c:	8c820008 	lw	v0,8(a0)
9d00da10:	ac650004 	sw	a1,4(v1)
9d00da14:	10400004 	beqz	v0,9d00da28 <PORTSetPinsDigitalOut+0x38>
9d00da18:	00000000 	nop
9d00da1c:	8c830004 	lw	v1,4(a0)
9d00da20:	00a32824 	and	a1,a1,v1
9d00da24:	ac450008 	sw	a1,8(v0)
9d00da28:	03e00008 	jr	ra
9d00da2c:	00000000 	nop

9d00da30 <__errno>:
9d00da30:	3c02a000 	lui	v0,0xa000
9d00da34:	03e00008 	jr	ra
9d00da38:	8c420930 	lw	v0,2352(v0)

9d00da3c <__do_global_ctors_aux>:
9d00da3c:	3c029d01 	lui	v0,0x9d01
9d00da40:	8c42dad4 	lw	v0,-9516(v0)
9d00da44:	27bdffe0 	addiu	sp,sp,-32
9d00da48:	2403ffff 	li	v1,-1
9d00da4c:	afbf001c 	sw	ra,28(sp)
9d00da50:	afb10018 	sw	s1,24(sp)
9d00da54:	10430009 	beq	v0,v1,9d00da7c <__do_global_ctors_aux+0x40>
9d00da58:	afb00014 	sw	s0,20(sp)
9d00da5c:	3c119d01 	lui	s1,0x9d01
9d00da60:	2631dad4 	addiu	s1,s1,-9516
9d00da64:	2410ffff 	li	s0,-1
9d00da68:	0040f809 	jalr	v0
9d00da6c:	2631fffc 	addiu	s1,s1,-4
9d00da70:	8e220000 	lw	v0,0(s1)
9d00da74:	1450fffc 	bne	v0,s0,9d00da68 <__do_global_ctors_aux+0x2c>
9d00da78:	00000000 	nop
9d00da7c:	8fbf001c 	lw	ra,28(sp)
9d00da80:	8fb10018 	lw	s1,24(sp)
9d00da84:	8fb00014 	lw	s0,20(sp)
9d00da88:	03e00008 	jr	ra
9d00da8c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .init:

9d00da90 <_init>:
9d00da90:	27bdffe0 	addiu	sp,sp,-32
9d00da94:	afbf0014 	sw	ra,20(sp)
9d00da98:	0f4004b3 	jal	9d0012cc <frame_dummy>
9d00da9c:	00000000 	nop
9d00daa0:	0f40368f 	jal	9d00da3c <__do_global_ctors_aux>
9d00daa4:	00000000 	nop
9d00daa8:	8fbf0014 	lw	ra,20(sp)
9d00daac:	03e00008 	jr	ra
9d00dab0:	27bd0020 	addiu	sp,sp,32

Disassembly of section .fini:

9d00dab4 <_fini>:
9d00dab4:	27bdffe0 	addiu	sp,sp,-32
9d00dab8:	afbf0014 	sw	ra,20(sp)
9d00dabc:	0f400484 	jal	9d001210 <__do_global_dtors_aux>
9d00dac0:	00000000 	nop
9d00dac4:	8fbf0014 	lw	ra,20(sp)
9d00dac8:	03e00008 	jr	ra
9d00dacc:	27bd0020 	addiu	sp,sp,32

Disassembly of section .rodata:

9d00db34 <_ZTV6Client-0x64>:
9d00db34:	0066664f 	0x66664f
9d00db38:	00006e4f 	0x6e4f
9d00db3c:	636c6557 	0x636c6557
9d00db40:	2c656d6f 	sltiu	a1,v1,28015
9d00db44:	77656e20 	jalx	9d95b880 <_EEPROM_ADDR+0x8dc880>
9d00db48:	65737520 	0x65737520
9d00db4c:	00002172 	tlt	zero,zero,0x85
9d00db50:	746f6f62 	jalx	91bdbd88 <_imageExecutionJumpToFirstInFlash+0x8fbdbd88>
9d00db54:	64616f6c 	0x64616f6c
9d00db58:	00007265 	0x7265
9d00db5c:	616c6572 	0x616c6572
9d00db60:	6e6f2079 	0x6e6f2079
9d00db64:	00000000 	nop
9d00db68:	616c6572 	0x616c6572
9d00db6c:	666f2079 	0x666f2079
9d00db70:	00000066 	0x66
9d00db74:	75706e69 	jalx	95c1b9a4 <_imageExecutionJumpToFirstInFlash+0x93c1b9a4>
9d00db78:	00000074 	teq	zero,zero,0x1
9d00db7c:	75706e49 	jalx	95c1b924 <_imageExecutionJumpToFirstInFlash+0x93c1b924>
9d00db80:	74732074 	jalx	91cc81d0 <_imageExecutionJumpToFirstInFlash+0x8fcc81d0>
9d00db84:	3a657461 	xori	a1,s3,0x7461
9d00db88:	00000020 	add	zero,zero,zero
9d00db8c:	0000203e 	0x203e
9d00db90:	20434149 	addi	v1,v0,16713
9d00db94:	00000000 	nop

9d00db98 <_ZTV6Client>:
	...
9d00dba0:	9d0018a4 9d001894 9d001880 9d001858     ............X...
9d00dbb0:	9d001850 9d001844 9d00183c 9d001834     P...D...<...4...

9d00dbc0 <_ZTV6Server>:
	...
9d00dbc8:	9d001b84 9d001b2c 9d001ac4 00000000     ....,...........
9d00dbd8:	50494843 0054494b                       CHIPKIT.

9d00dbe0 <SerializedMACAddress>:
9d00dbe0:	00a30400 00000000 6c6f6f70 70746e2e     ........pool.ntp
9d00dbf0:	67726f2e 00000000 9d002b28 9d002ad0     .org....(+...*..
9d00dc00:	9d002b84 9d002b60 9d002b84 9d002b60     .+..`+...+..`+..
9d00dc10:	9d002b84 9d002b60 9d002a18 9d002a3c     .+..`+...*..<*..
9d00dc20:	9d0029dc 9d002a7c 9d002aac              .)..|*...*..

9d00dc2c <C.66.26417>:
9d00dc2c:	00a30400 00000000 9d004218 9d004220     .........B.. B..
9d00dc3c:	9d0040c8 9d0042cc 9d004268 9d004270     .@...B..hB..pB..
9d00dc4c:	9d0042b0 9d0042d4 9d005eb8 9d005f0c     .B...B...^..._..
9d00dc5c:	9d005eb8 9d005eb8 9d005eac 9d005eb8     .^...^...^...^..
9d00dc6c:	9d005f28 9d005f28 9d005eac 9d005eac     (_..(_...^...^..
9d00dc7c:	9d005eac 9d005f8c 9d005eac 9d005eac     .^..._...^...^..
9d00dc8c:	9d005ee8 9d0071dc 9d007234 9d0072f0     .^...q..4r...r..
9d00dc9c:	9d00734c 9d006de0 9d007394 9d0073c0     Ls...m...s...s..
9d00dcac:	9d0072c0 9d007088 9d0070bc 9d0070a8     .r...p...p...p..
9d00dcbc:	9d0072c0 9d007088                       .r...p..

9d00dcc4 <TCPSocketInitializer>:
9d00dcc4:	03e80109 010903e8 03e803e8 03e80109     ................
9d00dcd4:	010903e8 03e803e8 03e80109 010903e8     ................
9d00dce4:	03e803e8 03e80109 010903e8 03e803e8     ................
9d00dcf4:	03e80109 010903e8 03e803e8 9d008e90     ................
9d00dd04:	9d008ea4 9d008ec8 9d008f74 9d008fac     ........t.......
9d00dd14:	9d008db8 9d009064 9d00901c 9d0090a8     ....d...........
9d00dd24:	9d00901c 9d0090a8 9d00901c 9d0090a8     ................

9d00dd34 <port_to_tris_PGM>:
9d00dd34:	00000000 bf886000 bf886040 bf886080     .....`..@`...`..
9d00dd44:	bf8860c0 bf886100 bf886140 bf886180     .`...a..@a...a..
9d00dd54:	00000000                                ....

9d00dd58 <digital_pin_to_port_PGM>:
9d00dd58:	04050606 05040403 03040404 06060101     ................
9d00dd68:	04040606 03030101 07070603 05050707     ................
9d00dd78:	05050505 04040505 07020202 04060601     ................
9d00dd88:	07070404 02020707 02020202 02020202     ................
9d00dd98:	02020202 01010202 03040101 07070404     ................
9d00dda8:	07070101 00030107                       ........

9d00ddb0 <digital_pin_to_bit_mask_PGM>:
9d00ddb0:	01000004 00010100 00024000 02000004     .........@......
9d00ddc0:	00081000 00100010 00080004 10002000     ............. ..
9d00ddd0:	00100020 40008000 40008000 00080004      ......@...@....
9d00dde0:	00080001 00040008 00808000 00400080     ..............@.
9d00ddf0:	00100020 00040008 00010002 00200400      ............. .
9d00de00:	20000800 01001000 00010400 00400002     ... ..........@.
9d00de10:	08000100 01000080 02000040 00020001     ........@.......
9d00de20:	00080004 00200010 00800040 02000100     ...... .@.......
9d00de30:	08000400 20001000 80004000 00020001     ....... .@......
9d00de40:	00200010 20000200 00802000 00010002     .. .... . ......
9d00de50:	00800040 10004000 02002000 00000002     @....@... ......

9d00de60 <digital_pin_to_timer_PGM>:
9d00de60:	00000000 00010000 00020100 00000003     ................
9d00de70:	00040050 05000005 00000000 00000000     P...............
	...
9d00de8c:	04000300 00000000 00000000 00000000     ................
	...
9d00deac:	00000030 00000000 00000000 00000000     0...............
9d00debc:	00000000 00400010 00000000 00000000     ......@.........
	...
9d00def4:	00000020 00000000 00000000 00000000      ...............
	...
9d00df10:	00000043                                C...

9d00df14 <_EthMIIClkDivTbl>:
9d00df14:	00060004 000a0008 0014000e 0028001c     ..............(.

9d00df24 <__IntSrcTbl>:
9d00df24:	bf881030 bf881060 00000001 bf881030     0...`.......0...
9d00df34:	bf881060 00000002 bf881030 bf881060     `.......0...`...
9d00df44:	00000004 bf881030 bf881060 00000008     ....0...`.......
9d00df54:	bf881030 bf881060 00000080 bf881030     0...`.......0...
9d00df64:	bf881060 00000800 bf881030 bf881060     `.......0...`...
9d00df74:	00008000 bf881030 bf881060 00080000     ....0...`.......
9d00df84:	bf881030 bf881060 00000010 bf881030     0...`.......0...
9d00df94:	bf881060 00000100 bf881030 bf881060     `.......0...`...
9d00dfa4:	00001000 bf881030 bf881060 00010000     ....0...`.......
9d00dfb4:	bf881030 bf881060 00100000 bf881030     0...`.......0...
9d00dfc4:	bf881060 00000020 bf881030 bf881060     `... ...0...`...
9d00dfd4:	00000200 bf881030 bf881060 00002000     ....0...`.... ..
9d00dfe4:	bf881030 bf881060 00020000 bf881030     0...`.......0...
9d00dff4:	bf881060 00200000 bf881040 bf881070     `..... .@...p...
9d00e004:	20000000 bf881040 bf881070 40000000     ... @...p......@
9d00e014:	bf881040 bf881070 80000000 bf881050     @...p.......P...
9d00e024:	bf881080 00000001 bf881050 bf881080     ........P.......
9d00e034:	00000002 bf881030 bf881060 00000040     ....0...`...@...
9d00e044:	bf881030 bf881060 00000400 bf881030     0...`.......0...
9d00e054:	bf881060 00004000 bf881030 bf881060     `....@..0...`...
9d00e064:	00040000 bf881030 bf881060 00400000     ....0...`.....@.
9d00e074:	bf881040 bf881070 00000001 bf881030     @...p.......0...
9d00e084:	bf881060 03800000 bf881040 bf881070     `.......@...p...
9d00e094:	000000e0 bf881030 bf881060 1c000000     ....0...`.......
9d00e0a4:	bf881040 bf881070 00000700 bf881030     @...p.......0...
9d00e0b4:	bf881060 00800000 bf881040 bf881070     `.......@...p...
9d00e0c4:	00000020 bf881030 bf881060 04000000      ...0...`.......
9d00e0d4:	bf881040 bf881070 00000100 bf881030     @...p.......0...
9d00e0e4:	bf881060 02000000 bf881040 bf881070     `.......@...p...
9d00e0f4:	00000080 bf881030 bf881060 10000000     ....0...`.......
9d00e104:	bf881040 bf881070 00000400 bf881030     @...p.......0...
9d00e114:	bf881060 01000000 bf881040 bf881070     `.......@...p...
9d00e124:	00000040 bf881030 bf881060 08000000     @...0...`.......
9d00e134:	bf881040 bf881070 00000200 bf881030     @...p.......0...
9d00e144:	bf881060 e0000000 bf881040 bf881070     `.......@...p...
9d00e154:	00003800 bf881030 bf881060 1c000000     .8..0...`.......
9d00e164:	bf881040 bf881070 000000e0 bf881040     @...p.......@...
9d00e174:	bf881070 00000700 bf881030 bf881060     p.......0...`...
9d00e184:	20000000 bf881040 bf881070 00000800     ... @...p.......
9d00e194:	bf881030 bf881060 04000000 bf881040     0...`.......@...
9d00e1a4:	bf881070 00000020 bf881040 bf881070     p... ...@...p...
9d00e1b4:	00000100 bf881030 bf881060 40000000     ....0...`......@
9d00e1c4:	bf881040 bf881070 00001000 bf881030     @...p.......0...
9d00e1d4:	bf881060 08000000 bf881040 bf881070     `.......@...p...
9d00e1e4:	00000040 bf881040 bf881070 00000200     @...@...p.......
9d00e1f4:	bf881030 bf881060 80000000 bf881040     0...`.......@...
9d00e204:	bf881070 00002000 bf881030 bf881060     p.... ..0...`...
9d00e214:	10000000 bf881040 bf881070 00000080     ....@...p.......
9d00e224:	bf881040 bf881070 00000400 bf881030     @...p.......0...
9d00e234:	bf881060 1c000000 bf881040 bf881070     `.......@...p...
9d00e244:	00000700 bf881040 bf881070 000000e0     ....@...p.......
9d00e254:	bf881050 bf881080 00000038 bf881050     P.......8...P...
9d00e264:	bf881080 00000e00 bf881050 bf881080     ........P.......
9d00e274:	000001c0 bf881030 bf881060 04000000     ....0...`.......
9d00e284:	bf881040 bf881070 00000100 bf881040     @...p.......@...
9d00e294:	bf881070 00000020 bf881050 bf881080     p... ...P.......
9d00e2a4:	00000008 bf881050 bf881080 00000200     ....P...........
9d00e2b4:	bf881050 bf881080 00000040 bf881030     P.......@...0...
9d00e2c4:	bf881060 08000000 bf881040 bf881070     `.......@...p...
9d00e2d4:	00000200 bf881040 bf881070 00000040     ....@...p...@...
9d00e2e4:	bf881050 bf881080 00000010 bf881050     P...........P...
9d00e2f4:	bf881080 00000400 bf881050 bf881080     ........P.......
9d00e304:	00000080 bf881030 bf881060 10000000     ....0...`.......
9d00e314:	bf881040 bf881070 00000400 bf881040     @...p.......@...
9d00e324:	bf881070 00000080 bf881050 bf881080     p.......P.......
9d00e334:	00000020 bf881050 bf881080 00000800      ...P...........
9d00e344:	bf881050 bf881080 00000100 bf881040     P...........@...
9d00e354:	bf881070 00000002 bf881040 bf881070     p.......@...p...
9d00e364:	00000004 bf881050 bf881080 00000004     ....P...........
9d00e374:	bf881040 bf881070 00000008 bf881040     @...p.......@...
9d00e384:	bf881070 00000010 bf881040 bf881070     p.......@...p...
9d00e394:	00004000 bf881040 bf881070 01000000     .@..@...p.......
9d00e3a4:	bf881040 bf881070 00008000 bf881040     @...p.......@...
9d00e3b4:	bf881070 00010000 bf881040 bf881070     p.......@...p...
9d00e3c4:	00020000 bf881040 bf881070 00040000     ....@...p.......
9d00e3d4:	bf881040 bf881070 00080000 bf881040     @...p.......@...
9d00e3e4:	bf881070 00100000 bf881040 bf881070     p.......@...p...
9d00e3f4:	00200000 bf881040 bf881070 00400000     .. .@...p.....@.
9d00e404:	bf881040 bf881070 00800000 bf881040     @...p.......@...
9d00e414:	bf881070 02000000 bf881040 bf881070     p.......@...p...
9d00e424:	04000000 bf881040 bf881070 08000000     ....@...p.......
9d00e434:	bf881040 bf881070 10000000              @...p.......

9d00e440 <__IntVectorTbl>:
9d00e440:	bf881090 00000000 00000002 bf881090     ................
9d00e450:	00000008 0000000a bf881090 00000010     ................
9d00e460:	00000012 bf881090 00000018 0000001a     ................
9d00e470:	bf8810a0 00000018 0000001a bf8810b0     ................
9d00e480:	00000018 0000001a bf8810c0 00000018     ................
9d00e490:	0000001a bf8810d0 00000018 0000001a     ................
9d00e4a0:	bf8810a0 00000000 00000002 bf8810b0     ................
9d00e4b0:	00000000 00000002 bf8810c0 00000000     ................
9d00e4c0:	00000002 bf8810d0 00000000 00000002     ................
9d00e4d0:	bf8810e0 00000000 00000002 bf8810a0     ................
9d00e4e0:	00000008 0000000a bf8810b0 00000008     ................
9d00e4f0:	0000000a bf8810c0 00000008 0000000a     ................
9d00e500:	bf8810d0 00000008 0000000a bf8810e0     ................
9d00e510:	00000008 0000000a bf8810a0 00000010     ................
9d00e520:	00000012 bf8810b0 00000010 00000012     ................
9d00e530:	bf8810c0 00000010 00000012 bf8810d0     ................
9d00e540:	00000010 00000012 bf8810e0 00000010     ................
9d00e550:	00000012 bf8810e0 00000018 0000001a     ................
9d00e560:	bf881100 00000018 0000001a bf8810f0     ................
9d00e570:	00000000 00000002 bf881110 00000000     ................
9d00e580:	00000002 bf8810f0 00000000 00000002     ................
9d00e590:	bf881110 00000000 00000002 bf881100     ................
9d00e5a0:	00000018 0000001a bf881150 00000008     ........P.......
9d00e5b0:	0000000a bf881150 00000018 0000001a     ....P...........
9d00e5c0:	bf881150 00000010 00000012 bf8810f0     P...............
9d00e5d0:	00000008 0000000a bf881110 00000008     ................
9d00e5e0:	0000000a bf8810f0 00000000 00000002     ................
9d00e5f0:	bf881100 00000018 0000001a bf881110     ................
9d00e600:	00000000 00000002 bf8810f0 00000010     ................
9d00e610:	00000012 bf8810f0 00000018 0000001a     ................
9d00e620:	bf881100 00000000 00000002 bf881100     ................
9d00e630:	00000008 0000000a bf881100 00000010     ................
9d00e640:	00000012 bf881110 00000010 00000012     ................
9d00e650:	bf881110 00000018 0000001a bf881120     ............ ...
9d00e660:	00000000 00000002 bf881120 00000008     ........ .......
9d00e670:	0000000a bf881120 00000010 00000012     .... ...........
9d00e680:	bf881120 00000018 0000001a bf881130      ...........0...
9d00e690:	00000000 00000002 bf881130 00000008     ........0.......
9d00e6a0:	0000000a bf881130 00000010 00000012     ....0...........
9d00e6b0:	bf881130 00000018 0000001a bf881140     0...........@...
9d00e6c0:	00000000 00000002 bf881140 00000008     ........@.......
9d00e6d0:	0000000a bf881140 00000010 00000012     ....@...........
9d00e6e0:	bf881140 00000018 0000001a bf881150     @...........P...
9d00e6f0:	00000000 00000002                       ........

9d00e6f8 <PortRegTbl>:
9d00e6f8:	bf886000 00000000 00000000 bf886040     .`..........@`..
9d00e708:	0000ffff bf809060 bf886080 00000000     ....`....`......
9d00e718:	00000000 bf8860c0 00000000 00000000     .....`..........
9d00e728:	bf886100 00000000 00000000 bf886140     .a..........@a..
	...
9d00e740:	bf886180 00000000 00000000              .a..........
